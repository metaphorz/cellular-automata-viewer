function bP(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();function Ob(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function SP(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var ey={exports:{}},Nh={},ty={exports:{}},Zt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yT;function wP(){if(yT)return Zt;yT=1;var n=Symbol.for("react.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),o=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),d=Symbol.iterator;function p(U){return U===null||typeof U!="object"?null:(U=d&&U[d]||U["@@iterator"],typeof U=="function"?U:null)}var m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,b={};function y(U,z,ne){this.props=U,this.context=z,this.refs=b,this.updater=ne||m}y.prototype.isReactComponent={},y.prototype.setState=function(U,z){if(typeof U!="object"&&typeof U!="function"&&U!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,U,z,"setState")},y.prototype.forceUpdate=function(U){this.updater.enqueueForceUpdate(this,U,"forceUpdate")};function v(){}v.prototype=y.prototype;function S(U,z,ne){this.props=U,this.context=z,this.refs=b,this.updater=ne||m}var C=S.prototype=new v;C.constructor=S,g(C,y.prototype),C.isPureReactComponent=!0;var _=Array.isArray,A=Object.prototype.hasOwnProperty,k={current:null},N={key:!0,ref:!0,__self:!0,__source:!0};function D(U,z,ne){var Y,te={},he=null,se=null;if(z!=null)for(Y in z.ref!==void 0&&(se=z.ref),z.key!==void 0&&(he=""+z.key),z)A.call(z,Y)&&!N.hasOwnProperty(Y)&&(te[Y]=z[Y]);var Q=arguments.length-2;if(Q===1)te.children=ne;else if(1<Q){for(var de=Array(Q),ce=0;ce<Q;ce++)de[ce]=arguments[ce+2];te.children=de}if(U&&U.defaultProps)for(Y in Q=U.defaultProps,Q)te[Y]===void 0&&(te[Y]=Q[Y]);return{$$typeof:n,type:U,key:he,ref:se,props:te,_owner:k.current}}function M(U,z){return{$$typeof:n,type:U.type,key:z,ref:U.ref,props:U.props,_owner:U._owner}}function T(U){return typeof U=="object"&&U!==null&&U.$$typeof===n}function I(U){var z={"=":"=0",":":"=2"};return"$"+U.replace(/[=:]/g,function(ne){return z[ne]})}var $=/\/+/g;function O(U,z){return typeof U=="object"&&U!==null&&U.key!=null?I(""+U.key):z.toString(36)}function B(U,z,ne,Y,te){var he=typeof U;(he==="undefined"||he==="boolean")&&(U=null);var se=!1;if(U===null)se=!0;else switch(he){case"string":case"number":se=!0;break;case"object":switch(U.$$typeof){case n:case e:se=!0}}if(se)return se=U,te=te(se),U=Y===""?"."+O(se,0):Y,_(te)?(ne="",U!=null&&(ne=U.replace($,"$&/")+"/"),B(te,z,ne,"",function(ce){return ce})):te!=null&&(T(te)&&(te=M(te,ne+(!te.key||se&&se.key===te.key?"":(""+te.key).replace($,"$&/")+"/")+U)),z.push(te)),1;if(se=0,Y=Y===""?".":Y+":",_(U))for(var Q=0;Q<U.length;Q++){he=U[Q];var de=Y+O(he,Q);se+=B(he,z,ne,de,te)}else if(de=p(U),typeof de=="function")for(U=de.call(U),Q=0;!(he=U.next()).done;)he=he.value,de=Y+O(he,Q++),se+=B(he,z,ne,de,te);else if(he==="object")throw z=String(U),Error("Objects are not valid as a React child (found: "+(z==="[object Object]"?"object with keys {"+Object.keys(U).join(", ")+"}":z)+"). If you meant to render a collection of children, use an array instead.");return se}function V(U,z,ne){if(U==null)return U;var Y=[],te=0;return B(U,Y,"","",function(he){return z.call(ne,he,te++)}),Y}function H(U){if(U._status===-1){var z=U._result;z=z(),z.then(function(ne){(U._status===0||U._status===-1)&&(U._status=1,U._result=ne)},function(ne){(U._status===0||U._status===-1)&&(U._status=2,U._result=ne)}),U._status===-1&&(U._status=0,U._result=z)}if(U._status===1)return U._result.default;throw U._result}var q={current:null},P={transition:null},K={ReactCurrentDispatcher:q,ReactCurrentBatchConfig:P,ReactCurrentOwner:k};function Z(){throw Error("act(...) is not supported in production builds of React.")}return Zt.Children={map:V,forEach:function(U,z,ne){V(U,function(){z.apply(this,arguments)},ne)},count:function(U){var z=0;return V(U,function(){z++}),z},toArray:function(U){return V(U,function(z){return z})||[]},only:function(U){if(!T(U))throw Error("React.Children.only expected to receive a single React element child.");return U}},Zt.Component=y,Zt.Fragment=t,Zt.Profiler=r,Zt.PureComponent=S,Zt.StrictMode=s,Zt.Suspense=l,Zt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=K,Zt.act=Z,Zt.cloneElement=function(U,z,ne){if(U==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+U+".");var Y=g({},U.props),te=U.key,he=U.ref,se=U._owner;if(z!=null){if(z.ref!==void 0&&(he=z.ref,se=k.current),z.key!==void 0&&(te=""+z.key),U.type&&U.type.defaultProps)var Q=U.type.defaultProps;for(de in z)A.call(z,de)&&!N.hasOwnProperty(de)&&(Y[de]=z[de]===void 0&&Q!==void 0?Q[de]:z[de])}var de=arguments.length-2;if(de===1)Y.children=ne;else if(1<de){Q=Array(de);for(var ce=0;ce<de;ce++)Q[ce]=arguments[ce+2];Y.children=Q}return{$$typeof:n,type:U.type,key:te,ref:he,props:Y,_owner:se}},Zt.createContext=function(U){return U={$$typeof:o,_currentValue:U,_currentValue2:U,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},U.Provider={$$typeof:i,_context:U},U.Consumer=U},Zt.createElement=D,Zt.createFactory=function(U){var z=D.bind(null,U);return z.type=U,z},Zt.createRef=function(){return{current:null}},Zt.forwardRef=function(U){return{$$typeof:a,render:U}},Zt.isValidElement=T,Zt.lazy=function(U){return{$$typeof:h,_payload:{_status:-1,_result:U},_init:H}},Zt.memo=function(U,z){return{$$typeof:c,type:U,compare:z===void 0?null:z}},Zt.startTransition=function(U){var z=P.transition;P.transition={};try{U()}finally{P.transition=z}},Zt.unstable_act=Z,Zt.useCallback=function(U,z){return q.current.useCallback(U,z)},Zt.useContext=function(U){return q.current.useContext(U)},Zt.useDebugValue=function(){},Zt.useDeferredValue=function(U){return q.current.useDeferredValue(U)},Zt.useEffect=function(U,z){return q.current.useEffect(U,z)},Zt.useId=function(){return q.current.useId()},Zt.useImperativeHandle=function(U,z,ne){return q.current.useImperativeHandle(U,z,ne)},Zt.useInsertionEffect=function(U,z){return q.current.useInsertionEffect(U,z)},Zt.useLayoutEffect=function(U,z){return q.current.useLayoutEffect(U,z)},Zt.useMemo=function(U,z){return q.current.useMemo(U,z)},Zt.useReducer=function(U,z,ne){return q.current.useReducer(U,z,ne)},Zt.useRef=function(U){return q.current.useRef(U)},Zt.useState=function(U){return q.current.useState(U)},Zt.useSyncExternalStore=function(U,z,ne){return q.current.useSyncExternalStore(U,z,ne)},Zt.useTransition=function(){return q.current.useTransition()},Zt.version="18.3.1",Zt}var bT;function Ub(){return bT||(bT=1,ty.exports=wP()),ty.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ST;function _P(){if(ST)return Nh;ST=1;var n=Ub(),e=Symbol.for("react.element"),t=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i={key:!0,ref:!0,__self:!0,__source:!0};function o(a,l,c){var h,d={},p=null,m=null;c!==void 0&&(p=""+c),l.key!==void 0&&(p=""+l.key),l.ref!==void 0&&(m=l.ref);for(h in l)s.call(l,h)&&!i.hasOwnProperty(h)&&(d[h]=l[h]);if(a&&a.defaultProps)for(h in l=a.defaultProps,l)d[h]===void 0&&(d[h]=l[h]);return{$$typeof:e,type:a,key:p,ref:m,props:d,_owner:r.current}}return Nh.Fragment=t,Nh.jsx=o,Nh.jsxs=o,Nh}var wT;function CP(){return wT||(wT=1,ey.exports=_P()),ey.exports}var pe=CP(),Ae=Ub();const EP=Ob(Ae);var Zp={},ny={exports:{}},Ar={},sy={exports:{}},ry={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _T;function TP(){return _T||(_T=1,function(n){function e(P,K){var Z=P.length;P.push(K);e:for(;0<Z;){var U=Z-1>>>1,z=P[U];if(0<r(z,K))P[U]=K,P[Z]=z,Z=U;else break e}}function t(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var K=P[0],Z=P.pop();if(Z!==K){P[0]=Z;e:for(var U=0,z=P.length,ne=z>>>1;U<ne;){var Y=2*(U+1)-1,te=P[Y],he=Y+1,se=P[he];if(0>r(te,Z))he<z&&0>r(se,te)?(P[U]=se,P[he]=Z,U=he):(P[U]=te,P[Y]=Z,U=Y);else if(he<z&&0>r(se,Z))P[U]=se,P[he]=Z,U=he;else break e}}return K}function r(P,K){var Z=P.sortIndex-K.sortIndex;return Z!==0?Z:P.id-K.id}if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],c=[],h=1,d=null,p=3,m=!1,g=!1,b=!1,y=typeof setTimeout=="function"?setTimeout:null,v=typeof clearTimeout=="function"?clearTimeout:null,S=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function C(P){for(var K=t(c);K!==null;){if(K.callback===null)s(c);else if(K.startTime<=P)s(c),K.sortIndex=K.expirationTime,e(l,K);else break;K=t(c)}}function _(P){if(b=!1,C(P),!g)if(t(l)!==null)g=!0,H(A);else{var K=t(c);K!==null&&q(_,K.startTime-P)}}function A(P,K){g=!1,b&&(b=!1,v(D),D=-1),m=!0;var Z=p;try{for(C(K),d=t(l);d!==null&&(!(d.expirationTime>K)||P&&!I());){var U=d.callback;if(typeof U=="function"){d.callback=null,p=d.priorityLevel;var z=U(d.expirationTime<=K);K=n.unstable_now(),typeof z=="function"?d.callback=z:d===t(l)&&s(l),C(K)}else s(l);d=t(l)}if(d!==null)var ne=!0;else{var Y=t(c);Y!==null&&q(_,Y.startTime-K),ne=!1}return ne}finally{d=null,p=Z,m=!1}}var k=!1,N=null,D=-1,M=5,T=-1;function I(){return!(n.unstable_now()-T<M)}function $(){if(N!==null){var P=n.unstable_now();T=P;var K=!0;try{K=N(!0,P)}finally{K?O():(k=!1,N=null)}}else k=!1}var O;if(typeof S=="function")O=function(){S($)};else if(typeof MessageChannel<"u"){var B=new MessageChannel,V=B.port2;B.port1.onmessage=$,O=function(){V.postMessage(null)}}else O=function(){y($,0)};function H(P){N=P,k||(k=!0,O())}function q(P,K){D=y(function(){P(n.unstable_now())},K)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_continueExecution=function(){g||m||(g=!0,H(A))},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return p},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(P){switch(p){case 1:case 2:case 3:var K=3;break;default:K=p}var Z=p;p=K;try{return P()}finally{p=Z}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(P,K){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var Z=p;p=P;try{return K()}finally{p=Z}},n.unstable_scheduleCallback=function(P,K,Z){var U=n.unstable_now();switch(typeof Z=="object"&&Z!==null?(Z=Z.delay,Z=typeof Z=="number"&&0<Z?U+Z:U):Z=U,P){case 1:var z=-1;break;case 2:z=250;break;case 5:z=1073741823;break;case 4:z=1e4;break;default:z=5e3}return z=Z+z,P={id:h++,callback:K,priorityLevel:P,startTime:Z,expirationTime:z,sortIndex:-1},Z>U?(P.sortIndex=Z,e(c,P),t(l)===null&&P===t(c)&&(b?(v(D),D=-1):b=!0,q(_,Z-U))):(P.sortIndex=z,e(l,P),g||m||(g=!0,H(A))),P},n.unstable_shouldYield=I,n.unstable_wrapCallback=function(P){var K=p;return function(){var Z=p;p=K;try{return P.apply(this,arguments)}finally{p=Z}}}}(ry)),ry}var CT;function IP(){return CT||(CT=1,sy.exports=TP()),sy.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ET;function AP(){if(ET)return Ar;ET=1;var n=Ub(),e=IP();function t(u){for(var f="https://reactjs.org/docs/error-decoder.html?invariant="+u,x=1;x<arguments.length;x++)f+="&args[]="+encodeURIComponent(arguments[x]);return"Minified React error #"+u+"; visit "+f+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var s=new Set,r={};function i(u,f){o(u,f),o(u+"Capture",f)}function o(u,f){for(r[u]=f,u=0;u<f.length;u++)s.add(f[u])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,c=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,h={},d={};function p(u){return l.call(d,u)?!0:l.call(h,u)?!1:c.test(u)?d[u]=!0:(h[u]=!0,!1)}function m(u,f,x,w){if(x!==null&&x.type===0)return!1;switch(typeof f){case"function":case"symbol":return!0;case"boolean":return w?!1:x!==null?!x.acceptsBooleans:(u=u.toLowerCase().slice(0,5),u!=="data-"&&u!=="aria-");default:return!1}}function g(u,f,x,w){if(f===null||typeof f>"u"||m(u,f,x,w))return!0;if(w)return!1;if(x!==null)switch(x.type){case 3:return!f;case 4:return f===!1;case 5:return isNaN(f);case 6:return isNaN(f)||1>f}return!1}function b(u,f,x,w,E,R,F){this.acceptsBooleans=f===2||f===3||f===4,this.attributeName=w,this.attributeNamespace=E,this.mustUseProperty=x,this.propertyName=u,this.type=f,this.sanitizeURL=R,this.removeEmptyString=F}var y={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(u){y[u]=new b(u,0,!1,u,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(u){var f=u[0];y[f]=new b(f,1,!1,u[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(u){y[u]=new b(u,2,!1,u.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(u){y[u]=new b(u,2,!1,u,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(u){y[u]=new b(u,3,!1,u.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(u){y[u]=new b(u,3,!0,u,null,!1,!1)}),["capture","download"].forEach(function(u){y[u]=new b(u,4,!1,u,null,!1,!1)}),["cols","rows","size","span"].forEach(function(u){y[u]=new b(u,6,!1,u,null,!1,!1)}),["rowSpan","start"].forEach(function(u){y[u]=new b(u,5,!1,u.toLowerCase(),null,!1,!1)});var v=/[\-:]([a-z])/g;function S(u){return u[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(u){var f=u.replace(v,S);y[f]=new b(f,1,!1,u,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(u){var f=u.replace(v,S);y[f]=new b(f,1,!1,u,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(u){var f=u.replace(v,S);y[f]=new b(f,1,!1,u,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(u){y[u]=new b(u,1,!1,u.toLowerCase(),null,!1,!1)}),y.xlinkHref=new b("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(u){y[u]=new b(u,1,!1,u.toLowerCase(),null,!0,!0)});function C(u,f,x,w){var E=y.hasOwnProperty(f)?y[f]:null;(E!==null?E.type!==0:w||!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(g(f,x,E,w)&&(x=null),w||E===null?p(f)&&(x===null?u.removeAttribute(f):u.setAttribute(f,""+x)):E.mustUseProperty?u[E.propertyName]=x===null?E.type===3?!1:"":x:(f=E.attributeName,w=E.attributeNamespace,x===null?u.removeAttribute(f):(E=E.type,x=E===3||E===4&&x===!0?"":""+x,w?u.setAttributeNS(w,f,x):u.setAttribute(f,x))))}var _=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,A=Symbol.for("react.element"),k=Symbol.for("react.portal"),N=Symbol.for("react.fragment"),D=Symbol.for("react.strict_mode"),M=Symbol.for("react.profiler"),T=Symbol.for("react.provider"),I=Symbol.for("react.context"),$=Symbol.for("react.forward_ref"),O=Symbol.for("react.suspense"),B=Symbol.for("react.suspense_list"),V=Symbol.for("react.memo"),H=Symbol.for("react.lazy"),q=Symbol.for("react.offscreen"),P=Symbol.iterator;function K(u){return u===null||typeof u!="object"?null:(u=P&&u[P]||u["@@iterator"],typeof u=="function"?u:null)}var Z=Object.assign,U;function z(u){if(U===void 0)try{throw Error()}catch(x){var f=x.stack.trim().match(/\n( *(at )?)/);U=f&&f[1]||""}return`
`+U+u}var ne=!1;function Y(u,f){if(!u||ne)return"";ne=!0;var x=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(f)if(f=function(){throw Error()},Object.defineProperty(f.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(f,[])}catch(Ee){var w=Ee}Reflect.construct(u,[],f)}else{try{f.call()}catch(Ee){w=Ee}u.call(f.prototype)}else{try{throw Error()}catch(Ee){w=Ee}u()}}catch(Ee){if(Ee&&w&&typeof Ee.stack=="string"){for(var E=Ee.stack.split(`
`),R=w.stack.split(`
`),F=E.length-1,J=R.length-1;1<=F&&0<=J&&E[F]!==R[J];)J--;for(;1<=F&&0<=J;F--,J--)if(E[F]!==R[J]){if(F!==1||J!==1)do if(F--,J--,0>J||E[F]!==R[J]){var re=`
`+E[F].replace(" at new "," at ");return u.displayName&&re.includes("<anonymous>")&&(re=re.replace("<anonymous>",u.displayName)),re}while(1<=F&&0<=J);break}}}finally{ne=!1,Error.prepareStackTrace=x}return(u=u?u.displayName||u.name:"")?z(u):""}function te(u){switch(u.tag){case 5:return z(u.type);case 16:return z("Lazy");case 13:return z("Suspense");case 19:return z("SuspenseList");case 0:case 2:case 15:return u=Y(u.type,!1),u;case 11:return u=Y(u.type.render,!1),u;case 1:return u=Y(u.type,!0),u;default:return""}}function he(u){if(u==null)return null;if(typeof u=="function")return u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case N:return"Fragment";case k:return"Portal";case M:return"Profiler";case D:return"StrictMode";case O:return"Suspense";case B:return"SuspenseList"}if(typeof u=="object")switch(u.$$typeof){case I:return(u.displayName||"Context")+".Consumer";case T:return(u._context.displayName||"Context")+".Provider";case $:var f=u.render;return u=u.displayName,u||(u=f.displayName||f.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case V:return f=u.displayName||null,f!==null?f:he(u.type)||"Memo";case H:f=u._payload,u=u._init;try{return he(u(f))}catch{}}return null}function se(u){var f=u.type;switch(u.tag){case 24:return"Cache";case 9:return(f.displayName||"Context")+".Consumer";case 10:return(f._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return u=f.render,u=u.displayName||u.name||"",f.displayName||(u!==""?"ForwardRef("+u+")":"ForwardRef");case 7:return"Fragment";case 5:return f;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return he(f);case 8:return f===D?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof f=="function")return f.displayName||f.name||null;if(typeof f=="string")return f}return null}function Q(u){switch(typeof u){case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function de(u){var f=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(f==="checkbox"||f==="radio")}function ce(u){var f=de(u)?"checked":"value",x=Object.getOwnPropertyDescriptor(u.constructor.prototype,f),w=""+u[f];if(!u.hasOwnProperty(f)&&typeof x<"u"&&typeof x.get=="function"&&typeof x.set=="function"){var E=x.get,R=x.set;return Object.defineProperty(u,f,{configurable:!0,get:function(){return E.call(this)},set:function(F){w=""+F,R.call(this,F)}}),Object.defineProperty(u,f,{enumerable:x.enumerable}),{getValue:function(){return w},setValue:function(F){w=""+F},stopTracking:function(){u._valueTracker=null,delete u[f]}}}}function De(u){u._valueTracker||(u._valueTracker=ce(u))}function He(u){if(!u)return!1;var f=u._valueTracker;if(!f)return!0;var x=f.getValue(),w="";return u&&(w=de(u)?u.checked?"true":"false":u.value),u=w,u!==x?(f.setValue(u),!0):!1}function Le(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}function j(u,f){var x=f.checked;return Z({},f,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:x??u._wrapperState.initialChecked})}function ht(u,f){var x=f.defaultValue==null?"":f.defaultValue,w=f.checked!=null?f.checked:f.defaultChecked;x=Q(f.value!=null?f.value:x),u._wrapperState={initialChecked:w,initialValue:x,controlled:f.type==="checkbox"||f.type==="radio"?f.checked!=null:f.value!=null}}function We(u,f){f=f.checked,f!=null&&C(u,"checked",f,!1)}function Ke(u,f){We(u,f);var x=Q(f.value),w=f.type;if(x!=null)w==="number"?(x===0&&u.value===""||u.value!=x)&&(u.value=""+x):u.value!==""+x&&(u.value=""+x);else if(w==="submit"||w==="reset"){u.removeAttribute("value");return}f.hasOwnProperty("value")?yt(u,f.type,x):f.hasOwnProperty("defaultValue")&&yt(u,f.type,Q(f.defaultValue)),f.checked==null&&f.defaultChecked!=null&&(u.defaultChecked=!!f.defaultChecked)}function Oe(u,f,x){if(f.hasOwnProperty("value")||f.hasOwnProperty("defaultValue")){var w=f.type;if(!(w!=="submit"&&w!=="reset"||f.value!==void 0&&f.value!==null))return;f=""+u._wrapperState.initialValue,x||f===u.value||(u.value=f),u.defaultValue=f}x=u.name,x!==""&&(u.name=""),u.defaultChecked=!!u._wrapperState.initialChecked,x!==""&&(u.name=x)}function yt(u,f,x){(f!=="number"||Le(u.ownerDocument)!==u)&&(x==null?u.defaultValue=""+u._wrapperState.initialValue:u.defaultValue!==""+x&&(u.defaultValue=""+x))}var Ve=Array.isArray;function X(u,f,x,w){if(u=u.options,f){f={};for(var E=0;E<x.length;E++)f["$"+x[E]]=!0;for(x=0;x<u.length;x++)E=f.hasOwnProperty("$"+u[x].value),u[x].selected!==E&&(u[x].selected=E),E&&w&&(u[x].defaultSelected=!0)}else{for(x=""+Q(x),f=null,E=0;E<u.length;E++){if(u[E].value===x){u[E].selected=!0,w&&(u[E].defaultSelected=!0);return}f!==null||u[E].disabled||(f=u[E])}f!==null&&(f.selected=!0)}}function L(u,f){if(f.dangerouslySetInnerHTML!=null)throw Error(t(91));return Z({},f,{value:void 0,defaultValue:void 0,children:""+u._wrapperState.initialValue})}function ge(u,f){var x=f.value;if(x==null){if(x=f.children,f=f.defaultValue,x!=null){if(f!=null)throw Error(t(92));if(Ve(x)){if(1<x.length)throw Error(t(93));x=x[0]}f=x}f==null&&(f=""),x=f}u._wrapperState={initialValue:Q(x)}}function Re(u,f){var x=Q(f.value),w=Q(f.defaultValue);x!=null&&(x=""+x,x!==u.value&&(u.value=x),f.defaultValue==null&&u.defaultValue!==x&&(u.defaultValue=x)),w!=null&&(u.defaultValue=""+w)}function $e(u){var f=u.textContent;f===u._wrapperState.initialValue&&f!==""&&f!==null&&(u.value=f)}function Ie(u){switch(u){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Xe(u,f){return u==null||u==="http://www.w3.org/1999/xhtml"?Ie(f):u==="http://www.w3.org/2000/svg"&&f==="foreignObject"?"http://www.w3.org/1999/xhtml":u}var ze,et=function(u){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(f,x,w,E){MSApp.execUnsafeLocalFunction(function(){return u(f,x,w,E)})}:u}(function(u,f){if(u.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in u)u.innerHTML=f;else{for(ze=ze||document.createElement("div"),ze.innerHTML="<svg>"+f.valueOf().toString()+"</svg>",f=ze.firstChild;u.firstChild;)u.removeChild(u.firstChild);for(;f.firstChild;)u.appendChild(f.firstChild)}});function ut(u,f){if(f){var x=u.firstChild;if(x&&x===u.lastChild&&x.nodeType===3){x.nodeValue=f;return}}u.textContent=f}var Pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},lt=["Webkit","ms","Moz","O"];Object.keys(Pe).forEach(function(u){lt.forEach(function(f){f=f+u.charAt(0).toUpperCase()+u.substring(1),Pe[f]=Pe[u]})});function wt(u,f,x){return f==null||typeof f=="boolean"||f===""?"":x||typeof f!="number"||f===0||Pe.hasOwnProperty(u)&&Pe[u]?(""+f).trim():f+"px"}function Et(u,f){u=u.style;for(var x in f)if(f.hasOwnProperty(x)){var w=x.indexOf("--")===0,E=wt(x,f[x],w);x==="float"&&(x="cssFloat"),w?u.setProperty(x,E):u[x]=E}}var ct=Z({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Ot(u,f){if(f){if(ct[u]&&(f.children!=null||f.dangerouslySetInnerHTML!=null))throw Error(t(137,u));if(f.dangerouslySetInnerHTML!=null){if(f.children!=null)throw Error(t(60));if(typeof f.dangerouslySetInnerHTML!="object"||!("__html"in f.dangerouslySetInnerHTML))throw Error(t(61))}if(f.style!=null&&typeof f.style!="object")throw Error(t(62))}}function $t(u,f){if(u.indexOf("-")===-1)return typeof f.is=="string";switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var hn=null;function ue(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var tt=null,ke=null,Fe=null;function it(u){if(u=xh(u)){if(typeof tt!="function")throw Error(t(280));var f=u.stateNode;f&&(f=dp(f),tt(u.stateNode,u.type,f))}}function nt(u){ke?Fe?Fe.push(u):Fe=[u]:ke=u}function Pt(){if(ke){var u=ke,f=Fe;if(Fe=ke=null,it(u),f)for(u=0;u<f.length;u++)it(f[u])}}function Sn(u,f){return u(f)}function Jn(){}var tn=!1;function Cn(u,f,x){if(tn)return u(f,x);tn=!0;try{return Sn(u,f,x)}finally{tn=!1,(ke!==null||Fe!==null)&&(Jn(),Pt())}}function Ye(u,f){var x=u.stateNode;if(x===null)return null;var w=dp(x);if(w===null)return null;x=w[f];e:switch(f){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(w=!w.disabled)||(u=u.type,w=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!w;break e;default:u=!1}if(u)return null;if(x&&typeof x!="function")throw Error(t(231,f,typeof x));return x}var Bt=!1;if(a)try{var es={};Object.defineProperty(es,"passive",{get:function(){Bt=!0}}),window.addEventListener("test",es,es),window.removeEventListener("test",es,es)}catch{Bt=!1}function xn(u,f,x,w,E,R,F,J,re){var Ee=Array.prototype.slice.call(arguments,3);try{f.apply(x,Ee)}catch(Ge){this.onError(Ge)}}var ts=!1,rl=null,il=!1,Jo=null,Wf={onError:function(u){ts=!0,rl=u}};function xc(u,f,x,w,E,R,F,J,re){ts=!1,rl=null,xn.apply(Wf,arguments)}function Hf(u,f,x,w,E,R,F,J,re){if(xc.apply(this,arguments),ts){if(ts){var Ee=rl;ts=!1,rl=null}else throw Error(t(198));il||(il=!0,Jo=Ee)}}function Wi(u){var f=u,x=u;if(u.alternate)for(;f.return;)f=f.return;else{u=f;do f=u,(f.flags&4098)!==0&&(x=f.return),u=f.return;while(u)}return f.tag===3?x:null}function Xf(u){if(u.tag===13){var f=u.memoizedState;if(f===null&&(u=u.alternate,u!==null&&(f=u.memoizedState)),f!==null)return f.dehydrated}return null}function jf(u){if(Wi(u)!==u)throw Error(t(188))}function _x(u){var f=u.alternate;if(!f){if(f=Wi(u),f===null)throw Error(t(188));return f!==u?null:u}for(var x=u,w=f;;){var E=x.return;if(E===null)break;var R=E.alternate;if(R===null){if(w=E.return,w!==null){x=w;continue}break}if(E.child===R.child){for(R=E.child;R;){if(R===x)return jf(E),u;if(R===w)return jf(E),f;R=R.sibling}throw Error(t(188))}if(x.return!==w.return)x=E,w=R;else{for(var F=!1,J=E.child;J;){if(J===x){F=!0,x=E,w=R;break}if(J===w){F=!0,w=E,x=R;break}J=J.sibling}if(!F){for(J=R.child;J;){if(J===x){F=!0,x=R,w=E;break}if(J===w){F=!0,w=R,x=E;break}J=J.sibling}if(!F)throw Error(t(189))}}if(x.alternate!==w)throw Error(t(190))}if(x.tag!==3)throw Error(t(188));return x.stateNode.current===x?u:f}function qf(u){return u=_x(u),u!==null?Kf(u):null}function Kf(u){if(u.tag===5||u.tag===6)return u;for(u=u.child;u!==null;){var f=Kf(u);if(f!==null)return f;u=u.sibling}return null}var Yf=e.unstable_scheduleCallback,G=e.unstable_cancelCallback,xe=e.unstable_shouldYield,Te=e.unstable_requestPaint,Se=e.unstable_now,ve=e.unstable_getCurrentPriorityLevel,Ze=e.unstable_ImmediatePriority,st=e.unstable_UserBlockingPriority,dt=e.unstable_NormalPriority,mt=e.unstable_LowPriority,Ft=e.unstable_IdlePriority,kt=null,bt=null;function nn(u){if(bt&&typeof bt.onCommitFiberRoot=="function")try{bt.onCommitFiberRoot(kt,u,void 0,(u.current.flags&128)===128)}catch{}}var Vt=Math.clz32?Math.clz32:an,Gn=Math.log,Pn=Math.LN2;function an(u){return u>>>=0,u===0?32:31-(Gn(u)/Pn|0)|0}var Tt=64,Wn=4194304;function Qt(u){switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return u&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return u}}function Hs(u,f){var x=u.pendingLanes;if(x===0)return 0;var w=0,E=u.suspendedLanes,R=u.pingedLanes,F=x&268435455;if(F!==0){var J=F&~E;J!==0?w=Qt(J):(R&=F,R!==0&&(w=Qt(R)))}else F=x&~E,F!==0?w=Qt(F):R!==0&&(w=Qt(R));if(w===0)return 0;if(f!==0&&f!==w&&(f&E)===0&&(E=w&-w,R=f&-f,E>=R||E===16&&(R&4194240)!==0))return f;if((w&4)!==0&&(w|=x&16),f=u.entangledLanes,f!==0)for(u=u.entanglements,f&=w;0<f;)x=31-Vt(f),E=1<<x,w|=u[x],f&=~E;return w}function ea(u,f){switch(u){case 1:case 2:case 4:return f+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function lr(u,f){for(var x=u.suspendedLanes,w=u.pingedLanes,E=u.expirationTimes,R=u.pendingLanes;0<R;){var F=31-Vt(R),J=1<<F,re=E[F];re===-1?((J&x)===0||(J&w)!==0)&&(E[F]=ea(J,f)):re<=f&&(u.expiredLanes|=J),R&=~J}}function So(u){return u=u.pendingLanes&-1073741825,u!==0?u:u&1073741824?1073741824:0}function En(){var u=Tt;return Tt<<=1,(Tt&4194240)===0&&(Tt=64),u}function Xs(u){for(var f=[],x=0;31>x;x++)f.push(u);return f}function _s(u,f,x){u.pendingLanes|=f,f!==536870912&&(u.suspendedLanes=0,u.pingedLanes=0),u=u.eventTimes,f=31-Vt(f),u[f]=x}function Fs(u,f){var x=u.pendingLanes&~f;u.pendingLanes=f,u.suspendedLanes=0,u.pingedLanes=0,u.expiredLanes&=f,u.mutableReadLanes&=f,u.entangledLanes&=f,f=u.entanglements;var w=u.eventTimes;for(u=u.expirationTimes;0<x;){var E=31-Vt(x),R=1<<E;f[E]=0,w[E]=-1,u[E]=-1,x&=~R}}function Cs(u,f){var x=u.entangledLanes|=f;for(u=u.entanglements;x;){var w=31-Vt(x),E=1<<w;E&f|u[w]&f&&(u[w]|=f),x&=~E}}var cn=0;function Hi(u){return u&=-u,1<u?4<u?(u&268435455)!==0?16:536870912:4:1}var Q_,Cx,J_,eC,tC,Ex=!1,Zf=[],ta=null,na=null,sa=null,th=new Map,nh=new Map,ra=[],VF="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function nC(u,f){switch(u){case"focusin":case"focusout":ta=null;break;case"dragenter":case"dragleave":na=null;break;case"mouseover":case"mouseout":sa=null;break;case"pointerover":case"pointerout":th.delete(f.pointerId);break;case"gotpointercapture":case"lostpointercapture":nh.delete(f.pointerId)}}function sh(u,f,x,w,E,R){return u===null||u.nativeEvent!==R?(u={blockedOn:f,domEventName:x,eventSystemFlags:w,nativeEvent:R,targetContainers:[E]},f!==null&&(f=xh(f),f!==null&&Cx(f)),u):(u.eventSystemFlags|=w,f=u.targetContainers,E!==null&&f.indexOf(E)===-1&&f.push(E),u)}function GF(u,f,x,w,E){switch(f){case"focusin":return ta=sh(ta,u,f,x,w,E),!0;case"dragenter":return na=sh(na,u,f,x,w,E),!0;case"mouseover":return sa=sh(sa,u,f,x,w,E),!0;case"pointerover":var R=E.pointerId;return th.set(R,sh(th.get(R)||null,u,f,x,w,E)),!0;case"gotpointercapture":return R=E.pointerId,nh.set(R,sh(nh.get(R)||null,u,f,x,w,E)),!0}return!1}function sC(u){var f=ol(u.target);if(f!==null){var x=Wi(f);if(x!==null){if(f=x.tag,f===13){if(f=Xf(x),f!==null){u.blockedOn=f,tC(u.priority,function(){J_(x)});return}}else if(f===3&&x.stateNode.current.memoizedState.isDehydrated){u.blockedOn=x.tag===3?x.stateNode.containerInfo:null;return}}}u.blockedOn=null}function Qf(u){if(u.blockedOn!==null)return!1;for(var f=u.targetContainers;0<f.length;){var x=Ix(u.domEventName,u.eventSystemFlags,f[0],u.nativeEvent);if(x===null){x=u.nativeEvent;var w=new x.constructor(x.type,x);hn=w,x.target.dispatchEvent(w),hn=null}else return f=xh(x),f!==null&&Cx(f),u.blockedOn=x,!1;f.shift()}return!0}function rC(u,f,x){Qf(u)&&x.delete(f)}function WF(){Ex=!1,ta!==null&&Qf(ta)&&(ta=null),na!==null&&Qf(na)&&(na=null),sa!==null&&Qf(sa)&&(sa=null),th.forEach(rC),nh.forEach(rC)}function rh(u,f){u.blockedOn===f&&(u.blockedOn=null,Ex||(Ex=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,WF)))}function ih(u){function f(E){return rh(E,u)}if(0<Zf.length){rh(Zf[0],u);for(var x=1;x<Zf.length;x++){var w=Zf[x];w.blockedOn===u&&(w.blockedOn=null)}}for(ta!==null&&rh(ta,u),na!==null&&rh(na,u),sa!==null&&rh(sa,u),th.forEach(f),nh.forEach(f),x=0;x<ra.length;x++)w=ra[x],w.blockedOn===u&&(w.blockedOn=null);for(;0<ra.length&&(x=ra[0],x.blockedOn===null);)sC(x),x.blockedOn===null&&ra.shift()}var vc=_.ReactCurrentBatchConfig,Jf=!0;function HF(u,f,x,w){var E=cn,R=vc.transition;vc.transition=null;try{cn=1,Tx(u,f,x,w)}finally{cn=E,vc.transition=R}}function XF(u,f,x,w){var E=cn,R=vc.transition;vc.transition=null;try{cn=4,Tx(u,f,x,w)}finally{cn=E,vc.transition=R}}function Tx(u,f,x,w){if(Jf){var E=Ix(u,f,x,w);if(E===null)Wx(u,f,w,ep,x),nC(u,w);else if(GF(E,u,f,x,w))w.stopPropagation();else if(nC(u,w),f&4&&-1<VF.indexOf(u)){for(;E!==null;){var R=xh(E);if(R!==null&&Q_(R),R=Ix(u,f,x,w),R===null&&Wx(u,f,w,ep,x),R===E)break;E=R}E!==null&&w.stopPropagation()}else Wx(u,f,w,null,x)}}var ep=null;function Ix(u,f,x,w){if(ep=null,u=ue(w),u=ol(u),u!==null)if(f=Wi(u),f===null)u=null;else if(x=f.tag,x===13){if(u=Xf(f),u!==null)return u;u=null}else if(x===3){if(f.stateNode.current.memoizedState.isDehydrated)return f.tag===3?f.stateNode.containerInfo:null;u=null}else f!==u&&(u=null);return ep=u,null}function iC(u){switch(u){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ve()){case Ze:return 1;case st:return 4;case dt:case mt:return 16;case Ft:return 536870912;default:return 16}default:return 16}}var ia=null,Ax=null,tp=null;function oC(){if(tp)return tp;var u,f=Ax,x=f.length,w,E="value"in ia?ia.value:ia.textContent,R=E.length;for(u=0;u<x&&f[u]===E[u];u++);var F=x-u;for(w=1;w<=F&&f[x-w]===E[R-w];w++);return tp=E.slice(u,1<w?1-w:void 0)}function np(u){var f=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&f===13&&(u=13)):u=f,u===10&&(u=13),32<=u||u===13?u:0}function sp(){return!0}function aC(){return!1}function Pr(u){function f(x,w,E,R,F){this._reactName=x,this._targetInst=E,this.type=w,this.nativeEvent=R,this.target=F,this.currentTarget=null;for(var J in u)u.hasOwnProperty(J)&&(x=u[J],this[J]=x?x(R):R[J]);return this.isDefaultPrevented=(R.defaultPrevented!=null?R.defaultPrevented:R.returnValue===!1)?sp:aC,this.isPropagationStopped=aC,this}return Z(f.prototype,{preventDefault:function(){this.defaultPrevented=!0;var x=this.nativeEvent;x&&(x.preventDefault?x.preventDefault():typeof x.returnValue!="unknown"&&(x.returnValue=!1),this.isDefaultPrevented=sp)},stopPropagation:function(){var x=this.nativeEvent;x&&(x.stopPropagation?x.stopPropagation():typeof x.cancelBubble!="unknown"&&(x.cancelBubble=!0),this.isPropagationStopped=sp)},persist:function(){},isPersistent:sp}),f}var yc={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Mx=Pr(yc),oh=Z({},yc,{view:0,detail:0}),jF=Pr(oh),Rx,kx,ah,rp=Z({},oh,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Dx,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==ah&&(ah&&u.type==="mousemove"?(Rx=u.screenX-ah.screenX,kx=u.screenY-ah.screenY):kx=Rx=0,ah=u),Rx)},movementY:function(u){return"movementY"in u?u.movementY:kx}}),lC=Pr(rp),qF=Z({},rp,{dataTransfer:0}),KF=Pr(qF),YF=Z({},oh,{relatedTarget:0}),Nx=Pr(YF),ZF=Z({},yc,{animationName:0,elapsedTime:0,pseudoElement:0}),QF=Pr(ZF),JF=Z({},yc,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),eL=Pr(JF),tL=Z({},yc,{data:0}),cC=Pr(tL),nL={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},sL={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},rL={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function iL(u){var f=this.nativeEvent;return f.getModifierState?f.getModifierState(u):(u=rL[u])?!!f[u]:!1}function Dx(){return iL}var oL=Z({},oh,{key:function(u){if(u.key){var f=nL[u.key]||u.key;if(f!=="Unidentified")return f}return u.type==="keypress"?(u=np(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?sL[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Dx,charCode:function(u){return u.type==="keypress"?np(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?np(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),aL=Pr(oL),lL=Z({},rp,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),uC=Pr(lL),cL=Z({},oh,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Dx}),uL=Pr(cL),hL=Z({},yc,{propertyName:0,elapsedTime:0,pseudoElement:0}),dL=Pr(hL),fL=Z({},rp,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),pL=Pr(fL),mL=[9,13,27,32],$x=a&&"CompositionEvent"in window,lh=null;a&&"documentMode"in document&&(lh=document.documentMode);var gL=a&&"TextEvent"in window&&!lh,hC=a&&(!$x||lh&&8<lh&&11>=lh),dC=" ",fC=!1;function pC(u,f){switch(u){case"keyup":return mL.indexOf(f.keyCode)!==-1;case"keydown":return f.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function mC(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var bc=!1;function xL(u,f){switch(u){case"compositionend":return mC(f);case"keypress":return f.which!==32?null:(fC=!0,dC);case"textInput":return u=f.data,u===dC&&fC?null:u;default:return null}}function vL(u,f){if(bc)return u==="compositionend"||!$x&&pC(u,f)?(u=oC(),tp=Ax=ia=null,bc=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(f.ctrlKey||f.altKey||f.metaKey)||f.ctrlKey&&f.altKey){if(f.char&&1<f.char.length)return f.char;if(f.which)return String.fromCharCode(f.which)}return null;case"compositionend":return hC&&f.locale!=="ko"?null:f.data;default:return null}}var yL={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function gC(u){var f=u&&u.nodeName&&u.nodeName.toLowerCase();return f==="input"?!!yL[u.type]:f==="textarea"}function xC(u,f,x,w){nt(w),f=cp(f,"onChange"),0<f.length&&(x=new Mx("onChange","change",null,x,w),u.push({event:x,listeners:f}))}var ch=null,uh=null;function bL(u){FC(u,0)}function ip(u){var f=Ec(u);if(He(f))return u}function SL(u,f){if(u==="change")return f}var vC=!1;if(a){var Fx;if(a){var Lx="oninput"in document;if(!Lx){var yC=document.createElement("div");yC.setAttribute("oninput","return;"),Lx=typeof yC.oninput=="function"}Fx=Lx}else Fx=!1;vC=Fx&&(!document.documentMode||9<document.documentMode)}function bC(){ch&&(ch.detachEvent("onpropertychange",SC),uh=ch=null)}function SC(u){if(u.propertyName==="value"&&ip(uh)){var f=[];xC(f,uh,u,ue(u)),Cn(bL,f)}}function wL(u,f,x){u==="focusin"?(bC(),ch=f,uh=x,ch.attachEvent("onpropertychange",SC)):u==="focusout"&&bC()}function _L(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return ip(uh)}function CL(u,f){if(u==="click")return ip(f)}function EL(u,f){if(u==="input"||u==="change")return ip(f)}function TL(u,f){return u===f&&(u!==0||1/u===1/f)||u!==u&&f!==f}var yi=typeof Object.is=="function"?Object.is:TL;function hh(u,f){if(yi(u,f))return!0;if(typeof u!="object"||u===null||typeof f!="object"||f===null)return!1;var x=Object.keys(u),w=Object.keys(f);if(x.length!==w.length)return!1;for(w=0;w<x.length;w++){var E=x[w];if(!l.call(f,E)||!yi(u[E],f[E]))return!1}return!0}function wC(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function _C(u,f){var x=wC(u);u=0;for(var w;x;){if(x.nodeType===3){if(w=u+x.textContent.length,u<=f&&w>=f)return{node:x,offset:f-u};u=w}e:{for(;x;){if(x.nextSibling){x=x.nextSibling;break e}x=x.parentNode}x=void 0}x=wC(x)}}function CC(u,f){return u&&f?u===f?!0:u&&u.nodeType===3?!1:f&&f.nodeType===3?CC(u,f.parentNode):"contains"in u?u.contains(f):u.compareDocumentPosition?!!(u.compareDocumentPosition(f)&16):!1:!1}function EC(){for(var u=window,f=Le();f instanceof u.HTMLIFrameElement;){try{var x=typeof f.contentWindow.location.href=="string"}catch{x=!1}if(x)u=f.contentWindow;else break;f=Le(u.document)}return f}function Px(u){var f=u&&u.nodeName&&u.nodeName.toLowerCase();return f&&(f==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||f==="textarea"||u.contentEditable==="true")}function IL(u){var f=EC(),x=u.focusedElem,w=u.selectionRange;if(f!==x&&x&&x.ownerDocument&&CC(x.ownerDocument.documentElement,x)){if(w!==null&&Px(x)){if(f=w.start,u=w.end,u===void 0&&(u=f),"selectionStart"in x)x.selectionStart=f,x.selectionEnd=Math.min(u,x.value.length);else if(u=(f=x.ownerDocument||document)&&f.defaultView||window,u.getSelection){u=u.getSelection();var E=x.textContent.length,R=Math.min(w.start,E);w=w.end===void 0?R:Math.min(w.end,E),!u.extend&&R>w&&(E=w,w=R,R=E),E=_C(x,R);var F=_C(x,w);E&&F&&(u.rangeCount!==1||u.anchorNode!==E.node||u.anchorOffset!==E.offset||u.focusNode!==F.node||u.focusOffset!==F.offset)&&(f=f.createRange(),f.setStart(E.node,E.offset),u.removeAllRanges(),R>w?(u.addRange(f),u.extend(F.node,F.offset)):(f.setEnd(F.node,F.offset),u.addRange(f)))}}for(f=[],u=x;u=u.parentNode;)u.nodeType===1&&f.push({element:u,left:u.scrollLeft,top:u.scrollTop});for(typeof x.focus=="function"&&x.focus(),x=0;x<f.length;x++)u=f[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}}var AL=a&&"documentMode"in document&&11>=document.documentMode,Sc=null,Ox=null,dh=null,Ux=!1;function TC(u,f,x){var w=x.window===x?x.document:x.nodeType===9?x:x.ownerDocument;Ux||Sc==null||Sc!==Le(w)||(w=Sc,"selectionStart"in w&&Px(w)?w={start:w.selectionStart,end:w.selectionEnd}:(w=(w.ownerDocument&&w.ownerDocument.defaultView||window).getSelection(),w={anchorNode:w.anchorNode,anchorOffset:w.anchorOffset,focusNode:w.focusNode,focusOffset:w.focusOffset}),dh&&hh(dh,w)||(dh=w,w=cp(Ox,"onSelect"),0<w.length&&(f=new Mx("onSelect","select",null,f,x),u.push({event:f,listeners:w}),f.target=Sc)))}function op(u,f){var x={};return x[u.toLowerCase()]=f.toLowerCase(),x["Webkit"+u]="webkit"+f,x["Moz"+u]="moz"+f,x}var wc={animationend:op("Animation","AnimationEnd"),animationiteration:op("Animation","AnimationIteration"),animationstart:op("Animation","AnimationStart"),transitionend:op("Transition","TransitionEnd")},zx={},IC={};a&&(IC=document.createElement("div").style,"AnimationEvent"in window||(delete wc.animationend.animation,delete wc.animationiteration.animation,delete wc.animationstart.animation),"TransitionEvent"in window||delete wc.transitionend.transition);function ap(u){if(zx[u])return zx[u];if(!wc[u])return u;var f=wc[u],x;for(x in f)if(f.hasOwnProperty(x)&&x in IC)return zx[u]=f[x];return u}var AC=ap("animationend"),MC=ap("animationiteration"),RC=ap("animationstart"),kC=ap("transitionend"),NC=new Map,DC="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function oa(u,f){NC.set(u,f),i(f,[u])}for(var Bx=0;Bx<DC.length;Bx++){var Vx=DC[Bx],ML=Vx.toLowerCase(),RL=Vx[0].toUpperCase()+Vx.slice(1);oa(ML,"on"+RL)}oa(AC,"onAnimationEnd"),oa(MC,"onAnimationIteration"),oa(RC,"onAnimationStart"),oa("dblclick","onDoubleClick"),oa("focusin","onFocus"),oa("focusout","onBlur"),oa(kC,"onTransitionEnd"),o("onMouseEnter",["mouseout","mouseover"]),o("onMouseLeave",["mouseout","mouseover"]),o("onPointerEnter",["pointerout","pointerover"]),o("onPointerLeave",["pointerout","pointerover"]),i("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),i("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),i("onBeforeInput",["compositionend","keypress","textInput","paste"]),i("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var fh="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),kL=new Set("cancel close invalid load scroll toggle".split(" ").concat(fh));function $C(u,f,x){var w=u.type||"unknown-event";u.currentTarget=x,Hf(w,f,void 0,u),u.currentTarget=null}function FC(u,f){f=(f&4)!==0;for(var x=0;x<u.length;x++){var w=u[x],E=w.event;w=w.listeners;e:{var R=void 0;if(f)for(var F=w.length-1;0<=F;F--){var J=w[F],re=J.instance,Ee=J.currentTarget;if(J=J.listener,re!==R&&E.isPropagationStopped())break e;$C(E,J,Ee),R=re}else for(F=0;F<w.length;F++){if(J=w[F],re=J.instance,Ee=J.currentTarget,J=J.listener,re!==R&&E.isPropagationStopped())break e;$C(E,J,Ee),R=re}}}if(il)throw u=Jo,il=!1,Jo=null,u}function Nn(u,f){var x=f[Yx];x===void 0&&(x=f[Yx]=new Set);var w=u+"__bubble";x.has(w)||(LC(f,u,2,!1),x.add(w))}function Gx(u,f,x){var w=0;f&&(w|=4),LC(x,u,w,f)}var lp="_reactListening"+Math.random().toString(36).slice(2);function ph(u){if(!u[lp]){u[lp]=!0,s.forEach(function(x){x!=="selectionchange"&&(kL.has(x)||Gx(x,!1,u),Gx(x,!0,u))});var f=u.nodeType===9?u:u.ownerDocument;f===null||f[lp]||(f[lp]=!0,Gx("selectionchange",!1,f))}}function LC(u,f,x,w){switch(iC(f)){case 1:var E=HF;break;case 4:E=XF;break;default:E=Tx}x=E.bind(null,f,x,u),E=void 0,!Bt||f!=="touchstart"&&f!=="touchmove"&&f!=="wheel"||(E=!0),w?E!==void 0?u.addEventListener(f,x,{capture:!0,passive:E}):u.addEventListener(f,x,!0):E!==void 0?u.addEventListener(f,x,{passive:E}):u.addEventListener(f,x,!1)}function Wx(u,f,x,w,E){var R=w;if((f&1)===0&&(f&2)===0&&w!==null)e:for(;;){if(w===null)return;var F=w.tag;if(F===3||F===4){var J=w.stateNode.containerInfo;if(J===E||J.nodeType===8&&J.parentNode===E)break;if(F===4)for(F=w.return;F!==null;){var re=F.tag;if((re===3||re===4)&&(re=F.stateNode.containerInfo,re===E||re.nodeType===8&&re.parentNode===E))return;F=F.return}for(;J!==null;){if(F=ol(J),F===null)return;if(re=F.tag,re===5||re===6){w=R=F;continue e}J=J.parentNode}}w=w.return}Cn(function(){var Ee=R,Ge=ue(x),qe=[];e:{var Be=NC.get(u);if(Be!==void 0){var ft=Mx,xt=u;switch(u){case"keypress":if(np(x)===0)break e;case"keydown":case"keyup":ft=aL;break;case"focusin":xt="focus",ft=Nx;break;case"focusout":xt="blur",ft=Nx;break;case"beforeblur":case"afterblur":ft=Nx;break;case"click":if(x.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ft=lC;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ft=KF;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ft=uL;break;case AC:case MC:case RC:ft=QF;break;case kC:ft=dL;break;case"scroll":ft=jF;break;case"wheel":ft=pL;break;case"copy":case"cut":case"paste":ft=eL;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ft=uC}var St=(f&4)!==0,ns=!St&&u==="scroll",ye=St?Be!==null?Be+"Capture":null:Be;St=[];for(var le=Ee,we;le!==null;){we=le;var Qe=we.stateNode;if(we.tag===5&&Qe!==null&&(we=Qe,ye!==null&&(Qe=Ye(le,ye),Qe!=null&&St.push(mh(le,Qe,we)))),ns)break;le=le.return}0<St.length&&(Be=new ft(Be,xt,null,x,Ge),qe.push({event:Be,listeners:St}))}}if((f&7)===0){e:{if(Be=u==="mouseover"||u==="pointerover",ft=u==="mouseout"||u==="pointerout",Be&&x!==hn&&(xt=x.relatedTarget||x.fromElement)&&(ol(xt)||xt[wo]))break e;if((ft||Be)&&(Be=Ge.window===Ge?Ge:(Be=Ge.ownerDocument)?Be.defaultView||Be.parentWindow:window,ft?(xt=x.relatedTarget||x.toElement,ft=Ee,xt=xt?ol(xt):null,xt!==null&&(ns=Wi(xt),xt!==ns||xt.tag!==5&&xt.tag!==6)&&(xt=null)):(ft=null,xt=Ee),ft!==xt)){if(St=lC,Qe="onMouseLeave",ye="onMouseEnter",le="mouse",(u==="pointerout"||u==="pointerover")&&(St=uC,Qe="onPointerLeave",ye="onPointerEnter",le="pointer"),ns=ft==null?Be:Ec(ft),we=xt==null?Be:Ec(xt),Be=new St(Qe,le+"leave",ft,x,Ge),Be.target=ns,Be.relatedTarget=we,Qe=null,ol(Ge)===Ee&&(St=new St(ye,le+"enter",xt,x,Ge),St.target=we,St.relatedTarget=ns,Qe=St),ns=Qe,ft&&xt)t:{for(St=ft,ye=xt,le=0,we=St;we;we=_c(we))le++;for(we=0,Qe=ye;Qe;Qe=_c(Qe))we++;for(;0<le-we;)St=_c(St),le--;for(;0<we-le;)ye=_c(ye),we--;for(;le--;){if(St===ye||ye!==null&&St===ye.alternate)break t;St=_c(St),ye=_c(ye)}St=null}else St=null;ft!==null&&PC(qe,Be,ft,St,!1),xt!==null&&ns!==null&&PC(qe,ns,xt,St,!0)}}e:{if(Be=Ee?Ec(Ee):window,ft=Be.nodeName&&Be.nodeName.toLowerCase(),ft==="select"||ft==="input"&&Be.type==="file")var _t=SL;else if(gC(Be))if(vC)_t=EL;else{_t=_L;var Mt=wL}else(ft=Be.nodeName)&&ft.toLowerCase()==="input"&&(Be.type==="checkbox"||Be.type==="radio")&&(_t=CL);if(_t&&(_t=_t(u,Ee))){xC(qe,_t,x,Ge);break e}Mt&&Mt(u,Be,Ee),u==="focusout"&&(Mt=Be._wrapperState)&&Mt.controlled&&Be.type==="number"&&yt(Be,"number",Be.value)}switch(Mt=Ee?Ec(Ee):window,u){case"focusin":(gC(Mt)||Mt.contentEditable==="true")&&(Sc=Mt,Ox=Ee,dh=null);break;case"focusout":dh=Ox=Sc=null;break;case"mousedown":Ux=!0;break;case"contextmenu":case"mouseup":case"dragend":Ux=!1,TC(qe,x,Ge);break;case"selectionchange":if(AL)break;case"keydown":case"keyup":TC(qe,x,Ge)}var Rt;if($x)e:{switch(u){case"compositionstart":var Lt="onCompositionStart";break e;case"compositionend":Lt="onCompositionEnd";break e;case"compositionupdate":Lt="onCompositionUpdate";break e}Lt=void 0}else bc?pC(u,x)&&(Lt="onCompositionEnd"):u==="keydown"&&x.keyCode===229&&(Lt="onCompositionStart");Lt&&(hC&&x.locale!=="ko"&&(bc||Lt!=="onCompositionStart"?Lt==="onCompositionEnd"&&bc&&(Rt=oC()):(ia=Ge,Ax="value"in ia?ia.value:ia.textContent,bc=!0)),Mt=cp(Ee,Lt),0<Mt.length&&(Lt=new cC(Lt,u,null,x,Ge),qe.push({event:Lt,listeners:Mt}),Rt?Lt.data=Rt:(Rt=mC(x),Rt!==null&&(Lt.data=Rt)))),(Rt=gL?xL(u,x):vL(u,x))&&(Ee=cp(Ee,"onBeforeInput"),0<Ee.length&&(Ge=new cC("onBeforeInput","beforeinput",null,x,Ge),qe.push({event:Ge,listeners:Ee}),Ge.data=Rt))}FC(qe,f)})}function mh(u,f,x){return{instance:u,listener:f,currentTarget:x}}function cp(u,f){for(var x=f+"Capture",w=[];u!==null;){var E=u,R=E.stateNode;E.tag===5&&R!==null&&(E=R,R=Ye(u,x),R!=null&&w.unshift(mh(u,R,E)),R=Ye(u,f),R!=null&&w.push(mh(u,R,E))),u=u.return}return w}function _c(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5);return u||null}function PC(u,f,x,w,E){for(var R=f._reactName,F=[];x!==null&&x!==w;){var J=x,re=J.alternate,Ee=J.stateNode;if(re!==null&&re===w)break;J.tag===5&&Ee!==null&&(J=Ee,E?(re=Ye(x,R),re!=null&&F.unshift(mh(x,re,J))):E||(re=Ye(x,R),re!=null&&F.push(mh(x,re,J)))),x=x.return}F.length!==0&&u.push({event:f,listeners:F})}var NL=/\r\n?/g,DL=/\u0000|\uFFFD/g;function OC(u){return(typeof u=="string"?u:""+u).replace(NL,`
`).replace(DL,"")}function up(u,f,x){if(f=OC(f),OC(u)!==f&&x)throw Error(t(425))}function hp(){}var Hx=null,Xx=null;function jx(u,f){return u==="textarea"||u==="noscript"||typeof f.children=="string"||typeof f.children=="number"||typeof f.dangerouslySetInnerHTML=="object"&&f.dangerouslySetInnerHTML!==null&&f.dangerouslySetInnerHTML.__html!=null}var qx=typeof setTimeout=="function"?setTimeout:void 0,$L=typeof clearTimeout=="function"?clearTimeout:void 0,UC=typeof Promise=="function"?Promise:void 0,FL=typeof queueMicrotask=="function"?queueMicrotask:typeof UC<"u"?function(u){return UC.resolve(null).then(u).catch(LL)}:qx;function LL(u){setTimeout(function(){throw u})}function Kx(u,f){var x=f,w=0;do{var E=x.nextSibling;if(u.removeChild(x),E&&E.nodeType===8)if(x=E.data,x==="/$"){if(w===0){u.removeChild(E),ih(f);return}w--}else x!=="$"&&x!=="$?"&&x!=="$!"||w++;x=E}while(x);ih(f)}function aa(u){for(;u!=null;u=u.nextSibling){var f=u.nodeType;if(f===1||f===3)break;if(f===8){if(f=u.data,f==="$"||f==="$!"||f==="$?")break;if(f==="/$")return null}}return u}function zC(u){u=u.previousSibling;for(var f=0;u;){if(u.nodeType===8){var x=u.data;if(x==="$"||x==="$!"||x==="$?"){if(f===0)return u;f--}else x==="/$"&&f++}u=u.previousSibling}return null}var Cc=Math.random().toString(36).slice(2),Xi="__reactFiber$"+Cc,gh="__reactProps$"+Cc,wo="__reactContainer$"+Cc,Yx="__reactEvents$"+Cc,PL="__reactListeners$"+Cc,OL="__reactHandles$"+Cc;function ol(u){var f=u[Xi];if(f)return f;for(var x=u.parentNode;x;){if(f=x[wo]||x[Xi]){if(x=f.alternate,f.child!==null||x!==null&&x.child!==null)for(u=zC(u);u!==null;){if(x=u[Xi])return x;u=zC(u)}return f}u=x,x=u.parentNode}return null}function xh(u){return u=u[Xi]||u[wo],!u||u.tag!==5&&u.tag!==6&&u.tag!==13&&u.tag!==3?null:u}function Ec(u){if(u.tag===5||u.tag===6)return u.stateNode;throw Error(t(33))}function dp(u){return u[gh]||null}var Zx=[],Tc=-1;function la(u){return{current:u}}function Dn(u){0>Tc||(u.current=Zx[Tc],Zx[Tc]=null,Tc--)}function Rn(u,f){Tc++,Zx[Tc]=u.current,u.current=f}var ca={},js=la(ca),_r=la(!1),al=ca;function Ic(u,f){var x=u.type.contextTypes;if(!x)return ca;var w=u.stateNode;if(w&&w.__reactInternalMemoizedUnmaskedChildContext===f)return w.__reactInternalMemoizedMaskedChildContext;var E={},R;for(R in x)E[R]=f[R];return w&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=f,u.__reactInternalMemoizedMaskedChildContext=E),E}function Cr(u){return u=u.childContextTypes,u!=null}function fp(){Dn(_r),Dn(js)}function BC(u,f,x){if(js.current!==ca)throw Error(t(168));Rn(js,f),Rn(_r,x)}function VC(u,f,x){var w=u.stateNode;if(f=f.childContextTypes,typeof w.getChildContext!="function")return x;w=w.getChildContext();for(var E in w)if(!(E in f))throw Error(t(108,se(u)||"Unknown",E));return Z({},x,w)}function pp(u){return u=(u=u.stateNode)&&u.__reactInternalMemoizedMergedChildContext||ca,al=js.current,Rn(js,u),Rn(_r,_r.current),!0}function GC(u,f,x){var w=u.stateNode;if(!w)throw Error(t(169));x?(u=VC(u,f,al),w.__reactInternalMemoizedMergedChildContext=u,Dn(_r),Dn(js),Rn(js,u)):Dn(_r),Rn(_r,x)}var _o=null,mp=!1,Qx=!1;function WC(u){_o===null?_o=[u]:_o.push(u)}function UL(u){mp=!0,WC(u)}function ua(){if(!Qx&&_o!==null){Qx=!0;var u=0,f=cn;try{var x=_o;for(cn=1;u<x.length;u++){var w=x[u];do w=w(!0);while(w!==null)}_o=null,mp=!1}catch(E){throw _o!==null&&(_o=_o.slice(u+1)),Yf(Ze,ua),E}finally{cn=f,Qx=!1}}return null}var Ac=[],Mc=0,gp=null,xp=0,Zr=[],Qr=0,ll=null,Co=1,Eo="";function cl(u,f){Ac[Mc++]=xp,Ac[Mc++]=gp,gp=u,xp=f}function HC(u,f,x){Zr[Qr++]=Co,Zr[Qr++]=Eo,Zr[Qr++]=ll,ll=u;var w=Co;u=Eo;var E=32-Vt(w)-1;w&=~(1<<E),x+=1;var R=32-Vt(f)+E;if(30<R){var F=E-E%5;R=(w&(1<<F)-1).toString(32),w>>=F,E-=F,Co=1<<32-Vt(f)+E|x<<E|w,Eo=R+u}else Co=1<<R|x<<E|w,Eo=u}function Jx(u){u.return!==null&&(cl(u,1),HC(u,1,0))}function ev(u){for(;u===gp;)gp=Ac[--Mc],Ac[Mc]=null,xp=Ac[--Mc],Ac[Mc]=null;for(;u===ll;)ll=Zr[--Qr],Zr[Qr]=null,Eo=Zr[--Qr],Zr[Qr]=null,Co=Zr[--Qr],Zr[Qr]=null}var Or=null,Ur=null,On=!1,bi=null;function XC(u,f){var x=ni(5,null,null,0);x.elementType="DELETED",x.stateNode=f,x.return=u,f=u.deletions,f===null?(u.deletions=[x],u.flags|=16):f.push(x)}function jC(u,f){switch(u.tag){case 5:var x=u.type;return f=f.nodeType!==1||x.toLowerCase()!==f.nodeName.toLowerCase()?null:f,f!==null?(u.stateNode=f,Or=u,Ur=aa(f.firstChild),!0):!1;case 6:return f=u.pendingProps===""||f.nodeType!==3?null:f,f!==null?(u.stateNode=f,Or=u,Ur=null,!0):!1;case 13:return f=f.nodeType!==8?null:f,f!==null?(x=ll!==null?{id:Co,overflow:Eo}:null,u.memoizedState={dehydrated:f,treeContext:x,retryLane:1073741824},x=ni(18,null,null,0),x.stateNode=f,x.return=u,u.child=x,Or=u,Ur=null,!0):!1;default:return!1}}function tv(u){return(u.mode&1)!==0&&(u.flags&128)===0}function nv(u){if(On){var f=Ur;if(f){var x=f;if(!jC(u,f)){if(tv(u))throw Error(t(418));f=aa(x.nextSibling);var w=Or;f&&jC(u,f)?XC(w,x):(u.flags=u.flags&-4097|2,On=!1,Or=u)}}else{if(tv(u))throw Error(t(418));u.flags=u.flags&-4097|2,On=!1,Or=u}}}function qC(u){for(u=u.return;u!==null&&u.tag!==5&&u.tag!==3&&u.tag!==13;)u=u.return;Or=u}function vp(u){if(u!==Or)return!1;if(!On)return qC(u),On=!0,!1;var f;if((f=u.tag!==3)&&!(f=u.tag!==5)&&(f=u.type,f=f!=="head"&&f!=="body"&&!jx(u.type,u.memoizedProps)),f&&(f=Ur)){if(tv(u))throw KC(),Error(t(418));for(;f;)XC(u,f),f=aa(f.nextSibling)}if(qC(u),u.tag===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(t(317));e:{for(u=u.nextSibling,f=0;u;){if(u.nodeType===8){var x=u.data;if(x==="/$"){if(f===0){Ur=aa(u.nextSibling);break e}f--}else x!=="$"&&x!=="$!"&&x!=="$?"||f++}u=u.nextSibling}Ur=null}}else Ur=Or?aa(u.stateNode.nextSibling):null;return!0}function KC(){for(var u=Ur;u;)u=aa(u.nextSibling)}function Rc(){Ur=Or=null,On=!1}function sv(u){bi===null?bi=[u]:bi.push(u)}var zL=_.ReactCurrentBatchConfig;function vh(u,f,x){if(u=x.ref,u!==null&&typeof u!="function"&&typeof u!="object"){if(x._owner){if(x=x._owner,x){if(x.tag!==1)throw Error(t(309));var w=x.stateNode}if(!w)throw Error(t(147,u));var E=w,R=""+u;return f!==null&&f.ref!==null&&typeof f.ref=="function"&&f.ref._stringRef===R?f.ref:(f=function(F){var J=E.refs;F===null?delete J[R]:J[R]=F},f._stringRef=R,f)}if(typeof u!="string")throw Error(t(284));if(!x._owner)throw Error(t(290,u))}return u}function yp(u,f){throw u=Object.prototype.toString.call(f),Error(t(31,u==="[object Object]"?"object with keys {"+Object.keys(f).join(", ")+"}":u))}function YC(u){var f=u._init;return f(u._payload)}function ZC(u){function f(ye,le){if(u){var we=ye.deletions;we===null?(ye.deletions=[le],ye.flags|=16):we.push(le)}}function x(ye,le){if(!u)return null;for(;le!==null;)f(ye,le),le=le.sibling;return null}function w(ye,le){for(ye=new Map;le!==null;)le.key!==null?ye.set(le.key,le):ye.set(le.index,le),le=le.sibling;return ye}function E(ye,le){return ye=va(ye,le),ye.index=0,ye.sibling=null,ye}function R(ye,le,we){return ye.index=we,u?(we=ye.alternate,we!==null?(we=we.index,we<le?(ye.flags|=2,le):we):(ye.flags|=2,le)):(ye.flags|=1048576,le)}function F(ye){return u&&ye.alternate===null&&(ye.flags|=2),ye}function J(ye,le,we,Qe){return le===null||le.tag!==6?(le=qv(we,ye.mode,Qe),le.return=ye,le):(le=E(le,we),le.return=ye,le)}function re(ye,le,we,Qe){var _t=we.type;return _t===N?Ge(ye,le,we.props.children,Qe,we.key):le!==null&&(le.elementType===_t||typeof _t=="object"&&_t!==null&&_t.$$typeof===H&&YC(_t)===le.type)?(Qe=E(le,we.props),Qe.ref=vh(ye,le,we),Qe.return=ye,Qe):(Qe=Gp(we.type,we.key,we.props,null,ye.mode,Qe),Qe.ref=vh(ye,le,we),Qe.return=ye,Qe)}function Ee(ye,le,we,Qe){return le===null||le.tag!==4||le.stateNode.containerInfo!==we.containerInfo||le.stateNode.implementation!==we.implementation?(le=Kv(we,ye.mode,Qe),le.return=ye,le):(le=E(le,we.children||[]),le.return=ye,le)}function Ge(ye,le,we,Qe,_t){return le===null||le.tag!==7?(le=xl(we,ye.mode,Qe,_t),le.return=ye,le):(le=E(le,we),le.return=ye,le)}function qe(ye,le,we){if(typeof le=="string"&&le!==""||typeof le=="number")return le=qv(""+le,ye.mode,we),le.return=ye,le;if(typeof le=="object"&&le!==null){switch(le.$$typeof){case A:return we=Gp(le.type,le.key,le.props,null,ye.mode,we),we.ref=vh(ye,null,le),we.return=ye,we;case k:return le=Kv(le,ye.mode,we),le.return=ye,le;case H:var Qe=le._init;return qe(ye,Qe(le._payload),we)}if(Ve(le)||K(le))return le=xl(le,ye.mode,we,null),le.return=ye,le;yp(ye,le)}return null}function Be(ye,le,we,Qe){var _t=le!==null?le.key:null;if(typeof we=="string"&&we!==""||typeof we=="number")return _t!==null?null:J(ye,le,""+we,Qe);if(typeof we=="object"&&we!==null){switch(we.$$typeof){case A:return we.key===_t?re(ye,le,we,Qe):null;case k:return we.key===_t?Ee(ye,le,we,Qe):null;case H:return _t=we._init,Be(ye,le,_t(we._payload),Qe)}if(Ve(we)||K(we))return _t!==null?null:Ge(ye,le,we,Qe,null);yp(ye,we)}return null}function ft(ye,le,we,Qe,_t){if(typeof Qe=="string"&&Qe!==""||typeof Qe=="number")return ye=ye.get(we)||null,J(le,ye,""+Qe,_t);if(typeof Qe=="object"&&Qe!==null){switch(Qe.$$typeof){case A:return ye=ye.get(Qe.key===null?we:Qe.key)||null,re(le,ye,Qe,_t);case k:return ye=ye.get(Qe.key===null?we:Qe.key)||null,Ee(le,ye,Qe,_t);case H:var Mt=Qe._init;return ft(ye,le,we,Mt(Qe._payload),_t)}if(Ve(Qe)||K(Qe))return ye=ye.get(we)||null,Ge(le,ye,Qe,_t,null);yp(le,Qe)}return null}function xt(ye,le,we,Qe){for(var _t=null,Mt=null,Rt=le,Lt=le=0,Is=null;Rt!==null&&Lt<we.length;Lt++){Rt.index>Lt?(Is=Rt,Rt=null):Is=Rt.sibling;var dn=Be(ye,Rt,we[Lt],Qe);if(dn===null){Rt===null&&(Rt=Is);break}u&&Rt&&dn.alternate===null&&f(ye,Rt),le=R(dn,le,Lt),Mt===null?_t=dn:Mt.sibling=dn,Mt=dn,Rt=Is}if(Lt===we.length)return x(ye,Rt),On&&cl(ye,Lt),_t;if(Rt===null){for(;Lt<we.length;Lt++)Rt=qe(ye,we[Lt],Qe),Rt!==null&&(le=R(Rt,le,Lt),Mt===null?_t=Rt:Mt.sibling=Rt,Mt=Rt);return On&&cl(ye,Lt),_t}for(Rt=w(ye,Rt);Lt<we.length;Lt++)Is=ft(Rt,ye,Lt,we[Lt],Qe),Is!==null&&(u&&Is.alternate!==null&&Rt.delete(Is.key===null?Lt:Is.key),le=R(Is,le,Lt),Mt===null?_t=Is:Mt.sibling=Is,Mt=Is);return u&&Rt.forEach(function(ya){return f(ye,ya)}),On&&cl(ye,Lt),_t}function St(ye,le,we,Qe){var _t=K(we);if(typeof _t!="function")throw Error(t(150));if(we=_t.call(we),we==null)throw Error(t(151));for(var Mt=_t=null,Rt=le,Lt=le=0,Is=null,dn=we.next();Rt!==null&&!dn.done;Lt++,dn=we.next()){Rt.index>Lt?(Is=Rt,Rt=null):Is=Rt.sibling;var ya=Be(ye,Rt,dn.value,Qe);if(ya===null){Rt===null&&(Rt=Is);break}u&&Rt&&ya.alternate===null&&f(ye,Rt),le=R(ya,le,Lt),Mt===null?_t=ya:Mt.sibling=ya,Mt=ya,Rt=Is}if(dn.done)return x(ye,Rt),On&&cl(ye,Lt),_t;if(Rt===null){for(;!dn.done;Lt++,dn=we.next())dn=qe(ye,dn.value,Qe),dn!==null&&(le=R(dn,le,Lt),Mt===null?_t=dn:Mt.sibling=dn,Mt=dn);return On&&cl(ye,Lt),_t}for(Rt=w(ye,Rt);!dn.done;Lt++,dn=we.next())dn=ft(Rt,ye,Lt,dn.value,Qe),dn!==null&&(u&&dn.alternate!==null&&Rt.delete(dn.key===null?Lt:dn.key),le=R(dn,le,Lt),Mt===null?_t=dn:Mt.sibling=dn,Mt=dn);return u&&Rt.forEach(function(yP){return f(ye,yP)}),On&&cl(ye,Lt),_t}function ns(ye,le,we,Qe){if(typeof we=="object"&&we!==null&&we.type===N&&we.key===null&&(we=we.props.children),typeof we=="object"&&we!==null){switch(we.$$typeof){case A:e:{for(var _t=we.key,Mt=le;Mt!==null;){if(Mt.key===_t){if(_t=we.type,_t===N){if(Mt.tag===7){x(ye,Mt.sibling),le=E(Mt,we.props.children),le.return=ye,ye=le;break e}}else if(Mt.elementType===_t||typeof _t=="object"&&_t!==null&&_t.$$typeof===H&&YC(_t)===Mt.type){x(ye,Mt.sibling),le=E(Mt,we.props),le.ref=vh(ye,Mt,we),le.return=ye,ye=le;break e}x(ye,Mt);break}else f(ye,Mt);Mt=Mt.sibling}we.type===N?(le=xl(we.props.children,ye.mode,Qe,we.key),le.return=ye,ye=le):(Qe=Gp(we.type,we.key,we.props,null,ye.mode,Qe),Qe.ref=vh(ye,le,we),Qe.return=ye,ye=Qe)}return F(ye);case k:e:{for(Mt=we.key;le!==null;){if(le.key===Mt)if(le.tag===4&&le.stateNode.containerInfo===we.containerInfo&&le.stateNode.implementation===we.implementation){x(ye,le.sibling),le=E(le,we.children||[]),le.return=ye,ye=le;break e}else{x(ye,le);break}else f(ye,le);le=le.sibling}le=Kv(we,ye.mode,Qe),le.return=ye,ye=le}return F(ye);case H:return Mt=we._init,ns(ye,le,Mt(we._payload),Qe)}if(Ve(we))return xt(ye,le,we,Qe);if(K(we))return St(ye,le,we,Qe);yp(ye,we)}return typeof we=="string"&&we!==""||typeof we=="number"?(we=""+we,le!==null&&le.tag===6?(x(ye,le.sibling),le=E(le,we),le.return=ye,ye=le):(x(ye,le),le=qv(we,ye.mode,Qe),le.return=ye,ye=le),F(ye)):x(ye,le)}return ns}var kc=ZC(!0),QC=ZC(!1),bp=la(null),Sp=null,Nc=null,rv=null;function iv(){rv=Nc=Sp=null}function ov(u){var f=bp.current;Dn(bp),u._currentValue=f}function av(u,f,x){for(;u!==null;){var w=u.alternate;if((u.childLanes&f)!==f?(u.childLanes|=f,w!==null&&(w.childLanes|=f)):w!==null&&(w.childLanes&f)!==f&&(w.childLanes|=f),u===x)break;u=u.return}}function Dc(u,f){Sp=u,rv=Nc=null,u=u.dependencies,u!==null&&u.firstContext!==null&&((u.lanes&f)!==0&&(Er=!0),u.firstContext=null)}function Jr(u){var f=u._currentValue;if(rv!==u)if(u={context:u,memoizedValue:f,next:null},Nc===null){if(Sp===null)throw Error(t(308));Nc=u,Sp.dependencies={lanes:0,firstContext:u}}else Nc=Nc.next=u;return f}var ul=null;function lv(u){ul===null?ul=[u]:ul.push(u)}function JC(u,f,x,w){var E=f.interleaved;return E===null?(x.next=x,lv(f)):(x.next=E.next,E.next=x),f.interleaved=x,To(u,w)}function To(u,f){u.lanes|=f;var x=u.alternate;for(x!==null&&(x.lanes|=f),x=u,u=u.return;u!==null;)u.childLanes|=f,x=u.alternate,x!==null&&(x.childLanes|=f),x=u,u=u.return;return x.tag===3?x.stateNode:null}var ha=!1;function cv(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function eE(u,f){u=u.updateQueue,f.updateQueue===u&&(f.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,effects:u.effects})}function Io(u,f){return{eventTime:u,lane:f,tag:0,payload:null,callback:null,next:null}}function da(u,f,x){var w=u.updateQueue;if(w===null)return null;if(w=w.shared,(un&2)!==0){var E=w.pending;return E===null?f.next=f:(f.next=E.next,E.next=f),w.pending=f,To(u,x)}return E=w.interleaved,E===null?(f.next=f,lv(w)):(f.next=E.next,E.next=f),w.interleaved=f,To(u,x)}function wp(u,f,x){if(f=f.updateQueue,f!==null&&(f=f.shared,(x&4194240)!==0)){var w=f.lanes;w&=u.pendingLanes,x|=w,f.lanes=x,Cs(u,x)}}function tE(u,f){var x=u.updateQueue,w=u.alternate;if(w!==null&&(w=w.updateQueue,x===w)){var E=null,R=null;if(x=x.firstBaseUpdate,x!==null){do{var F={eventTime:x.eventTime,lane:x.lane,tag:x.tag,payload:x.payload,callback:x.callback,next:null};R===null?E=R=F:R=R.next=F,x=x.next}while(x!==null);R===null?E=R=f:R=R.next=f}else E=R=f;x={baseState:w.baseState,firstBaseUpdate:E,lastBaseUpdate:R,shared:w.shared,effects:w.effects},u.updateQueue=x;return}u=x.lastBaseUpdate,u===null?x.firstBaseUpdate=f:u.next=f,x.lastBaseUpdate=f}function _p(u,f,x,w){var E=u.updateQueue;ha=!1;var R=E.firstBaseUpdate,F=E.lastBaseUpdate,J=E.shared.pending;if(J!==null){E.shared.pending=null;var re=J,Ee=re.next;re.next=null,F===null?R=Ee:F.next=Ee,F=re;var Ge=u.alternate;Ge!==null&&(Ge=Ge.updateQueue,J=Ge.lastBaseUpdate,J!==F&&(J===null?Ge.firstBaseUpdate=Ee:J.next=Ee,Ge.lastBaseUpdate=re))}if(R!==null){var qe=E.baseState;F=0,Ge=Ee=re=null,J=R;do{var Be=J.lane,ft=J.eventTime;if((w&Be)===Be){Ge!==null&&(Ge=Ge.next={eventTime:ft,lane:0,tag:J.tag,payload:J.payload,callback:J.callback,next:null});e:{var xt=u,St=J;switch(Be=f,ft=x,St.tag){case 1:if(xt=St.payload,typeof xt=="function"){qe=xt.call(ft,qe,Be);break e}qe=xt;break e;case 3:xt.flags=xt.flags&-65537|128;case 0:if(xt=St.payload,Be=typeof xt=="function"?xt.call(ft,qe,Be):xt,Be==null)break e;qe=Z({},qe,Be);break e;case 2:ha=!0}}J.callback!==null&&J.lane!==0&&(u.flags|=64,Be=E.effects,Be===null?E.effects=[J]:Be.push(J))}else ft={eventTime:ft,lane:Be,tag:J.tag,payload:J.payload,callback:J.callback,next:null},Ge===null?(Ee=Ge=ft,re=qe):Ge=Ge.next=ft,F|=Be;if(J=J.next,J===null){if(J=E.shared.pending,J===null)break;Be=J,J=Be.next,Be.next=null,E.lastBaseUpdate=Be,E.shared.pending=null}}while(!0);if(Ge===null&&(re=qe),E.baseState=re,E.firstBaseUpdate=Ee,E.lastBaseUpdate=Ge,f=E.shared.interleaved,f!==null){E=f;do F|=E.lane,E=E.next;while(E!==f)}else R===null&&(E.shared.lanes=0);fl|=F,u.lanes=F,u.memoizedState=qe}}function nE(u,f,x){if(u=f.effects,f.effects=null,u!==null)for(f=0;f<u.length;f++){var w=u[f],E=w.callback;if(E!==null){if(w.callback=null,w=x,typeof E!="function")throw Error(t(191,E));E.call(w)}}}var yh={},ji=la(yh),bh=la(yh),Sh=la(yh);function hl(u){if(u===yh)throw Error(t(174));return u}function uv(u,f){switch(Rn(Sh,f),Rn(bh,u),Rn(ji,yh),u=f.nodeType,u){case 9:case 11:f=(f=f.documentElement)?f.namespaceURI:Xe(null,"");break;default:u=u===8?f.parentNode:f,f=u.namespaceURI||null,u=u.tagName,f=Xe(f,u)}Dn(ji),Rn(ji,f)}function $c(){Dn(ji),Dn(bh),Dn(Sh)}function sE(u){hl(Sh.current);var f=hl(ji.current),x=Xe(f,u.type);f!==x&&(Rn(bh,u),Rn(ji,x))}function hv(u){bh.current===u&&(Dn(ji),Dn(bh))}var Bn=la(0);function Cp(u){for(var f=u;f!==null;){if(f.tag===13){var x=f.memoizedState;if(x!==null&&(x=x.dehydrated,x===null||x.data==="$?"||x.data==="$!"))return f}else if(f.tag===19&&f.memoizedProps.revealOrder!==void 0){if((f.flags&128)!==0)return f}else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===u)break;for(;f.sibling===null;){if(f.return===null||f.return===u)return null;f=f.return}f.sibling.return=f.return,f=f.sibling}return null}var dv=[];function fv(){for(var u=0;u<dv.length;u++)dv[u]._workInProgressVersionPrimary=null;dv.length=0}var Ep=_.ReactCurrentDispatcher,pv=_.ReactCurrentBatchConfig,dl=0,Vn=null,gs=null,Es=null,Tp=!1,wh=!1,_h=0,BL=0;function qs(){throw Error(t(321))}function mv(u,f){if(f===null)return!1;for(var x=0;x<f.length&&x<u.length;x++)if(!yi(u[x],f[x]))return!1;return!0}function gv(u,f,x,w,E,R){if(dl=R,Vn=f,f.memoizedState=null,f.updateQueue=null,f.lanes=0,Ep.current=u===null||u.memoizedState===null?HL:XL,u=x(w,E),wh){R=0;do{if(wh=!1,_h=0,25<=R)throw Error(t(301));R+=1,Es=gs=null,f.updateQueue=null,Ep.current=jL,u=x(w,E)}while(wh)}if(Ep.current=Mp,f=gs!==null&&gs.next!==null,dl=0,Es=gs=Vn=null,Tp=!1,f)throw Error(t(300));return u}function xv(){var u=_h!==0;return _h=0,u}function qi(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Es===null?Vn.memoizedState=Es=u:Es=Es.next=u,Es}function ei(){if(gs===null){var u=Vn.alternate;u=u!==null?u.memoizedState:null}else u=gs.next;var f=Es===null?Vn.memoizedState:Es.next;if(f!==null)Es=f,gs=u;else{if(u===null)throw Error(t(310));gs=u,u={memoizedState:gs.memoizedState,baseState:gs.baseState,baseQueue:gs.baseQueue,queue:gs.queue,next:null},Es===null?Vn.memoizedState=Es=u:Es=Es.next=u}return Es}function Ch(u,f){return typeof f=="function"?f(u):f}function vv(u){var f=ei(),x=f.queue;if(x===null)throw Error(t(311));x.lastRenderedReducer=u;var w=gs,E=w.baseQueue,R=x.pending;if(R!==null){if(E!==null){var F=E.next;E.next=R.next,R.next=F}w.baseQueue=E=R,x.pending=null}if(E!==null){R=E.next,w=w.baseState;var J=F=null,re=null,Ee=R;do{var Ge=Ee.lane;if((dl&Ge)===Ge)re!==null&&(re=re.next={lane:0,action:Ee.action,hasEagerState:Ee.hasEagerState,eagerState:Ee.eagerState,next:null}),w=Ee.hasEagerState?Ee.eagerState:u(w,Ee.action);else{var qe={lane:Ge,action:Ee.action,hasEagerState:Ee.hasEagerState,eagerState:Ee.eagerState,next:null};re===null?(J=re=qe,F=w):re=re.next=qe,Vn.lanes|=Ge,fl|=Ge}Ee=Ee.next}while(Ee!==null&&Ee!==R);re===null?F=w:re.next=J,yi(w,f.memoizedState)||(Er=!0),f.memoizedState=w,f.baseState=F,f.baseQueue=re,x.lastRenderedState=w}if(u=x.interleaved,u!==null){E=u;do R=E.lane,Vn.lanes|=R,fl|=R,E=E.next;while(E!==u)}else E===null&&(x.lanes=0);return[f.memoizedState,x.dispatch]}function yv(u){var f=ei(),x=f.queue;if(x===null)throw Error(t(311));x.lastRenderedReducer=u;var w=x.dispatch,E=x.pending,R=f.memoizedState;if(E!==null){x.pending=null;var F=E=E.next;do R=u(R,F.action),F=F.next;while(F!==E);yi(R,f.memoizedState)||(Er=!0),f.memoizedState=R,f.baseQueue===null&&(f.baseState=R),x.lastRenderedState=R}return[R,w]}function rE(){}function iE(u,f){var x=Vn,w=ei(),E=f(),R=!yi(w.memoizedState,E);if(R&&(w.memoizedState=E,Er=!0),w=w.queue,bv(lE.bind(null,x,w,u),[u]),w.getSnapshot!==f||R||Es!==null&&Es.memoizedState.tag&1){if(x.flags|=2048,Eh(9,aE.bind(null,x,w,E,f),void 0,null),Ts===null)throw Error(t(349));(dl&30)!==0||oE(x,f,E)}return E}function oE(u,f,x){u.flags|=16384,u={getSnapshot:f,value:x},f=Vn.updateQueue,f===null?(f={lastEffect:null,stores:null},Vn.updateQueue=f,f.stores=[u]):(x=f.stores,x===null?f.stores=[u]:x.push(u))}function aE(u,f,x,w){f.value=x,f.getSnapshot=w,cE(f)&&uE(u)}function lE(u,f,x){return x(function(){cE(f)&&uE(u)})}function cE(u){var f=u.getSnapshot;u=u.value;try{var x=f();return!yi(u,x)}catch{return!0}}function uE(u){var f=To(u,1);f!==null&&Ci(f,u,1,-1)}function hE(u){var f=qi();return typeof u=="function"&&(u=u()),f.memoizedState=f.baseState=u,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ch,lastRenderedState:u},f.queue=u,u=u.dispatch=WL.bind(null,Vn,u),[f.memoizedState,u]}function Eh(u,f,x,w){return u={tag:u,create:f,destroy:x,deps:w,next:null},f=Vn.updateQueue,f===null?(f={lastEffect:null,stores:null},Vn.updateQueue=f,f.lastEffect=u.next=u):(x=f.lastEffect,x===null?f.lastEffect=u.next=u:(w=x.next,x.next=u,u.next=w,f.lastEffect=u)),u}function dE(){return ei().memoizedState}function Ip(u,f,x,w){var E=qi();Vn.flags|=u,E.memoizedState=Eh(1|f,x,void 0,w===void 0?null:w)}function Ap(u,f,x,w){var E=ei();w=w===void 0?null:w;var R=void 0;if(gs!==null){var F=gs.memoizedState;if(R=F.destroy,w!==null&&mv(w,F.deps)){E.memoizedState=Eh(f,x,R,w);return}}Vn.flags|=u,E.memoizedState=Eh(1|f,x,R,w)}function fE(u,f){return Ip(8390656,8,u,f)}function bv(u,f){return Ap(2048,8,u,f)}function pE(u,f){return Ap(4,2,u,f)}function mE(u,f){return Ap(4,4,u,f)}function gE(u,f){if(typeof f=="function")return u=u(),f(u),function(){f(null)};if(f!=null)return u=u(),f.current=u,function(){f.current=null}}function xE(u,f,x){return x=x!=null?x.concat([u]):null,Ap(4,4,gE.bind(null,f,u),x)}function Sv(){}function vE(u,f){var x=ei();f=f===void 0?null:f;var w=x.memoizedState;return w!==null&&f!==null&&mv(f,w[1])?w[0]:(x.memoizedState=[u,f],u)}function yE(u,f){var x=ei();f=f===void 0?null:f;var w=x.memoizedState;return w!==null&&f!==null&&mv(f,w[1])?w[0]:(u=u(),x.memoizedState=[u,f],u)}function bE(u,f,x){return(dl&21)===0?(u.baseState&&(u.baseState=!1,Er=!0),u.memoizedState=x):(yi(x,f)||(x=En(),Vn.lanes|=x,fl|=x,u.baseState=!0),f)}function VL(u,f){var x=cn;cn=x!==0&&4>x?x:4,u(!0);var w=pv.transition;pv.transition={};try{u(!1),f()}finally{cn=x,pv.transition=w}}function SE(){return ei().memoizedState}function GL(u,f,x){var w=ga(u);if(x={lane:w,action:x,hasEagerState:!1,eagerState:null,next:null},wE(u))_E(f,x);else if(x=JC(u,f,x,w),x!==null){var E=ur();Ci(x,u,w,E),CE(x,f,w)}}function WL(u,f,x){var w=ga(u),E={lane:w,action:x,hasEagerState:!1,eagerState:null,next:null};if(wE(u))_E(f,E);else{var R=u.alternate;if(u.lanes===0&&(R===null||R.lanes===0)&&(R=f.lastRenderedReducer,R!==null))try{var F=f.lastRenderedState,J=R(F,x);if(E.hasEagerState=!0,E.eagerState=J,yi(J,F)){var re=f.interleaved;re===null?(E.next=E,lv(f)):(E.next=re.next,re.next=E),f.interleaved=E;return}}catch{}finally{}x=JC(u,f,E,w),x!==null&&(E=ur(),Ci(x,u,w,E),CE(x,f,w))}}function wE(u){var f=u.alternate;return u===Vn||f!==null&&f===Vn}function _E(u,f){wh=Tp=!0;var x=u.pending;x===null?f.next=f:(f.next=x.next,x.next=f),u.pending=f}function CE(u,f,x){if((x&4194240)!==0){var w=f.lanes;w&=u.pendingLanes,x|=w,f.lanes=x,Cs(u,x)}}var Mp={readContext:Jr,useCallback:qs,useContext:qs,useEffect:qs,useImperativeHandle:qs,useInsertionEffect:qs,useLayoutEffect:qs,useMemo:qs,useReducer:qs,useRef:qs,useState:qs,useDebugValue:qs,useDeferredValue:qs,useTransition:qs,useMutableSource:qs,useSyncExternalStore:qs,useId:qs,unstable_isNewReconciler:!1},HL={readContext:Jr,useCallback:function(u,f){return qi().memoizedState=[u,f===void 0?null:f],u},useContext:Jr,useEffect:fE,useImperativeHandle:function(u,f,x){return x=x!=null?x.concat([u]):null,Ip(4194308,4,gE.bind(null,f,u),x)},useLayoutEffect:function(u,f){return Ip(4194308,4,u,f)},useInsertionEffect:function(u,f){return Ip(4,2,u,f)},useMemo:function(u,f){var x=qi();return f=f===void 0?null:f,u=u(),x.memoizedState=[u,f],u},useReducer:function(u,f,x){var w=qi();return f=x!==void 0?x(f):f,w.memoizedState=w.baseState=f,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:f},w.queue=u,u=u.dispatch=GL.bind(null,Vn,u),[w.memoizedState,u]},useRef:function(u){var f=qi();return u={current:u},f.memoizedState=u},useState:hE,useDebugValue:Sv,useDeferredValue:function(u){return qi().memoizedState=u},useTransition:function(){var u=hE(!1),f=u[0];return u=VL.bind(null,u[1]),qi().memoizedState=u,[f,u]},useMutableSource:function(){},useSyncExternalStore:function(u,f,x){var w=Vn,E=qi();if(On){if(x===void 0)throw Error(t(407));x=x()}else{if(x=f(),Ts===null)throw Error(t(349));(dl&30)!==0||oE(w,f,x)}E.memoizedState=x;var R={value:x,getSnapshot:f};return E.queue=R,fE(lE.bind(null,w,R,u),[u]),w.flags|=2048,Eh(9,aE.bind(null,w,R,x,f),void 0,null),x},useId:function(){var u=qi(),f=Ts.identifierPrefix;if(On){var x=Eo,w=Co;x=(w&~(1<<32-Vt(w)-1)).toString(32)+x,f=":"+f+"R"+x,x=_h++,0<x&&(f+="H"+x.toString(32)),f+=":"}else x=BL++,f=":"+f+"r"+x.toString(32)+":";return u.memoizedState=f},unstable_isNewReconciler:!1},XL={readContext:Jr,useCallback:vE,useContext:Jr,useEffect:bv,useImperativeHandle:xE,useInsertionEffect:pE,useLayoutEffect:mE,useMemo:yE,useReducer:vv,useRef:dE,useState:function(){return vv(Ch)},useDebugValue:Sv,useDeferredValue:function(u){var f=ei();return bE(f,gs.memoizedState,u)},useTransition:function(){var u=vv(Ch)[0],f=ei().memoizedState;return[u,f]},useMutableSource:rE,useSyncExternalStore:iE,useId:SE,unstable_isNewReconciler:!1},jL={readContext:Jr,useCallback:vE,useContext:Jr,useEffect:bv,useImperativeHandle:xE,useInsertionEffect:pE,useLayoutEffect:mE,useMemo:yE,useReducer:yv,useRef:dE,useState:function(){return yv(Ch)},useDebugValue:Sv,useDeferredValue:function(u){var f=ei();return gs===null?f.memoizedState=u:bE(f,gs.memoizedState,u)},useTransition:function(){var u=yv(Ch)[0],f=ei().memoizedState;return[u,f]},useMutableSource:rE,useSyncExternalStore:iE,useId:SE,unstable_isNewReconciler:!1};function Si(u,f){if(u&&u.defaultProps){f=Z({},f),u=u.defaultProps;for(var x in u)f[x]===void 0&&(f[x]=u[x]);return f}return f}function wv(u,f,x,w){f=u.memoizedState,x=x(w,f),x=x==null?f:Z({},f,x),u.memoizedState=x,u.lanes===0&&(u.updateQueue.baseState=x)}var Rp={isMounted:function(u){return(u=u._reactInternals)?Wi(u)===u:!1},enqueueSetState:function(u,f,x){u=u._reactInternals;var w=ur(),E=ga(u),R=Io(w,E);R.payload=f,x!=null&&(R.callback=x),f=da(u,R,E),f!==null&&(Ci(f,u,E,w),wp(f,u,E))},enqueueReplaceState:function(u,f,x){u=u._reactInternals;var w=ur(),E=ga(u),R=Io(w,E);R.tag=1,R.payload=f,x!=null&&(R.callback=x),f=da(u,R,E),f!==null&&(Ci(f,u,E,w),wp(f,u,E))},enqueueForceUpdate:function(u,f){u=u._reactInternals;var x=ur(),w=ga(u),E=Io(x,w);E.tag=2,f!=null&&(E.callback=f),f=da(u,E,w),f!==null&&(Ci(f,u,w,x),wp(f,u,w))}};function EE(u,f,x,w,E,R,F){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(w,R,F):f.prototype&&f.prototype.isPureReactComponent?!hh(x,w)||!hh(E,R):!0}function TE(u,f,x){var w=!1,E=ca,R=f.contextType;return typeof R=="object"&&R!==null?R=Jr(R):(E=Cr(f)?al:js.current,w=f.contextTypes,R=(w=w!=null)?Ic(u,E):ca),f=new f(x,R),u.memoizedState=f.state!==null&&f.state!==void 0?f.state:null,f.updater=Rp,u.stateNode=f,f._reactInternals=u,w&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=E,u.__reactInternalMemoizedMaskedChildContext=R),f}function IE(u,f,x,w){u=f.state,typeof f.componentWillReceiveProps=="function"&&f.componentWillReceiveProps(x,w),typeof f.UNSAFE_componentWillReceiveProps=="function"&&f.UNSAFE_componentWillReceiveProps(x,w),f.state!==u&&Rp.enqueueReplaceState(f,f.state,null)}function _v(u,f,x,w){var E=u.stateNode;E.props=x,E.state=u.memoizedState,E.refs={},cv(u);var R=f.contextType;typeof R=="object"&&R!==null?E.context=Jr(R):(R=Cr(f)?al:js.current,E.context=Ic(u,R)),E.state=u.memoizedState,R=f.getDerivedStateFromProps,typeof R=="function"&&(wv(u,f,R,x),E.state=u.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof E.getSnapshotBeforeUpdate=="function"||typeof E.UNSAFE_componentWillMount!="function"&&typeof E.componentWillMount!="function"||(f=E.state,typeof E.componentWillMount=="function"&&E.componentWillMount(),typeof E.UNSAFE_componentWillMount=="function"&&E.UNSAFE_componentWillMount(),f!==E.state&&Rp.enqueueReplaceState(E,E.state,null),_p(u,x,E,w),E.state=u.memoizedState),typeof E.componentDidMount=="function"&&(u.flags|=4194308)}function Fc(u,f){try{var x="",w=f;do x+=te(w),w=w.return;while(w);var E=x}catch(R){E=`
Error generating stack: `+R.message+`
`+R.stack}return{value:u,source:f,stack:E,digest:null}}function Cv(u,f,x){return{value:u,source:null,stack:x??null,digest:f??null}}function Ev(u,f){try{console.error(f.value)}catch(x){setTimeout(function(){throw x})}}var qL=typeof WeakMap=="function"?WeakMap:Map;function AE(u,f,x){x=Io(-1,x),x.tag=3,x.payload={element:null};var w=f.value;return x.callback=function(){Pp||(Pp=!0,zv=w),Ev(u,f)},x}function ME(u,f,x){x=Io(-1,x),x.tag=3;var w=u.type.getDerivedStateFromError;if(typeof w=="function"){var E=f.value;x.payload=function(){return w(E)},x.callback=function(){Ev(u,f)}}var R=u.stateNode;return R!==null&&typeof R.componentDidCatch=="function"&&(x.callback=function(){Ev(u,f),typeof w!="function"&&(pa===null?pa=new Set([this]):pa.add(this));var F=f.stack;this.componentDidCatch(f.value,{componentStack:F!==null?F:""})}),x}function RE(u,f,x){var w=u.pingCache;if(w===null){w=u.pingCache=new qL;var E=new Set;w.set(f,E)}else E=w.get(f),E===void 0&&(E=new Set,w.set(f,E));E.has(x)||(E.add(x),u=lP.bind(null,u,f,x),f.then(u,u))}function kE(u){do{var f;if((f=u.tag===13)&&(f=u.memoizedState,f=f!==null?f.dehydrated!==null:!0),f)return u;u=u.return}while(u!==null);return null}function NE(u,f,x,w,E){return(u.mode&1)===0?(u===f?u.flags|=65536:(u.flags|=128,x.flags|=131072,x.flags&=-52805,x.tag===1&&(x.alternate===null?x.tag=17:(f=Io(-1,1),f.tag=2,da(x,f,1))),x.lanes|=1),u):(u.flags|=65536,u.lanes=E,u)}var KL=_.ReactCurrentOwner,Er=!1;function cr(u,f,x,w){f.child=u===null?QC(f,null,x,w):kc(f,u.child,x,w)}function DE(u,f,x,w,E){x=x.render;var R=f.ref;return Dc(f,E),w=gv(u,f,x,w,R,E),x=xv(),u!==null&&!Er?(f.updateQueue=u.updateQueue,f.flags&=-2053,u.lanes&=~E,Ao(u,f,E)):(On&&x&&Jx(f),f.flags|=1,cr(u,f,w,E),f.child)}function $E(u,f,x,w,E){if(u===null){var R=x.type;return typeof R=="function"&&!jv(R)&&R.defaultProps===void 0&&x.compare===null&&x.defaultProps===void 0?(f.tag=15,f.type=R,FE(u,f,R,w,E)):(u=Gp(x.type,null,w,f,f.mode,E),u.ref=f.ref,u.return=f,f.child=u)}if(R=u.child,(u.lanes&E)===0){var F=R.memoizedProps;if(x=x.compare,x=x!==null?x:hh,x(F,w)&&u.ref===f.ref)return Ao(u,f,E)}return f.flags|=1,u=va(R,w),u.ref=f.ref,u.return=f,f.child=u}function FE(u,f,x,w,E){if(u!==null){var R=u.memoizedProps;if(hh(R,w)&&u.ref===f.ref)if(Er=!1,f.pendingProps=w=R,(u.lanes&E)!==0)(u.flags&131072)!==0&&(Er=!0);else return f.lanes=u.lanes,Ao(u,f,E)}return Tv(u,f,x,w,E)}function LE(u,f,x){var w=f.pendingProps,E=w.children,R=u!==null?u.memoizedState:null;if(w.mode==="hidden")if((f.mode&1)===0)f.memoizedState={baseLanes:0,cachePool:null,transitions:null},Rn(Pc,zr),zr|=x;else{if((x&1073741824)===0)return u=R!==null?R.baseLanes|x:x,f.lanes=f.childLanes=1073741824,f.memoizedState={baseLanes:u,cachePool:null,transitions:null},f.updateQueue=null,Rn(Pc,zr),zr|=u,null;f.memoizedState={baseLanes:0,cachePool:null,transitions:null},w=R!==null?R.baseLanes:x,Rn(Pc,zr),zr|=w}else R!==null?(w=R.baseLanes|x,f.memoizedState=null):w=x,Rn(Pc,zr),zr|=w;return cr(u,f,E,x),f.child}function PE(u,f){var x=f.ref;(u===null&&x!==null||u!==null&&u.ref!==x)&&(f.flags|=512,f.flags|=2097152)}function Tv(u,f,x,w,E){var R=Cr(x)?al:js.current;return R=Ic(f,R),Dc(f,E),x=gv(u,f,x,w,R,E),w=xv(),u!==null&&!Er?(f.updateQueue=u.updateQueue,f.flags&=-2053,u.lanes&=~E,Ao(u,f,E)):(On&&w&&Jx(f),f.flags|=1,cr(u,f,x,E),f.child)}function OE(u,f,x,w,E){if(Cr(x)){var R=!0;pp(f)}else R=!1;if(Dc(f,E),f.stateNode===null)Np(u,f),TE(f,x,w),_v(f,x,w,E),w=!0;else if(u===null){var F=f.stateNode,J=f.memoizedProps;F.props=J;var re=F.context,Ee=x.contextType;typeof Ee=="object"&&Ee!==null?Ee=Jr(Ee):(Ee=Cr(x)?al:js.current,Ee=Ic(f,Ee));var Ge=x.getDerivedStateFromProps,qe=typeof Ge=="function"||typeof F.getSnapshotBeforeUpdate=="function";qe||typeof F.UNSAFE_componentWillReceiveProps!="function"&&typeof F.componentWillReceiveProps!="function"||(J!==w||re!==Ee)&&IE(f,F,w,Ee),ha=!1;var Be=f.memoizedState;F.state=Be,_p(f,w,F,E),re=f.memoizedState,J!==w||Be!==re||_r.current||ha?(typeof Ge=="function"&&(wv(f,x,Ge,w),re=f.memoizedState),(J=ha||EE(f,x,J,w,Be,re,Ee))?(qe||typeof F.UNSAFE_componentWillMount!="function"&&typeof F.componentWillMount!="function"||(typeof F.componentWillMount=="function"&&F.componentWillMount(),typeof F.UNSAFE_componentWillMount=="function"&&F.UNSAFE_componentWillMount()),typeof F.componentDidMount=="function"&&(f.flags|=4194308)):(typeof F.componentDidMount=="function"&&(f.flags|=4194308),f.memoizedProps=w,f.memoizedState=re),F.props=w,F.state=re,F.context=Ee,w=J):(typeof F.componentDidMount=="function"&&(f.flags|=4194308),w=!1)}else{F=f.stateNode,eE(u,f),J=f.memoizedProps,Ee=f.type===f.elementType?J:Si(f.type,J),F.props=Ee,qe=f.pendingProps,Be=F.context,re=x.contextType,typeof re=="object"&&re!==null?re=Jr(re):(re=Cr(x)?al:js.current,re=Ic(f,re));var ft=x.getDerivedStateFromProps;(Ge=typeof ft=="function"||typeof F.getSnapshotBeforeUpdate=="function")||typeof F.UNSAFE_componentWillReceiveProps!="function"&&typeof F.componentWillReceiveProps!="function"||(J!==qe||Be!==re)&&IE(f,F,w,re),ha=!1,Be=f.memoizedState,F.state=Be,_p(f,w,F,E);var xt=f.memoizedState;J!==qe||Be!==xt||_r.current||ha?(typeof ft=="function"&&(wv(f,x,ft,w),xt=f.memoizedState),(Ee=ha||EE(f,x,Ee,w,Be,xt,re)||!1)?(Ge||typeof F.UNSAFE_componentWillUpdate!="function"&&typeof F.componentWillUpdate!="function"||(typeof F.componentWillUpdate=="function"&&F.componentWillUpdate(w,xt,re),typeof F.UNSAFE_componentWillUpdate=="function"&&F.UNSAFE_componentWillUpdate(w,xt,re)),typeof F.componentDidUpdate=="function"&&(f.flags|=4),typeof F.getSnapshotBeforeUpdate=="function"&&(f.flags|=1024)):(typeof F.componentDidUpdate!="function"||J===u.memoizedProps&&Be===u.memoizedState||(f.flags|=4),typeof F.getSnapshotBeforeUpdate!="function"||J===u.memoizedProps&&Be===u.memoizedState||(f.flags|=1024),f.memoizedProps=w,f.memoizedState=xt),F.props=w,F.state=xt,F.context=re,w=Ee):(typeof F.componentDidUpdate!="function"||J===u.memoizedProps&&Be===u.memoizedState||(f.flags|=4),typeof F.getSnapshotBeforeUpdate!="function"||J===u.memoizedProps&&Be===u.memoizedState||(f.flags|=1024),w=!1)}return Iv(u,f,x,w,R,E)}function Iv(u,f,x,w,E,R){PE(u,f);var F=(f.flags&128)!==0;if(!w&&!F)return E&&GC(f,x,!1),Ao(u,f,R);w=f.stateNode,KL.current=f;var J=F&&typeof x.getDerivedStateFromError!="function"?null:w.render();return f.flags|=1,u!==null&&F?(f.child=kc(f,u.child,null,R),f.child=kc(f,null,J,R)):cr(u,f,J,R),f.memoizedState=w.state,E&&GC(f,x,!0),f.child}function UE(u){var f=u.stateNode;f.pendingContext?BC(u,f.pendingContext,f.pendingContext!==f.context):f.context&&BC(u,f.context,!1),uv(u,f.containerInfo)}function zE(u,f,x,w,E){return Rc(),sv(E),f.flags|=256,cr(u,f,x,w),f.child}var Av={dehydrated:null,treeContext:null,retryLane:0};function Mv(u){return{baseLanes:u,cachePool:null,transitions:null}}function BE(u,f,x){var w=f.pendingProps,E=Bn.current,R=!1,F=(f.flags&128)!==0,J;if((J=F)||(J=u!==null&&u.memoizedState===null?!1:(E&2)!==0),J?(R=!0,f.flags&=-129):(u===null||u.memoizedState!==null)&&(E|=1),Rn(Bn,E&1),u===null)return nv(f),u=f.memoizedState,u!==null&&(u=u.dehydrated,u!==null)?((f.mode&1)===0?f.lanes=1:u.data==="$!"?f.lanes=8:f.lanes=1073741824,null):(F=w.children,u=w.fallback,R?(w=f.mode,R=f.child,F={mode:"hidden",children:F},(w&1)===0&&R!==null?(R.childLanes=0,R.pendingProps=F):R=Wp(F,w,0,null),u=xl(u,w,x,null),R.return=f,u.return=f,R.sibling=u,f.child=R,f.child.memoizedState=Mv(x),f.memoizedState=Av,u):Rv(f,F));if(E=u.memoizedState,E!==null&&(J=E.dehydrated,J!==null))return YL(u,f,F,w,J,E,x);if(R){R=w.fallback,F=f.mode,E=u.child,J=E.sibling;var re={mode:"hidden",children:w.children};return(F&1)===0&&f.child!==E?(w=f.child,w.childLanes=0,w.pendingProps=re,f.deletions=null):(w=va(E,re),w.subtreeFlags=E.subtreeFlags&14680064),J!==null?R=va(J,R):(R=xl(R,F,x,null),R.flags|=2),R.return=f,w.return=f,w.sibling=R,f.child=w,w=R,R=f.child,F=u.child.memoizedState,F=F===null?Mv(x):{baseLanes:F.baseLanes|x,cachePool:null,transitions:F.transitions},R.memoizedState=F,R.childLanes=u.childLanes&~x,f.memoizedState=Av,w}return R=u.child,u=R.sibling,w=va(R,{mode:"visible",children:w.children}),(f.mode&1)===0&&(w.lanes=x),w.return=f,w.sibling=null,u!==null&&(x=f.deletions,x===null?(f.deletions=[u],f.flags|=16):x.push(u)),f.child=w,f.memoizedState=null,w}function Rv(u,f){return f=Wp({mode:"visible",children:f},u.mode,0,null),f.return=u,u.child=f}function kp(u,f,x,w){return w!==null&&sv(w),kc(f,u.child,null,x),u=Rv(f,f.pendingProps.children),u.flags|=2,f.memoizedState=null,u}function YL(u,f,x,w,E,R,F){if(x)return f.flags&256?(f.flags&=-257,w=Cv(Error(t(422))),kp(u,f,F,w)):f.memoizedState!==null?(f.child=u.child,f.flags|=128,null):(R=w.fallback,E=f.mode,w=Wp({mode:"visible",children:w.children},E,0,null),R=xl(R,E,F,null),R.flags|=2,w.return=f,R.return=f,w.sibling=R,f.child=w,(f.mode&1)!==0&&kc(f,u.child,null,F),f.child.memoizedState=Mv(F),f.memoizedState=Av,R);if((f.mode&1)===0)return kp(u,f,F,null);if(E.data==="$!"){if(w=E.nextSibling&&E.nextSibling.dataset,w)var J=w.dgst;return w=J,R=Error(t(419)),w=Cv(R,w,void 0),kp(u,f,F,w)}if(J=(F&u.childLanes)!==0,Er||J){if(w=Ts,w!==null){switch(F&-F){case 4:E=2;break;case 16:E=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:E=32;break;case 536870912:E=268435456;break;default:E=0}E=(E&(w.suspendedLanes|F))!==0?0:E,E!==0&&E!==R.retryLane&&(R.retryLane=E,To(u,E),Ci(w,u,E,-1))}return Xv(),w=Cv(Error(t(421))),kp(u,f,F,w)}return E.data==="$?"?(f.flags|=128,f.child=u.child,f=cP.bind(null,u),E._reactRetry=f,null):(u=R.treeContext,Ur=aa(E.nextSibling),Or=f,On=!0,bi=null,u!==null&&(Zr[Qr++]=Co,Zr[Qr++]=Eo,Zr[Qr++]=ll,Co=u.id,Eo=u.overflow,ll=f),f=Rv(f,w.children),f.flags|=4096,f)}function VE(u,f,x){u.lanes|=f;var w=u.alternate;w!==null&&(w.lanes|=f),av(u.return,f,x)}function kv(u,f,x,w,E){var R=u.memoizedState;R===null?u.memoizedState={isBackwards:f,rendering:null,renderingStartTime:0,last:w,tail:x,tailMode:E}:(R.isBackwards=f,R.rendering=null,R.renderingStartTime=0,R.last=w,R.tail=x,R.tailMode=E)}function GE(u,f,x){var w=f.pendingProps,E=w.revealOrder,R=w.tail;if(cr(u,f,w.children,x),w=Bn.current,(w&2)!==0)w=w&1|2,f.flags|=128;else{if(u!==null&&(u.flags&128)!==0)e:for(u=f.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&VE(u,x,f);else if(u.tag===19)VE(u,x,f);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===f)break e;for(;u.sibling===null;){if(u.return===null||u.return===f)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}w&=1}if(Rn(Bn,w),(f.mode&1)===0)f.memoizedState=null;else switch(E){case"forwards":for(x=f.child,E=null;x!==null;)u=x.alternate,u!==null&&Cp(u)===null&&(E=x),x=x.sibling;x=E,x===null?(E=f.child,f.child=null):(E=x.sibling,x.sibling=null),kv(f,!1,E,x,R);break;case"backwards":for(x=null,E=f.child,f.child=null;E!==null;){if(u=E.alternate,u!==null&&Cp(u)===null){f.child=E;break}u=E.sibling,E.sibling=x,x=E,E=u}kv(f,!0,x,null,R);break;case"together":kv(f,!1,null,null,void 0);break;default:f.memoizedState=null}return f.child}function Np(u,f){(f.mode&1)===0&&u!==null&&(u.alternate=null,f.alternate=null,f.flags|=2)}function Ao(u,f,x){if(u!==null&&(f.dependencies=u.dependencies),fl|=f.lanes,(x&f.childLanes)===0)return null;if(u!==null&&f.child!==u.child)throw Error(t(153));if(f.child!==null){for(u=f.child,x=va(u,u.pendingProps),f.child=x,x.return=f;u.sibling!==null;)u=u.sibling,x=x.sibling=va(u,u.pendingProps),x.return=f;x.sibling=null}return f.child}function ZL(u,f,x){switch(f.tag){case 3:UE(f),Rc();break;case 5:sE(f);break;case 1:Cr(f.type)&&pp(f);break;case 4:uv(f,f.stateNode.containerInfo);break;case 10:var w=f.type._context,E=f.memoizedProps.value;Rn(bp,w._currentValue),w._currentValue=E;break;case 13:if(w=f.memoizedState,w!==null)return w.dehydrated!==null?(Rn(Bn,Bn.current&1),f.flags|=128,null):(x&f.child.childLanes)!==0?BE(u,f,x):(Rn(Bn,Bn.current&1),u=Ao(u,f,x),u!==null?u.sibling:null);Rn(Bn,Bn.current&1);break;case 19:if(w=(x&f.childLanes)!==0,(u.flags&128)!==0){if(w)return GE(u,f,x);f.flags|=128}if(E=f.memoizedState,E!==null&&(E.rendering=null,E.tail=null,E.lastEffect=null),Rn(Bn,Bn.current),w)break;return null;case 22:case 23:return f.lanes=0,LE(u,f,x)}return Ao(u,f,x)}var WE,Nv,HE,XE;WE=function(u,f){for(var x=f.child;x!==null;){if(x.tag===5||x.tag===6)u.appendChild(x.stateNode);else if(x.tag!==4&&x.child!==null){x.child.return=x,x=x.child;continue}if(x===f)break;for(;x.sibling===null;){if(x.return===null||x.return===f)return;x=x.return}x.sibling.return=x.return,x=x.sibling}},Nv=function(){},HE=function(u,f,x,w){var E=u.memoizedProps;if(E!==w){u=f.stateNode,hl(ji.current);var R=null;switch(x){case"input":E=j(u,E),w=j(u,w),R=[];break;case"select":E=Z({},E,{value:void 0}),w=Z({},w,{value:void 0}),R=[];break;case"textarea":E=L(u,E),w=L(u,w),R=[];break;default:typeof E.onClick!="function"&&typeof w.onClick=="function"&&(u.onclick=hp)}Ot(x,w);var F;x=null;for(Ee in E)if(!w.hasOwnProperty(Ee)&&E.hasOwnProperty(Ee)&&E[Ee]!=null)if(Ee==="style"){var J=E[Ee];for(F in J)J.hasOwnProperty(F)&&(x||(x={}),x[F]="")}else Ee!=="dangerouslySetInnerHTML"&&Ee!=="children"&&Ee!=="suppressContentEditableWarning"&&Ee!=="suppressHydrationWarning"&&Ee!=="autoFocus"&&(r.hasOwnProperty(Ee)?R||(R=[]):(R=R||[]).push(Ee,null));for(Ee in w){var re=w[Ee];if(J=E!=null?E[Ee]:void 0,w.hasOwnProperty(Ee)&&re!==J&&(re!=null||J!=null))if(Ee==="style")if(J){for(F in J)!J.hasOwnProperty(F)||re&&re.hasOwnProperty(F)||(x||(x={}),x[F]="");for(F in re)re.hasOwnProperty(F)&&J[F]!==re[F]&&(x||(x={}),x[F]=re[F])}else x||(R||(R=[]),R.push(Ee,x)),x=re;else Ee==="dangerouslySetInnerHTML"?(re=re?re.__html:void 0,J=J?J.__html:void 0,re!=null&&J!==re&&(R=R||[]).push(Ee,re)):Ee==="children"?typeof re!="string"&&typeof re!="number"||(R=R||[]).push(Ee,""+re):Ee!=="suppressContentEditableWarning"&&Ee!=="suppressHydrationWarning"&&(r.hasOwnProperty(Ee)?(re!=null&&Ee==="onScroll"&&Nn("scroll",u),R||J===re||(R=[])):(R=R||[]).push(Ee,re))}x&&(R=R||[]).push("style",x);var Ee=R;(f.updateQueue=Ee)&&(f.flags|=4)}},XE=function(u,f,x,w){x!==w&&(f.flags|=4)};function Th(u,f){if(!On)switch(u.tailMode){case"hidden":f=u.tail;for(var x=null;f!==null;)f.alternate!==null&&(x=f),f=f.sibling;x===null?u.tail=null:x.sibling=null;break;case"collapsed":x=u.tail;for(var w=null;x!==null;)x.alternate!==null&&(w=x),x=x.sibling;w===null?f||u.tail===null?u.tail=null:u.tail.sibling=null:w.sibling=null}}function Ks(u){var f=u.alternate!==null&&u.alternate.child===u.child,x=0,w=0;if(f)for(var E=u.child;E!==null;)x|=E.lanes|E.childLanes,w|=E.subtreeFlags&14680064,w|=E.flags&14680064,E.return=u,E=E.sibling;else for(E=u.child;E!==null;)x|=E.lanes|E.childLanes,w|=E.subtreeFlags,w|=E.flags,E.return=u,E=E.sibling;return u.subtreeFlags|=w,u.childLanes=x,f}function QL(u,f,x){var w=f.pendingProps;switch(ev(f),f.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ks(f),null;case 1:return Cr(f.type)&&fp(),Ks(f),null;case 3:return w=f.stateNode,$c(),Dn(_r),Dn(js),fv(),w.pendingContext&&(w.context=w.pendingContext,w.pendingContext=null),(u===null||u.child===null)&&(vp(f)?f.flags|=4:u===null||u.memoizedState.isDehydrated&&(f.flags&256)===0||(f.flags|=1024,bi!==null&&(Gv(bi),bi=null))),Nv(u,f),Ks(f),null;case 5:hv(f);var E=hl(Sh.current);if(x=f.type,u!==null&&f.stateNode!=null)HE(u,f,x,w,E),u.ref!==f.ref&&(f.flags|=512,f.flags|=2097152);else{if(!w){if(f.stateNode===null)throw Error(t(166));return Ks(f),null}if(u=hl(ji.current),vp(f)){w=f.stateNode,x=f.type;var R=f.memoizedProps;switch(w[Xi]=f,w[gh]=R,u=(f.mode&1)!==0,x){case"dialog":Nn("cancel",w),Nn("close",w);break;case"iframe":case"object":case"embed":Nn("load",w);break;case"video":case"audio":for(E=0;E<fh.length;E++)Nn(fh[E],w);break;case"source":Nn("error",w);break;case"img":case"image":case"link":Nn("error",w),Nn("load",w);break;case"details":Nn("toggle",w);break;case"input":ht(w,R),Nn("invalid",w);break;case"select":w._wrapperState={wasMultiple:!!R.multiple},Nn("invalid",w);break;case"textarea":ge(w,R),Nn("invalid",w)}Ot(x,R),E=null;for(var F in R)if(R.hasOwnProperty(F)){var J=R[F];F==="children"?typeof J=="string"?w.textContent!==J&&(R.suppressHydrationWarning!==!0&&up(w.textContent,J,u),E=["children",J]):typeof J=="number"&&w.textContent!==""+J&&(R.suppressHydrationWarning!==!0&&up(w.textContent,J,u),E=["children",""+J]):r.hasOwnProperty(F)&&J!=null&&F==="onScroll"&&Nn("scroll",w)}switch(x){case"input":De(w),Oe(w,R,!0);break;case"textarea":De(w),$e(w);break;case"select":case"option":break;default:typeof R.onClick=="function"&&(w.onclick=hp)}w=E,f.updateQueue=w,w!==null&&(f.flags|=4)}else{F=E.nodeType===9?E:E.ownerDocument,u==="http://www.w3.org/1999/xhtml"&&(u=Ie(x)),u==="http://www.w3.org/1999/xhtml"?x==="script"?(u=F.createElement("div"),u.innerHTML="<script><\/script>",u=u.removeChild(u.firstChild)):typeof w.is=="string"?u=F.createElement(x,{is:w.is}):(u=F.createElement(x),x==="select"&&(F=u,w.multiple?F.multiple=!0:w.size&&(F.size=w.size))):u=F.createElementNS(u,x),u[Xi]=f,u[gh]=w,WE(u,f,!1,!1),f.stateNode=u;e:{switch(F=$t(x,w),x){case"dialog":Nn("cancel",u),Nn("close",u),E=w;break;case"iframe":case"object":case"embed":Nn("load",u),E=w;break;case"video":case"audio":for(E=0;E<fh.length;E++)Nn(fh[E],u);E=w;break;case"source":Nn("error",u),E=w;break;case"img":case"image":case"link":Nn("error",u),Nn("load",u),E=w;break;case"details":Nn("toggle",u),E=w;break;case"input":ht(u,w),E=j(u,w),Nn("invalid",u);break;case"option":E=w;break;case"select":u._wrapperState={wasMultiple:!!w.multiple},E=Z({},w,{value:void 0}),Nn("invalid",u);break;case"textarea":ge(u,w),E=L(u,w),Nn("invalid",u);break;default:E=w}Ot(x,E),J=E;for(R in J)if(J.hasOwnProperty(R)){var re=J[R];R==="style"?Et(u,re):R==="dangerouslySetInnerHTML"?(re=re?re.__html:void 0,re!=null&&et(u,re)):R==="children"?typeof re=="string"?(x!=="textarea"||re!=="")&&ut(u,re):typeof re=="number"&&ut(u,""+re):R!=="suppressContentEditableWarning"&&R!=="suppressHydrationWarning"&&R!=="autoFocus"&&(r.hasOwnProperty(R)?re!=null&&R==="onScroll"&&Nn("scroll",u):re!=null&&C(u,R,re,F))}switch(x){case"input":De(u),Oe(u,w,!1);break;case"textarea":De(u),$e(u);break;case"option":w.value!=null&&u.setAttribute("value",""+Q(w.value));break;case"select":u.multiple=!!w.multiple,R=w.value,R!=null?X(u,!!w.multiple,R,!1):w.defaultValue!=null&&X(u,!!w.multiple,w.defaultValue,!0);break;default:typeof E.onClick=="function"&&(u.onclick=hp)}switch(x){case"button":case"input":case"select":case"textarea":w=!!w.autoFocus;break e;case"img":w=!0;break e;default:w=!1}}w&&(f.flags|=4)}f.ref!==null&&(f.flags|=512,f.flags|=2097152)}return Ks(f),null;case 6:if(u&&f.stateNode!=null)XE(u,f,u.memoizedProps,w);else{if(typeof w!="string"&&f.stateNode===null)throw Error(t(166));if(x=hl(Sh.current),hl(ji.current),vp(f)){if(w=f.stateNode,x=f.memoizedProps,w[Xi]=f,(R=w.nodeValue!==x)&&(u=Or,u!==null))switch(u.tag){case 3:up(w.nodeValue,x,(u.mode&1)!==0);break;case 5:u.memoizedProps.suppressHydrationWarning!==!0&&up(w.nodeValue,x,(u.mode&1)!==0)}R&&(f.flags|=4)}else w=(x.nodeType===9?x:x.ownerDocument).createTextNode(w),w[Xi]=f,f.stateNode=w}return Ks(f),null;case 13:if(Dn(Bn),w=f.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(On&&Ur!==null&&(f.mode&1)!==0&&(f.flags&128)===0)KC(),Rc(),f.flags|=98560,R=!1;else if(R=vp(f),w!==null&&w.dehydrated!==null){if(u===null){if(!R)throw Error(t(318));if(R=f.memoizedState,R=R!==null?R.dehydrated:null,!R)throw Error(t(317));R[Xi]=f}else Rc(),(f.flags&128)===0&&(f.memoizedState=null),f.flags|=4;Ks(f),R=!1}else bi!==null&&(Gv(bi),bi=null),R=!0;if(!R)return f.flags&65536?f:null}return(f.flags&128)!==0?(f.lanes=x,f):(w=w!==null,w!==(u!==null&&u.memoizedState!==null)&&w&&(f.child.flags|=8192,(f.mode&1)!==0&&(u===null||(Bn.current&1)!==0?xs===0&&(xs=3):Xv())),f.updateQueue!==null&&(f.flags|=4),Ks(f),null);case 4:return $c(),Nv(u,f),u===null&&ph(f.stateNode.containerInfo),Ks(f),null;case 10:return ov(f.type._context),Ks(f),null;case 17:return Cr(f.type)&&fp(),Ks(f),null;case 19:if(Dn(Bn),R=f.memoizedState,R===null)return Ks(f),null;if(w=(f.flags&128)!==0,F=R.rendering,F===null)if(w)Th(R,!1);else{if(xs!==0||u!==null&&(u.flags&128)!==0)for(u=f.child;u!==null;){if(F=Cp(u),F!==null){for(f.flags|=128,Th(R,!1),w=F.updateQueue,w!==null&&(f.updateQueue=w,f.flags|=4),f.subtreeFlags=0,w=x,x=f.child;x!==null;)R=x,u=w,R.flags&=14680066,F=R.alternate,F===null?(R.childLanes=0,R.lanes=u,R.child=null,R.subtreeFlags=0,R.memoizedProps=null,R.memoizedState=null,R.updateQueue=null,R.dependencies=null,R.stateNode=null):(R.childLanes=F.childLanes,R.lanes=F.lanes,R.child=F.child,R.subtreeFlags=0,R.deletions=null,R.memoizedProps=F.memoizedProps,R.memoizedState=F.memoizedState,R.updateQueue=F.updateQueue,R.type=F.type,u=F.dependencies,R.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),x=x.sibling;return Rn(Bn,Bn.current&1|2),f.child}u=u.sibling}R.tail!==null&&Se()>Oc&&(f.flags|=128,w=!0,Th(R,!1),f.lanes=4194304)}else{if(!w)if(u=Cp(F),u!==null){if(f.flags|=128,w=!0,x=u.updateQueue,x!==null&&(f.updateQueue=x,f.flags|=4),Th(R,!0),R.tail===null&&R.tailMode==="hidden"&&!F.alternate&&!On)return Ks(f),null}else 2*Se()-R.renderingStartTime>Oc&&x!==1073741824&&(f.flags|=128,w=!0,Th(R,!1),f.lanes=4194304);R.isBackwards?(F.sibling=f.child,f.child=F):(x=R.last,x!==null?x.sibling=F:f.child=F,R.last=F)}return R.tail!==null?(f=R.tail,R.rendering=f,R.tail=f.sibling,R.renderingStartTime=Se(),f.sibling=null,x=Bn.current,Rn(Bn,w?x&1|2:x&1),f):(Ks(f),null);case 22:case 23:return Hv(),w=f.memoizedState!==null,u!==null&&u.memoizedState!==null!==w&&(f.flags|=8192),w&&(f.mode&1)!==0?(zr&1073741824)!==0&&(Ks(f),f.subtreeFlags&6&&(f.flags|=8192)):Ks(f),null;case 24:return null;case 25:return null}throw Error(t(156,f.tag))}function JL(u,f){switch(ev(f),f.tag){case 1:return Cr(f.type)&&fp(),u=f.flags,u&65536?(f.flags=u&-65537|128,f):null;case 3:return $c(),Dn(_r),Dn(js),fv(),u=f.flags,(u&65536)!==0&&(u&128)===0?(f.flags=u&-65537|128,f):null;case 5:return hv(f),null;case 13:if(Dn(Bn),u=f.memoizedState,u!==null&&u.dehydrated!==null){if(f.alternate===null)throw Error(t(340));Rc()}return u=f.flags,u&65536?(f.flags=u&-65537|128,f):null;case 19:return Dn(Bn),null;case 4:return $c(),null;case 10:return ov(f.type._context),null;case 22:case 23:return Hv(),null;case 24:return null;default:return null}}var Dp=!1,Ys=!1,eP=typeof WeakSet=="function"?WeakSet:Set,pt=null;function Lc(u,f){var x=u.ref;if(x!==null)if(typeof x=="function")try{x(null)}catch(w){Hn(u,f,w)}else x.current=null}function Dv(u,f,x){try{x()}catch(w){Hn(u,f,w)}}var jE=!1;function tP(u,f){if(Hx=Jf,u=EC(),Px(u)){if("selectionStart"in u)var x={start:u.selectionStart,end:u.selectionEnd};else e:{x=(x=u.ownerDocument)&&x.defaultView||window;var w=x.getSelection&&x.getSelection();if(w&&w.rangeCount!==0){x=w.anchorNode;var E=w.anchorOffset,R=w.focusNode;w=w.focusOffset;try{x.nodeType,R.nodeType}catch{x=null;break e}var F=0,J=-1,re=-1,Ee=0,Ge=0,qe=u,Be=null;t:for(;;){for(var ft;qe!==x||E!==0&&qe.nodeType!==3||(J=F+E),qe!==R||w!==0&&qe.nodeType!==3||(re=F+w),qe.nodeType===3&&(F+=qe.nodeValue.length),(ft=qe.firstChild)!==null;)Be=qe,qe=ft;for(;;){if(qe===u)break t;if(Be===x&&++Ee===E&&(J=F),Be===R&&++Ge===w&&(re=F),(ft=qe.nextSibling)!==null)break;qe=Be,Be=qe.parentNode}qe=ft}x=J===-1||re===-1?null:{start:J,end:re}}else x=null}x=x||{start:0,end:0}}else x=null;for(Xx={focusedElem:u,selectionRange:x},Jf=!1,pt=f;pt!==null;)if(f=pt,u=f.child,(f.subtreeFlags&1028)!==0&&u!==null)u.return=f,pt=u;else for(;pt!==null;){f=pt;try{var xt=f.alternate;if((f.flags&1024)!==0)switch(f.tag){case 0:case 11:case 15:break;case 1:if(xt!==null){var St=xt.memoizedProps,ns=xt.memoizedState,ye=f.stateNode,le=ye.getSnapshotBeforeUpdate(f.elementType===f.type?St:Si(f.type,St),ns);ye.__reactInternalSnapshotBeforeUpdate=le}break;case 3:var we=f.stateNode.containerInfo;we.nodeType===1?we.textContent="":we.nodeType===9&&we.documentElement&&we.removeChild(we.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(t(163))}}catch(Qe){Hn(f,f.return,Qe)}if(u=f.sibling,u!==null){u.return=f.return,pt=u;break}pt=f.return}return xt=jE,jE=!1,xt}function Ih(u,f,x){var w=f.updateQueue;if(w=w!==null?w.lastEffect:null,w!==null){var E=w=w.next;do{if((E.tag&u)===u){var R=E.destroy;E.destroy=void 0,R!==void 0&&Dv(f,x,R)}E=E.next}while(E!==w)}}function $p(u,f){if(f=f.updateQueue,f=f!==null?f.lastEffect:null,f!==null){var x=f=f.next;do{if((x.tag&u)===u){var w=x.create;x.destroy=w()}x=x.next}while(x!==f)}}function $v(u){var f=u.ref;if(f!==null){var x=u.stateNode;switch(u.tag){case 5:u=x;break;default:u=x}typeof f=="function"?f(u):f.current=u}}function qE(u){var f=u.alternate;f!==null&&(u.alternate=null,qE(f)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(f=u.stateNode,f!==null&&(delete f[Xi],delete f[gh],delete f[Yx],delete f[PL],delete f[OL])),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}function KE(u){return u.tag===5||u.tag===3||u.tag===4}function YE(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||KE(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function Fv(u,f,x){var w=u.tag;if(w===5||w===6)u=u.stateNode,f?x.nodeType===8?x.parentNode.insertBefore(u,f):x.insertBefore(u,f):(x.nodeType===8?(f=x.parentNode,f.insertBefore(u,x)):(f=x,f.appendChild(u)),x=x._reactRootContainer,x!=null||f.onclick!==null||(f.onclick=hp));else if(w!==4&&(u=u.child,u!==null))for(Fv(u,f,x),u=u.sibling;u!==null;)Fv(u,f,x),u=u.sibling}function Lv(u,f,x){var w=u.tag;if(w===5||w===6)u=u.stateNode,f?x.insertBefore(u,f):x.appendChild(u);else if(w!==4&&(u=u.child,u!==null))for(Lv(u,f,x),u=u.sibling;u!==null;)Lv(u,f,x),u=u.sibling}var Ls=null,wi=!1;function fa(u,f,x){for(x=x.child;x!==null;)ZE(u,f,x),x=x.sibling}function ZE(u,f,x){if(bt&&typeof bt.onCommitFiberUnmount=="function")try{bt.onCommitFiberUnmount(kt,x)}catch{}switch(x.tag){case 5:Ys||Lc(x,f);case 6:var w=Ls,E=wi;Ls=null,fa(u,f,x),Ls=w,wi=E,Ls!==null&&(wi?(u=Ls,x=x.stateNode,u.nodeType===8?u.parentNode.removeChild(x):u.removeChild(x)):Ls.removeChild(x.stateNode));break;case 18:Ls!==null&&(wi?(u=Ls,x=x.stateNode,u.nodeType===8?Kx(u.parentNode,x):u.nodeType===1&&Kx(u,x),ih(u)):Kx(Ls,x.stateNode));break;case 4:w=Ls,E=wi,Ls=x.stateNode.containerInfo,wi=!0,fa(u,f,x),Ls=w,wi=E;break;case 0:case 11:case 14:case 15:if(!Ys&&(w=x.updateQueue,w!==null&&(w=w.lastEffect,w!==null))){E=w=w.next;do{var R=E,F=R.destroy;R=R.tag,F!==void 0&&((R&2)!==0||(R&4)!==0)&&Dv(x,f,F),E=E.next}while(E!==w)}fa(u,f,x);break;case 1:if(!Ys&&(Lc(x,f),w=x.stateNode,typeof w.componentWillUnmount=="function"))try{w.props=x.memoizedProps,w.state=x.memoizedState,w.componentWillUnmount()}catch(J){Hn(x,f,J)}fa(u,f,x);break;case 21:fa(u,f,x);break;case 22:x.mode&1?(Ys=(w=Ys)||x.memoizedState!==null,fa(u,f,x),Ys=w):fa(u,f,x);break;default:fa(u,f,x)}}function QE(u){var f=u.updateQueue;if(f!==null){u.updateQueue=null;var x=u.stateNode;x===null&&(x=u.stateNode=new eP),f.forEach(function(w){var E=uP.bind(null,u,w);x.has(w)||(x.add(w),w.then(E,E))})}}function _i(u,f){var x=f.deletions;if(x!==null)for(var w=0;w<x.length;w++){var E=x[w];try{var R=u,F=f,J=F;e:for(;J!==null;){switch(J.tag){case 5:Ls=J.stateNode,wi=!1;break e;case 3:Ls=J.stateNode.containerInfo,wi=!0;break e;case 4:Ls=J.stateNode.containerInfo,wi=!0;break e}J=J.return}if(Ls===null)throw Error(t(160));ZE(R,F,E),Ls=null,wi=!1;var re=E.alternate;re!==null&&(re.return=null),E.return=null}catch(Ee){Hn(E,f,Ee)}}if(f.subtreeFlags&12854)for(f=f.child;f!==null;)JE(f,u),f=f.sibling}function JE(u,f){var x=u.alternate,w=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:if(_i(f,u),Ki(u),w&4){try{Ih(3,u,u.return),$p(3,u)}catch(St){Hn(u,u.return,St)}try{Ih(5,u,u.return)}catch(St){Hn(u,u.return,St)}}break;case 1:_i(f,u),Ki(u),w&512&&x!==null&&Lc(x,x.return);break;case 5:if(_i(f,u),Ki(u),w&512&&x!==null&&Lc(x,x.return),u.flags&32){var E=u.stateNode;try{ut(E,"")}catch(St){Hn(u,u.return,St)}}if(w&4&&(E=u.stateNode,E!=null)){var R=u.memoizedProps,F=x!==null?x.memoizedProps:R,J=u.type,re=u.updateQueue;if(u.updateQueue=null,re!==null)try{J==="input"&&R.type==="radio"&&R.name!=null&&We(E,R),$t(J,F);var Ee=$t(J,R);for(F=0;F<re.length;F+=2){var Ge=re[F],qe=re[F+1];Ge==="style"?Et(E,qe):Ge==="dangerouslySetInnerHTML"?et(E,qe):Ge==="children"?ut(E,qe):C(E,Ge,qe,Ee)}switch(J){case"input":Ke(E,R);break;case"textarea":Re(E,R);break;case"select":var Be=E._wrapperState.wasMultiple;E._wrapperState.wasMultiple=!!R.multiple;var ft=R.value;ft!=null?X(E,!!R.multiple,ft,!1):Be!==!!R.multiple&&(R.defaultValue!=null?X(E,!!R.multiple,R.defaultValue,!0):X(E,!!R.multiple,R.multiple?[]:"",!1))}E[gh]=R}catch(St){Hn(u,u.return,St)}}break;case 6:if(_i(f,u),Ki(u),w&4){if(u.stateNode===null)throw Error(t(162));E=u.stateNode,R=u.memoizedProps;try{E.nodeValue=R}catch(St){Hn(u,u.return,St)}}break;case 3:if(_i(f,u),Ki(u),w&4&&x!==null&&x.memoizedState.isDehydrated)try{ih(f.containerInfo)}catch(St){Hn(u,u.return,St)}break;case 4:_i(f,u),Ki(u);break;case 13:_i(f,u),Ki(u),E=u.child,E.flags&8192&&(R=E.memoizedState!==null,E.stateNode.isHidden=R,!R||E.alternate!==null&&E.alternate.memoizedState!==null||(Uv=Se())),w&4&&QE(u);break;case 22:if(Ge=x!==null&&x.memoizedState!==null,u.mode&1?(Ys=(Ee=Ys)||Ge,_i(f,u),Ys=Ee):_i(f,u),Ki(u),w&8192){if(Ee=u.memoizedState!==null,(u.stateNode.isHidden=Ee)&&!Ge&&(u.mode&1)!==0)for(pt=u,Ge=u.child;Ge!==null;){for(qe=pt=Ge;pt!==null;){switch(Be=pt,ft=Be.child,Be.tag){case 0:case 11:case 14:case 15:Ih(4,Be,Be.return);break;case 1:Lc(Be,Be.return);var xt=Be.stateNode;if(typeof xt.componentWillUnmount=="function"){w=Be,x=Be.return;try{f=w,xt.props=f.memoizedProps,xt.state=f.memoizedState,xt.componentWillUnmount()}catch(St){Hn(w,x,St)}}break;case 5:Lc(Be,Be.return);break;case 22:if(Be.memoizedState!==null){nT(qe);continue}}ft!==null?(ft.return=Be,pt=ft):nT(qe)}Ge=Ge.sibling}e:for(Ge=null,qe=u;;){if(qe.tag===5){if(Ge===null){Ge=qe;try{E=qe.stateNode,Ee?(R=E.style,typeof R.setProperty=="function"?R.setProperty("display","none","important"):R.display="none"):(J=qe.stateNode,re=qe.memoizedProps.style,F=re!=null&&re.hasOwnProperty("display")?re.display:null,J.style.display=wt("display",F))}catch(St){Hn(u,u.return,St)}}}else if(qe.tag===6){if(Ge===null)try{qe.stateNode.nodeValue=Ee?"":qe.memoizedProps}catch(St){Hn(u,u.return,St)}}else if((qe.tag!==22&&qe.tag!==23||qe.memoizedState===null||qe===u)&&qe.child!==null){qe.child.return=qe,qe=qe.child;continue}if(qe===u)break e;for(;qe.sibling===null;){if(qe.return===null||qe.return===u)break e;Ge===qe&&(Ge=null),qe=qe.return}Ge===qe&&(Ge=null),qe.sibling.return=qe.return,qe=qe.sibling}}break;case 19:_i(f,u),Ki(u),w&4&&QE(u);break;case 21:break;default:_i(f,u),Ki(u)}}function Ki(u){var f=u.flags;if(f&2){try{e:{for(var x=u.return;x!==null;){if(KE(x)){var w=x;break e}x=x.return}throw Error(t(160))}switch(w.tag){case 5:var E=w.stateNode;w.flags&32&&(ut(E,""),w.flags&=-33);var R=YE(u);Lv(u,R,E);break;case 3:case 4:var F=w.stateNode.containerInfo,J=YE(u);Fv(u,J,F);break;default:throw Error(t(161))}}catch(re){Hn(u,u.return,re)}u.flags&=-3}f&4096&&(u.flags&=-4097)}function nP(u,f,x){pt=u,eT(u)}function eT(u,f,x){for(var w=(u.mode&1)!==0;pt!==null;){var E=pt,R=E.child;if(E.tag===22&&w){var F=E.memoizedState!==null||Dp;if(!F){var J=E.alternate,re=J!==null&&J.memoizedState!==null||Ys;J=Dp;var Ee=Ys;if(Dp=F,(Ys=re)&&!Ee)for(pt=E;pt!==null;)F=pt,re=F.child,F.tag===22&&F.memoizedState!==null?sT(E):re!==null?(re.return=F,pt=re):sT(E);for(;R!==null;)pt=R,eT(R),R=R.sibling;pt=E,Dp=J,Ys=Ee}tT(u)}else(E.subtreeFlags&8772)!==0&&R!==null?(R.return=E,pt=R):tT(u)}}function tT(u){for(;pt!==null;){var f=pt;if((f.flags&8772)!==0){var x=f.alternate;try{if((f.flags&8772)!==0)switch(f.tag){case 0:case 11:case 15:Ys||$p(5,f);break;case 1:var w=f.stateNode;if(f.flags&4&&!Ys)if(x===null)w.componentDidMount();else{var E=f.elementType===f.type?x.memoizedProps:Si(f.type,x.memoizedProps);w.componentDidUpdate(E,x.memoizedState,w.__reactInternalSnapshotBeforeUpdate)}var R=f.updateQueue;R!==null&&nE(f,R,w);break;case 3:var F=f.updateQueue;if(F!==null){if(x=null,f.child!==null)switch(f.child.tag){case 5:x=f.child.stateNode;break;case 1:x=f.child.stateNode}nE(f,F,x)}break;case 5:var J=f.stateNode;if(x===null&&f.flags&4){x=J;var re=f.memoizedProps;switch(f.type){case"button":case"input":case"select":case"textarea":re.autoFocus&&x.focus();break;case"img":re.src&&(x.src=re.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(f.memoizedState===null){var Ee=f.alternate;if(Ee!==null){var Ge=Ee.memoizedState;if(Ge!==null){var qe=Ge.dehydrated;qe!==null&&ih(qe)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(t(163))}Ys||f.flags&512&&$v(f)}catch(Be){Hn(f,f.return,Be)}}if(f===u){pt=null;break}if(x=f.sibling,x!==null){x.return=f.return,pt=x;break}pt=f.return}}function nT(u){for(;pt!==null;){var f=pt;if(f===u){pt=null;break}var x=f.sibling;if(x!==null){x.return=f.return,pt=x;break}pt=f.return}}function sT(u){for(;pt!==null;){var f=pt;try{switch(f.tag){case 0:case 11:case 15:var x=f.return;try{$p(4,f)}catch(re){Hn(f,x,re)}break;case 1:var w=f.stateNode;if(typeof w.componentDidMount=="function"){var E=f.return;try{w.componentDidMount()}catch(re){Hn(f,E,re)}}var R=f.return;try{$v(f)}catch(re){Hn(f,R,re)}break;case 5:var F=f.return;try{$v(f)}catch(re){Hn(f,F,re)}}}catch(re){Hn(f,f.return,re)}if(f===u){pt=null;break}var J=f.sibling;if(J!==null){J.return=f.return,pt=J;break}pt=f.return}}var sP=Math.ceil,Fp=_.ReactCurrentDispatcher,Pv=_.ReactCurrentOwner,ti=_.ReactCurrentBatchConfig,un=0,Ts=null,is=null,Ps=0,zr=0,Pc=la(0),xs=0,Ah=null,fl=0,Lp=0,Ov=0,Mh=null,Tr=null,Uv=0,Oc=1/0,Mo=null,Pp=!1,zv=null,pa=null,Op=!1,ma=null,Up=0,Rh=0,Bv=null,zp=-1,Bp=0;function ur(){return(un&6)!==0?Se():zp!==-1?zp:zp=Se()}function ga(u){return(u.mode&1)===0?1:(un&2)!==0&&Ps!==0?Ps&-Ps:zL.transition!==null?(Bp===0&&(Bp=En()),Bp):(u=cn,u!==0||(u=window.event,u=u===void 0?16:iC(u.type)),u)}function Ci(u,f,x,w){if(50<Rh)throw Rh=0,Bv=null,Error(t(185));_s(u,x,w),((un&2)===0||u!==Ts)&&(u===Ts&&((un&2)===0&&(Lp|=x),xs===4&&xa(u,Ps)),Ir(u,w),x===1&&un===0&&(f.mode&1)===0&&(Oc=Se()+500,mp&&ua()))}function Ir(u,f){var x=u.callbackNode;lr(u,f);var w=Hs(u,u===Ts?Ps:0);if(w===0)x!==null&&G(x),u.callbackNode=null,u.callbackPriority=0;else if(f=w&-w,u.callbackPriority!==f){if(x!=null&&G(x),f===1)u.tag===0?UL(iT.bind(null,u)):WC(iT.bind(null,u)),FL(function(){(un&6)===0&&ua()}),x=null;else{switch(Hi(w)){case 1:x=Ze;break;case 4:x=st;break;case 16:x=dt;break;case 536870912:x=Ft;break;default:x=dt}x=fT(x,rT.bind(null,u))}u.callbackPriority=f,u.callbackNode=x}}function rT(u,f){if(zp=-1,Bp=0,(un&6)!==0)throw Error(t(327));var x=u.callbackNode;if(Uc()&&u.callbackNode!==x)return null;var w=Hs(u,u===Ts?Ps:0);if(w===0)return null;if((w&30)!==0||(w&u.expiredLanes)!==0||f)f=Vp(u,w);else{f=w;var E=un;un|=2;var R=aT();(Ts!==u||Ps!==f)&&(Mo=null,Oc=Se()+500,ml(u,f));do try{oP();break}catch(J){oT(u,J)}while(!0);iv(),Fp.current=R,un=E,is!==null?f=0:(Ts=null,Ps=0,f=xs)}if(f!==0){if(f===2&&(E=So(u),E!==0&&(w=E,f=Vv(u,E))),f===1)throw x=Ah,ml(u,0),xa(u,w),Ir(u,Se()),x;if(f===6)xa(u,w);else{if(E=u.current.alternate,(w&30)===0&&!rP(E)&&(f=Vp(u,w),f===2&&(R=So(u),R!==0&&(w=R,f=Vv(u,R))),f===1))throw x=Ah,ml(u,0),xa(u,w),Ir(u,Se()),x;switch(u.finishedWork=E,u.finishedLanes=w,f){case 0:case 1:throw Error(t(345));case 2:gl(u,Tr,Mo);break;case 3:if(xa(u,w),(w&130023424)===w&&(f=Uv+500-Se(),10<f)){if(Hs(u,0)!==0)break;if(E=u.suspendedLanes,(E&w)!==w){ur(),u.pingedLanes|=u.suspendedLanes&E;break}u.timeoutHandle=qx(gl.bind(null,u,Tr,Mo),f);break}gl(u,Tr,Mo);break;case 4:if(xa(u,w),(w&4194240)===w)break;for(f=u.eventTimes,E=-1;0<w;){var F=31-Vt(w);R=1<<F,F=f[F],F>E&&(E=F),w&=~R}if(w=E,w=Se()-w,w=(120>w?120:480>w?480:1080>w?1080:1920>w?1920:3e3>w?3e3:4320>w?4320:1960*sP(w/1960))-w,10<w){u.timeoutHandle=qx(gl.bind(null,u,Tr,Mo),w);break}gl(u,Tr,Mo);break;case 5:gl(u,Tr,Mo);break;default:throw Error(t(329))}}}return Ir(u,Se()),u.callbackNode===x?rT.bind(null,u):null}function Vv(u,f){var x=Mh;return u.current.memoizedState.isDehydrated&&(ml(u,f).flags|=256),u=Vp(u,f),u!==2&&(f=Tr,Tr=x,f!==null&&Gv(f)),u}function Gv(u){Tr===null?Tr=u:Tr.push.apply(Tr,u)}function rP(u){for(var f=u;;){if(f.flags&16384){var x=f.updateQueue;if(x!==null&&(x=x.stores,x!==null))for(var w=0;w<x.length;w++){var E=x[w],R=E.getSnapshot;E=E.value;try{if(!yi(R(),E))return!1}catch{return!1}}}if(x=f.child,f.subtreeFlags&16384&&x!==null)x.return=f,f=x;else{if(f===u)break;for(;f.sibling===null;){if(f.return===null||f.return===u)return!0;f=f.return}f.sibling.return=f.return,f=f.sibling}}return!0}function xa(u,f){for(f&=~Ov,f&=~Lp,u.suspendedLanes|=f,u.pingedLanes&=~f,u=u.expirationTimes;0<f;){var x=31-Vt(f),w=1<<x;u[x]=-1,f&=~w}}function iT(u){if((un&6)!==0)throw Error(t(327));Uc();var f=Hs(u,0);if((f&1)===0)return Ir(u,Se()),null;var x=Vp(u,f);if(u.tag!==0&&x===2){var w=So(u);w!==0&&(f=w,x=Vv(u,w))}if(x===1)throw x=Ah,ml(u,0),xa(u,f),Ir(u,Se()),x;if(x===6)throw Error(t(345));return u.finishedWork=u.current.alternate,u.finishedLanes=f,gl(u,Tr,Mo),Ir(u,Se()),null}function Wv(u,f){var x=un;un|=1;try{return u(f)}finally{un=x,un===0&&(Oc=Se()+500,mp&&ua())}}function pl(u){ma!==null&&ma.tag===0&&(un&6)===0&&Uc();var f=un;un|=1;var x=ti.transition,w=cn;try{if(ti.transition=null,cn=1,u)return u()}finally{cn=w,ti.transition=x,un=f,(un&6)===0&&ua()}}function Hv(){zr=Pc.current,Dn(Pc)}function ml(u,f){u.finishedWork=null,u.finishedLanes=0;var x=u.timeoutHandle;if(x!==-1&&(u.timeoutHandle=-1,$L(x)),is!==null)for(x=is.return;x!==null;){var w=x;switch(ev(w),w.tag){case 1:w=w.type.childContextTypes,w!=null&&fp();break;case 3:$c(),Dn(_r),Dn(js),fv();break;case 5:hv(w);break;case 4:$c();break;case 13:Dn(Bn);break;case 19:Dn(Bn);break;case 10:ov(w.type._context);break;case 22:case 23:Hv()}x=x.return}if(Ts=u,is=u=va(u.current,null),Ps=zr=f,xs=0,Ah=null,Ov=Lp=fl=0,Tr=Mh=null,ul!==null){for(f=0;f<ul.length;f++)if(x=ul[f],w=x.interleaved,w!==null){x.interleaved=null;var E=w.next,R=x.pending;if(R!==null){var F=R.next;R.next=E,w.next=F}x.pending=w}ul=null}return u}function oT(u,f){do{var x=is;try{if(iv(),Ep.current=Mp,Tp){for(var w=Vn.memoizedState;w!==null;){var E=w.queue;E!==null&&(E.pending=null),w=w.next}Tp=!1}if(dl=0,Es=gs=Vn=null,wh=!1,_h=0,Pv.current=null,x===null||x.return===null){xs=1,Ah=f,is=null;break}e:{var R=u,F=x.return,J=x,re=f;if(f=Ps,J.flags|=32768,re!==null&&typeof re=="object"&&typeof re.then=="function"){var Ee=re,Ge=J,qe=Ge.tag;if((Ge.mode&1)===0&&(qe===0||qe===11||qe===15)){var Be=Ge.alternate;Be?(Ge.updateQueue=Be.updateQueue,Ge.memoizedState=Be.memoizedState,Ge.lanes=Be.lanes):(Ge.updateQueue=null,Ge.memoizedState=null)}var ft=kE(F);if(ft!==null){ft.flags&=-257,NE(ft,F,J,R,f),ft.mode&1&&RE(R,Ee,f),f=ft,re=Ee;var xt=f.updateQueue;if(xt===null){var St=new Set;St.add(re),f.updateQueue=St}else xt.add(re);break e}else{if((f&1)===0){RE(R,Ee,f),Xv();break e}re=Error(t(426))}}else if(On&&J.mode&1){var ns=kE(F);if(ns!==null){(ns.flags&65536)===0&&(ns.flags|=256),NE(ns,F,J,R,f),sv(Fc(re,J));break e}}R=re=Fc(re,J),xs!==4&&(xs=2),Mh===null?Mh=[R]:Mh.push(R),R=F;do{switch(R.tag){case 3:R.flags|=65536,f&=-f,R.lanes|=f;var ye=AE(R,re,f);tE(R,ye);break e;case 1:J=re;var le=R.type,we=R.stateNode;if((R.flags&128)===0&&(typeof le.getDerivedStateFromError=="function"||we!==null&&typeof we.componentDidCatch=="function"&&(pa===null||!pa.has(we)))){R.flags|=65536,f&=-f,R.lanes|=f;var Qe=ME(R,J,f);tE(R,Qe);break e}}R=R.return}while(R!==null)}cT(x)}catch(_t){f=_t,is===x&&x!==null&&(is=x=x.return);continue}break}while(!0)}function aT(){var u=Fp.current;return Fp.current=Mp,u===null?Mp:u}function Xv(){(xs===0||xs===3||xs===2)&&(xs=4),Ts===null||(fl&268435455)===0&&(Lp&268435455)===0||xa(Ts,Ps)}function Vp(u,f){var x=un;un|=2;var w=aT();(Ts!==u||Ps!==f)&&(Mo=null,ml(u,f));do try{iP();break}catch(E){oT(u,E)}while(!0);if(iv(),un=x,Fp.current=w,is!==null)throw Error(t(261));return Ts=null,Ps=0,xs}function iP(){for(;is!==null;)lT(is)}function oP(){for(;is!==null&&!xe();)lT(is)}function lT(u){var f=dT(u.alternate,u,zr);u.memoizedProps=u.pendingProps,f===null?cT(u):is=f,Pv.current=null}function cT(u){var f=u;do{var x=f.alternate;if(u=f.return,(f.flags&32768)===0){if(x=QL(x,f,zr),x!==null){is=x;return}}else{if(x=JL(x,f),x!==null){x.flags&=32767,is=x;return}if(u!==null)u.flags|=32768,u.subtreeFlags=0,u.deletions=null;else{xs=6,is=null;return}}if(f=f.sibling,f!==null){is=f;return}is=f=u}while(f!==null);xs===0&&(xs=5)}function gl(u,f,x){var w=cn,E=ti.transition;try{ti.transition=null,cn=1,aP(u,f,x,w)}finally{ti.transition=E,cn=w}return null}function aP(u,f,x,w){do Uc();while(ma!==null);if((un&6)!==0)throw Error(t(327));x=u.finishedWork;var E=u.finishedLanes;if(x===null)return null;if(u.finishedWork=null,u.finishedLanes=0,x===u.current)throw Error(t(177));u.callbackNode=null,u.callbackPriority=0;var R=x.lanes|x.childLanes;if(Fs(u,R),u===Ts&&(is=Ts=null,Ps=0),(x.subtreeFlags&2064)===0&&(x.flags&2064)===0||Op||(Op=!0,fT(dt,function(){return Uc(),null})),R=(x.flags&15990)!==0,(x.subtreeFlags&15990)!==0||R){R=ti.transition,ti.transition=null;var F=cn;cn=1;var J=un;un|=4,Pv.current=null,tP(u,x),JE(x,u),IL(Xx),Jf=!!Hx,Xx=Hx=null,u.current=x,nP(x),Te(),un=J,cn=F,ti.transition=R}else u.current=x;if(Op&&(Op=!1,ma=u,Up=E),R=u.pendingLanes,R===0&&(pa=null),nn(x.stateNode),Ir(u,Se()),f!==null)for(w=u.onRecoverableError,x=0;x<f.length;x++)E=f[x],w(E.value,{componentStack:E.stack,digest:E.digest});if(Pp)throw Pp=!1,u=zv,zv=null,u;return(Up&1)!==0&&u.tag!==0&&Uc(),R=u.pendingLanes,(R&1)!==0?u===Bv?Rh++:(Rh=0,Bv=u):Rh=0,ua(),null}function Uc(){if(ma!==null){var u=Hi(Up),f=ti.transition,x=cn;try{if(ti.transition=null,cn=16>u?16:u,ma===null)var w=!1;else{if(u=ma,ma=null,Up=0,(un&6)!==0)throw Error(t(331));var E=un;for(un|=4,pt=u.current;pt!==null;){var R=pt,F=R.child;if((pt.flags&16)!==0){var J=R.deletions;if(J!==null){for(var re=0;re<J.length;re++){var Ee=J[re];for(pt=Ee;pt!==null;){var Ge=pt;switch(Ge.tag){case 0:case 11:case 15:Ih(8,Ge,R)}var qe=Ge.child;if(qe!==null)qe.return=Ge,pt=qe;else for(;pt!==null;){Ge=pt;var Be=Ge.sibling,ft=Ge.return;if(qE(Ge),Ge===Ee){pt=null;break}if(Be!==null){Be.return=ft,pt=Be;break}pt=ft}}}var xt=R.alternate;if(xt!==null){var St=xt.child;if(St!==null){xt.child=null;do{var ns=St.sibling;St.sibling=null,St=ns}while(St!==null)}}pt=R}}if((R.subtreeFlags&2064)!==0&&F!==null)F.return=R,pt=F;else e:for(;pt!==null;){if(R=pt,(R.flags&2048)!==0)switch(R.tag){case 0:case 11:case 15:Ih(9,R,R.return)}var ye=R.sibling;if(ye!==null){ye.return=R.return,pt=ye;break e}pt=R.return}}var le=u.current;for(pt=le;pt!==null;){F=pt;var we=F.child;if((F.subtreeFlags&2064)!==0&&we!==null)we.return=F,pt=we;else e:for(F=le;pt!==null;){if(J=pt,(J.flags&2048)!==0)try{switch(J.tag){case 0:case 11:case 15:$p(9,J)}}catch(_t){Hn(J,J.return,_t)}if(J===F){pt=null;break e}var Qe=J.sibling;if(Qe!==null){Qe.return=J.return,pt=Qe;break e}pt=J.return}}if(un=E,ua(),bt&&typeof bt.onPostCommitFiberRoot=="function")try{bt.onPostCommitFiberRoot(kt,u)}catch{}w=!0}return w}finally{cn=x,ti.transition=f}}return!1}function uT(u,f,x){f=Fc(x,f),f=AE(u,f,1),u=da(u,f,1),f=ur(),u!==null&&(_s(u,1,f),Ir(u,f))}function Hn(u,f,x){if(u.tag===3)uT(u,u,x);else for(;f!==null;){if(f.tag===3){uT(f,u,x);break}else if(f.tag===1){var w=f.stateNode;if(typeof f.type.getDerivedStateFromError=="function"||typeof w.componentDidCatch=="function"&&(pa===null||!pa.has(w))){u=Fc(x,u),u=ME(f,u,1),f=da(f,u,1),u=ur(),f!==null&&(_s(f,1,u),Ir(f,u));break}}f=f.return}}function lP(u,f,x){var w=u.pingCache;w!==null&&w.delete(f),f=ur(),u.pingedLanes|=u.suspendedLanes&x,Ts===u&&(Ps&x)===x&&(xs===4||xs===3&&(Ps&130023424)===Ps&&500>Se()-Uv?ml(u,0):Ov|=x),Ir(u,f)}function hT(u,f){f===0&&((u.mode&1)===0?f=1:(f=Wn,Wn<<=1,(Wn&130023424)===0&&(Wn=4194304)));var x=ur();u=To(u,f),u!==null&&(_s(u,f,x),Ir(u,x))}function cP(u){var f=u.memoizedState,x=0;f!==null&&(x=f.retryLane),hT(u,x)}function uP(u,f){var x=0;switch(u.tag){case 13:var w=u.stateNode,E=u.memoizedState;E!==null&&(x=E.retryLane);break;case 19:w=u.stateNode;break;default:throw Error(t(314))}w!==null&&w.delete(f),hT(u,x)}var dT;dT=function(u,f,x){if(u!==null)if(u.memoizedProps!==f.pendingProps||_r.current)Er=!0;else{if((u.lanes&x)===0&&(f.flags&128)===0)return Er=!1,ZL(u,f,x);Er=(u.flags&131072)!==0}else Er=!1,On&&(f.flags&1048576)!==0&&HC(f,xp,f.index);switch(f.lanes=0,f.tag){case 2:var w=f.type;Np(u,f),u=f.pendingProps;var E=Ic(f,js.current);Dc(f,x),E=gv(null,f,w,u,E,x);var R=xv();return f.flags|=1,typeof E=="object"&&E!==null&&typeof E.render=="function"&&E.$$typeof===void 0?(f.tag=1,f.memoizedState=null,f.updateQueue=null,Cr(w)?(R=!0,pp(f)):R=!1,f.memoizedState=E.state!==null&&E.state!==void 0?E.state:null,cv(f),E.updater=Rp,f.stateNode=E,E._reactInternals=f,_v(f,w,u,x),f=Iv(null,f,w,!0,R,x)):(f.tag=0,On&&R&&Jx(f),cr(null,f,E,x),f=f.child),f;case 16:w=f.elementType;e:{switch(Np(u,f),u=f.pendingProps,E=w._init,w=E(w._payload),f.type=w,E=f.tag=dP(w),u=Si(w,u),E){case 0:f=Tv(null,f,w,u,x);break e;case 1:f=OE(null,f,w,u,x);break e;case 11:f=DE(null,f,w,u,x);break e;case 14:f=$E(null,f,w,Si(w.type,u),x);break e}throw Error(t(306,w,""))}return f;case 0:return w=f.type,E=f.pendingProps,E=f.elementType===w?E:Si(w,E),Tv(u,f,w,E,x);case 1:return w=f.type,E=f.pendingProps,E=f.elementType===w?E:Si(w,E),OE(u,f,w,E,x);case 3:e:{if(UE(f),u===null)throw Error(t(387));w=f.pendingProps,R=f.memoizedState,E=R.element,eE(u,f),_p(f,w,null,x);var F=f.memoizedState;if(w=F.element,R.isDehydrated)if(R={element:w,isDehydrated:!1,cache:F.cache,pendingSuspenseBoundaries:F.pendingSuspenseBoundaries,transitions:F.transitions},f.updateQueue.baseState=R,f.memoizedState=R,f.flags&256){E=Fc(Error(t(423)),f),f=zE(u,f,w,x,E);break e}else if(w!==E){E=Fc(Error(t(424)),f),f=zE(u,f,w,x,E);break e}else for(Ur=aa(f.stateNode.containerInfo.firstChild),Or=f,On=!0,bi=null,x=QC(f,null,w,x),f.child=x;x;)x.flags=x.flags&-3|4096,x=x.sibling;else{if(Rc(),w===E){f=Ao(u,f,x);break e}cr(u,f,w,x)}f=f.child}return f;case 5:return sE(f),u===null&&nv(f),w=f.type,E=f.pendingProps,R=u!==null?u.memoizedProps:null,F=E.children,jx(w,E)?F=null:R!==null&&jx(w,R)&&(f.flags|=32),PE(u,f),cr(u,f,F,x),f.child;case 6:return u===null&&nv(f),null;case 13:return BE(u,f,x);case 4:return uv(f,f.stateNode.containerInfo),w=f.pendingProps,u===null?f.child=kc(f,null,w,x):cr(u,f,w,x),f.child;case 11:return w=f.type,E=f.pendingProps,E=f.elementType===w?E:Si(w,E),DE(u,f,w,E,x);case 7:return cr(u,f,f.pendingProps,x),f.child;case 8:return cr(u,f,f.pendingProps.children,x),f.child;case 12:return cr(u,f,f.pendingProps.children,x),f.child;case 10:e:{if(w=f.type._context,E=f.pendingProps,R=f.memoizedProps,F=E.value,Rn(bp,w._currentValue),w._currentValue=F,R!==null)if(yi(R.value,F)){if(R.children===E.children&&!_r.current){f=Ao(u,f,x);break e}}else for(R=f.child,R!==null&&(R.return=f);R!==null;){var J=R.dependencies;if(J!==null){F=R.child;for(var re=J.firstContext;re!==null;){if(re.context===w){if(R.tag===1){re=Io(-1,x&-x),re.tag=2;var Ee=R.updateQueue;if(Ee!==null){Ee=Ee.shared;var Ge=Ee.pending;Ge===null?re.next=re:(re.next=Ge.next,Ge.next=re),Ee.pending=re}}R.lanes|=x,re=R.alternate,re!==null&&(re.lanes|=x),av(R.return,x,f),J.lanes|=x;break}re=re.next}}else if(R.tag===10)F=R.type===f.type?null:R.child;else if(R.tag===18){if(F=R.return,F===null)throw Error(t(341));F.lanes|=x,J=F.alternate,J!==null&&(J.lanes|=x),av(F,x,f),F=R.sibling}else F=R.child;if(F!==null)F.return=R;else for(F=R;F!==null;){if(F===f){F=null;break}if(R=F.sibling,R!==null){R.return=F.return,F=R;break}F=F.return}R=F}cr(u,f,E.children,x),f=f.child}return f;case 9:return E=f.type,w=f.pendingProps.children,Dc(f,x),E=Jr(E),w=w(E),f.flags|=1,cr(u,f,w,x),f.child;case 14:return w=f.type,E=Si(w,f.pendingProps),E=Si(w.type,E),$E(u,f,w,E,x);case 15:return FE(u,f,f.type,f.pendingProps,x);case 17:return w=f.type,E=f.pendingProps,E=f.elementType===w?E:Si(w,E),Np(u,f),f.tag=1,Cr(w)?(u=!0,pp(f)):u=!1,Dc(f,x),TE(f,w,E),_v(f,w,E,x),Iv(null,f,w,!0,u,x);case 19:return GE(u,f,x);case 22:return LE(u,f,x)}throw Error(t(156,f.tag))};function fT(u,f){return Yf(u,f)}function hP(u,f,x,w){this.tag=u,this.key=x,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=f,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=w,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ni(u,f,x,w){return new hP(u,f,x,w)}function jv(u){return u=u.prototype,!(!u||!u.isReactComponent)}function dP(u){if(typeof u=="function")return jv(u)?1:0;if(u!=null){if(u=u.$$typeof,u===$)return 11;if(u===V)return 14}return 2}function va(u,f){var x=u.alternate;return x===null?(x=ni(u.tag,f,u.key,u.mode),x.elementType=u.elementType,x.type=u.type,x.stateNode=u.stateNode,x.alternate=u,u.alternate=x):(x.pendingProps=f,x.type=u.type,x.flags=0,x.subtreeFlags=0,x.deletions=null),x.flags=u.flags&14680064,x.childLanes=u.childLanes,x.lanes=u.lanes,x.child=u.child,x.memoizedProps=u.memoizedProps,x.memoizedState=u.memoizedState,x.updateQueue=u.updateQueue,f=u.dependencies,x.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext},x.sibling=u.sibling,x.index=u.index,x.ref=u.ref,x}function Gp(u,f,x,w,E,R){var F=2;if(w=u,typeof u=="function")jv(u)&&(F=1);else if(typeof u=="string")F=5;else e:switch(u){case N:return xl(x.children,E,R,f);case D:F=8,E|=8;break;case M:return u=ni(12,x,f,E|2),u.elementType=M,u.lanes=R,u;case O:return u=ni(13,x,f,E),u.elementType=O,u.lanes=R,u;case B:return u=ni(19,x,f,E),u.elementType=B,u.lanes=R,u;case q:return Wp(x,E,R,f);default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case T:F=10;break e;case I:F=9;break e;case $:F=11;break e;case V:F=14;break e;case H:F=16,w=null;break e}throw Error(t(130,u==null?u:typeof u,""))}return f=ni(F,x,f,E),f.elementType=u,f.type=w,f.lanes=R,f}function xl(u,f,x,w){return u=ni(7,u,w,f),u.lanes=x,u}function Wp(u,f,x,w){return u=ni(22,u,w,f),u.elementType=q,u.lanes=x,u.stateNode={isHidden:!1},u}function qv(u,f,x){return u=ni(6,u,null,f),u.lanes=x,u}function Kv(u,f,x){return f=ni(4,u.children!==null?u.children:[],u.key,f),f.lanes=x,f.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},f}function fP(u,f,x,w,E){this.tag=f,this.containerInfo=u,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Xs(0),this.expirationTimes=Xs(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Xs(0),this.identifierPrefix=w,this.onRecoverableError=E,this.mutableSourceEagerHydrationData=null}function Yv(u,f,x,w,E,R,F,J,re){return u=new fP(u,f,x,J,re),f===1?(f=1,R===!0&&(f|=8)):f=0,R=ni(3,null,null,f),u.current=R,R.stateNode=u,R.memoizedState={element:w,isDehydrated:x,cache:null,transitions:null,pendingSuspenseBoundaries:null},cv(R),u}function pP(u,f,x){var w=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:k,key:w==null?null:""+w,children:u,containerInfo:f,implementation:x}}function pT(u){if(!u)return ca;u=u._reactInternals;e:{if(Wi(u)!==u||u.tag!==1)throw Error(t(170));var f=u;do{switch(f.tag){case 3:f=f.stateNode.context;break e;case 1:if(Cr(f.type)){f=f.stateNode.__reactInternalMemoizedMergedChildContext;break e}}f=f.return}while(f!==null);throw Error(t(171))}if(u.tag===1){var x=u.type;if(Cr(x))return VC(u,x,f)}return f}function mT(u,f,x,w,E,R,F,J,re){return u=Yv(x,w,!0,u,E,R,F,J,re),u.context=pT(null),x=u.current,w=ur(),E=ga(x),R=Io(w,E),R.callback=f??null,da(x,R,E),u.current.lanes=E,_s(u,E,w),Ir(u,w),u}function Hp(u,f,x,w){var E=f.current,R=ur(),F=ga(E);return x=pT(x),f.context===null?f.context=x:f.pendingContext=x,f=Io(R,F),f.payload={element:u},w=w===void 0?null:w,w!==null&&(f.callback=w),u=da(E,f,F),u!==null&&(Ci(u,E,F,R),wp(u,E,F)),F}function Xp(u){if(u=u.current,!u.child)return null;switch(u.child.tag){case 5:return u.child.stateNode;default:return u.child.stateNode}}function gT(u,f){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var x=u.retryLane;u.retryLane=x!==0&&x<f?x:f}}function Zv(u,f){gT(u,f),(u=u.alternate)&&gT(u,f)}function mP(){return null}var xT=typeof reportError=="function"?reportError:function(u){console.error(u)};function Qv(u){this._internalRoot=u}jp.prototype.render=Qv.prototype.render=function(u){var f=this._internalRoot;if(f===null)throw Error(t(409));Hp(u,f,null,null)},jp.prototype.unmount=Qv.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var f=u.containerInfo;pl(function(){Hp(null,u,null,null)}),f[wo]=null}};function jp(u){this._internalRoot=u}jp.prototype.unstable_scheduleHydration=function(u){if(u){var f=eC();u={blockedOn:null,target:u,priority:f};for(var x=0;x<ra.length&&f!==0&&f<ra[x].priority;x++);ra.splice(x,0,u),x===0&&sC(u)}};function Jv(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function qp(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11&&(u.nodeType!==8||u.nodeValue!==" react-mount-point-unstable "))}function vT(){}function gP(u,f,x,w,E){if(E){if(typeof w=="function"){var R=w;w=function(){var Ee=Xp(F);R.call(Ee)}}var F=mT(f,w,u,0,null,!1,!1,"",vT);return u._reactRootContainer=F,u[wo]=F.current,ph(u.nodeType===8?u.parentNode:u),pl(),F}for(;E=u.lastChild;)u.removeChild(E);if(typeof w=="function"){var J=w;w=function(){var Ee=Xp(re);J.call(Ee)}}var re=Yv(u,0,!1,null,null,!1,!1,"",vT);return u._reactRootContainer=re,u[wo]=re.current,ph(u.nodeType===8?u.parentNode:u),pl(function(){Hp(f,re,x,w)}),re}function Kp(u,f,x,w,E){var R=x._reactRootContainer;if(R){var F=R;if(typeof E=="function"){var J=E;E=function(){var re=Xp(F);J.call(re)}}Hp(f,F,u,E)}else F=gP(x,f,u,E,w);return Xp(F)}Q_=function(u){switch(u.tag){case 3:var f=u.stateNode;if(f.current.memoizedState.isDehydrated){var x=Qt(f.pendingLanes);x!==0&&(Cs(f,x|1),Ir(f,Se()),(un&6)===0&&(Oc=Se()+500,ua()))}break;case 13:pl(function(){var w=To(u,1);if(w!==null){var E=ur();Ci(w,u,1,E)}}),Zv(u,1)}},Cx=function(u){if(u.tag===13){var f=To(u,134217728);if(f!==null){var x=ur();Ci(f,u,134217728,x)}Zv(u,134217728)}},J_=function(u){if(u.tag===13){var f=ga(u),x=To(u,f);if(x!==null){var w=ur();Ci(x,u,f,w)}Zv(u,f)}},eC=function(){return cn},tC=function(u,f){var x=cn;try{return cn=u,f()}finally{cn=x}},tt=function(u,f,x){switch(f){case"input":if(Ke(u,x),f=x.name,x.type==="radio"&&f!=null){for(x=u;x.parentNode;)x=x.parentNode;for(x=x.querySelectorAll("input[name="+JSON.stringify(""+f)+'][type="radio"]'),f=0;f<x.length;f++){var w=x[f];if(w!==u&&w.form===u.form){var E=dp(w);if(!E)throw Error(t(90));He(w),Ke(w,E)}}}break;case"textarea":Re(u,x);break;case"select":f=x.value,f!=null&&X(u,!!x.multiple,f,!1)}},Sn=Wv,Jn=pl;var xP={usingClientEntryPoint:!1,Events:[xh,Ec,dp,nt,Pt,Wv]},kh={findFiberByHostInstance:ol,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},vP={bundleType:kh.bundleType,version:kh.version,rendererPackageName:kh.rendererPackageName,rendererConfig:kh.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:_.ReactCurrentDispatcher,findHostInstanceByFiber:function(u){return u=qf(u),u===null?null:u.stateNode},findFiberByHostInstance:kh.findFiberByHostInstance||mP,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Yp=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Yp.isDisabled&&Yp.supportsFiber)try{kt=Yp.inject(vP),bt=Yp}catch{}}return Ar.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=xP,Ar.createPortal=function(u,f){var x=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Jv(f))throw Error(t(200));return pP(u,f,null,x)},Ar.createRoot=function(u,f){if(!Jv(u))throw Error(t(299));var x=!1,w="",E=xT;return f!=null&&(f.unstable_strictMode===!0&&(x=!0),f.identifierPrefix!==void 0&&(w=f.identifierPrefix),f.onRecoverableError!==void 0&&(E=f.onRecoverableError)),f=Yv(u,1,!1,null,null,x,!1,w,E),u[wo]=f.current,ph(u.nodeType===8?u.parentNode:u),new Qv(f)},Ar.findDOMNode=function(u){if(u==null)return null;if(u.nodeType===1)return u;var f=u._reactInternals;if(f===void 0)throw typeof u.render=="function"?Error(t(188)):(u=Object.keys(u).join(","),Error(t(268,u)));return u=qf(f),u=u===null?null:u.stateNode,u},Ar.flushSync=function(u){return pl(u)},Ar.hydrate=function(u,f,x){if(!qp(f))throw Error(t(200));return Kp(null,u,f,!0,x)},Ar.hydrateRoot=function(u,f,x){if(!Jv(u))throw Error(t(405));var w=x!=null&&x.hydratedSources||null,E=!1,R="",F=xT;if(x!=null&&(x.unstable_strictMode===!0&&(E=!0),x.identifierPrefix!==void 0&&(R=x.identifierPrefix),x.onRecoverableError!==void 0&&(F=x.onRecoverableError)),f=mT(f,null,u,1,x??null,E,!1,R,F),u[wo]=f.current,ph(u),w)for(u=0;u<w.length;u++)x=w[u],E=x._getVersion,E=E(x._source),f.mutableSourceEagerHydrationData==null?f.mutableSourceEagerHydrationData=[x,E]:f.mutableSourceEagerHydrationData.push(x,E);return new jp(f)},Ar.render=function(u,f,x){if(!qp(f))throw Error(t(200));return Kp(null,u,f,!1,x)},Ar.unmountComponentAtNode=function(u){if(!qp(u))throw Error(t(40));return u._reactRootContainer?(pl(function(){Kp(null,null,u,!1,function(){u._reactRootContainer=null,u[wo]=null})}),!0):!1},Ar.unstable_batchedUpdates=Wv,Ar.unstable_renderSubtreeIntoContainer=function(u,f,x,w){if(!qp(x))throw Error(t(200));if(u==null||u._reactInternals===void 0)throw Error(t(38));return Kp(u,f,x,!1,w)},Ar.version="18.3.1-next-f1338f8080-20240426",Ar}var TT;function MP(){if(TT)return ny.exports;TT=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),ny.exports=AP(),ny.exports}var IT;function RP(){if(IT)return Zp;IT=1;var n=MP();return Zp.createRoot=n.createRoot,Zp.hydrateRoot=n.hydrateRoot,Zp}var kP=RP();const NP=Ob(kP),DP="_automatonContainer_d8ku9_2",$P="_automatonRow_d8ku9_10",FP="_cell_d8ku9_15",LP="_alive_d8ku9_21",PP="_dead_d8ku9_24",zc={automatonContainer:DP,automatonRow:$P,cell:FP,alive:LP,dead:PP},OP=({generationsHistory:n,onCellClick:e})=>{const t=Ae.useRef(null);return Ae.useEffect(()=>{t.current&&(t.current.scrollTop=t.current.scrollHeight)},[n]),!n||n.length===0?pe.jsx("div",{className:zc.automatonContainer,children:"No generations to display."}):pe.jsx("div",{ref:t,className:zc.automatonContainer,style:{maxHeight:"500px",overflowY:"auto",border:"1px solid #ddd",padding:"5px"},children:n.map((s,r)=>pe.jsx("div",{className:zc.automatonRow,children:s.map((i,o)=>pe.jsx("div",{className:`${zc.cell} ${i===1?zc.alive:zc.dead}`,title:`Gen: ${r}, Cell: ${o}, State: ${i}`,onClick:()=>e&&e(r,o),onKeyPress:a=>{(a.key==="Enter"||a.key===" ")&&e&&e(r,o)},role:"button",tabIndex:0},o))},r))})},UP=({onStart:n,onPause:e,onReset:t,onRuleChange:s,currentRule:r,isRunning:i,simulationSpeed:o=200,onSpeedChange:a})=>{const[l,c]=Ae.useState(r.toString());Ae.useEffect(()=>{c(r.toString())},[r]);const h=Ae.useCallback(m=>{const g=m.target.value;c(g);const b=parseInt(g,10);!isNaN(b)&&b>=0&&b<=255?s&&s(b):g===""&&s&&s(0)},[s]),d=Ae.useCallback(m=>{const g=parseInt(m.target.value,10);a&&a(g)},[a]),p={controlsContainer:{display:"flex",alignItems:"center",gap:"10px",padding:"10px",marginBottom:"20px",flexWrap:"wrap",justifyContent:"center"},label:{marginRight:"5px"},input:{width:"60px",padding:"8px",border:"1px solid #ccc",borderRadius:"4px"},button:{padding:"8px 15px",border:"none",borderRadius:"4px",cursor:"pointer",backgroundColor:"#007bff",color:"white"},buttonDisabled:{backgroundColor:"#6c757d"},controlGroup:{display:"flex",alignItems:"center",gap:"10px",marginLeft:"10px"},slider:{width:"100px"},sliderLabel:{fontSize:"0.9em",color:"#333",minWidth:"100px",textAlign:"right"}};return pe.jsxs("div",{style:p.controlsContainer,children:[pe.jsx("label",{htmlFor:"ruleNumber",style:p.label,children:"Rule:"}),pe.jsx("input",{type:"number",id:"ruleNumber",value:l,onChange:h,min:"0",max:"255",style:p.input,disabled:i}),pe.jsx("button",{onClick:n,disabled:i,style:{...p.button,...i&&p.buttonDisabled},children:"Start"}),pe.jsx("button",{onClick:e,disabled:!i,style:{...p.button,...!i&&p.buttonDisabled},children:"Pause"}),pe.jsx("button",{onClick:t,style:p.button,children:"Reset"}),pe.jsxs("div",{style:p.controlGroup,children:[pe.jsx("label",{style:p.sliderLabel,children:"Speed:"}),pe.jsx("input",{type:"range",min:"50",max:"1000",step:"50",value:o,onChange:d,style:p.slider}),pe.jsxs("span",{style:{marginLeft:"5px",fontSize:"0.9em"},children:[o,"ms"]})]})]})},zP=(n,e=8)=>{if(typeof n!="number"||n<0||n>255)return console.error("Invalid rule number. Must be between 0 and 255."),Array(e).fill(0);let t=n.toString(2);for(;t.length<e;)t="0"+t;return t.split("").map(Number)},BP=(n,e)=>{if(!n||n.length===0)return[];const t=zP(e),s=[],r=n.length;for(let i=0;i<r;i++){const o=n[(i-1+r)%r],a=n[i],l=n[(i+1)%r],c=o<<2|a<<1|l;s[i]=t[7-c]}return s};/* @license twgl.js 5.5.4 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/twgl.js for details */let Pg=Float32Array;function Na(n,e,t){const s=new Pg(3);return n&&(s[0]=n),e&&(s[1]=e),t&&(s[2]=t),s}function VP(n,e,t){return t=t||new Pg(3),t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t}function AT(n,e,t){t=t||new Pg(3);const s=n[2]*e[0]-n[0]*e[2],r=n[0]*e[1]-n[1]*e[0];return t[0]=n[1]*e[2]-n[2]*e[1],t[1]=s,t[2]=r,t}function iy(n,e){e=e||new Pg(3);const t=n[0]*n[0]+n[1]*n[1]+n[2]*n[2],s=Math.sqrt(t);return s>1e-5?(e[0]=n[0]/s,e[1]=n[1]/s,e[2]=n[2]/s):(e[0]=0,e[1]=0,e[2]=0),e}let Ln=Float32Array;function GP(n){const e=Ln;return Ln=n,e}function WP(n,e){return e=e||new Ln(16),e[0]=-n[0],e[1]=-n[1],e[2]=-n[2],e[3]=-n[3],e[4]=-n[4],e[5]=-n[5],e[6]=-n[6],e[7]=-n[7],e[8]=-n[8],e[9]=-n[9],e[10]=-n[10],e[11]=-n[11],e[12]=-n[12],e[13]=-n[13],e[14]=-n[14],e[15]=-n[15],e}function HP(){return new Ln(16).fill(0)}function $A(n,e){return e=e||new Ln(16),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],e}function FA(n){return n=n||new Ln(16),n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function XP(n,e){if(e=e||new Ln(16),e===n){let S;return S=n[1],n[1]=n[4],n[4]=S,S=n[2],n[2]=n[8],n[8]=S,S=n[3],n[3]=n[12],n[12]=S,S=n[6],n[6]=n[9],n[9]=S,S=n[7],n[7]=n[13],n[13]=S,S=n[11],n[11]=n[14],n[14]=S,e}const t=n[0*4+0],s=n[0*4+1],r=n[0*4+2],i=n[0*4+3],o=n[1*4+0],a=n[1*4+1],l=n[1*4+2],c=n[1*4+3],h=n[2*4+0],d=n[2*4+1],p=n[2*4+2],m=n[2*4+3],g=n[3*4+0],b=n[3*4+1],y=n[3*4+2],v=n[3*4+3];return e[0]=t,e[1]=o,e[2]=h,e[3]=g,e[4]=s,e[5]=a,e[6]=d,e[7]=b,e[8]=r,e[9]=l,e[10]=p,e[11]=y,e[12]=i,e[13]=c,e[14]=m,e[15]=v,e}function LA(n,e){e=e||new Ln(16);const t=n[0*4+0],s=n[0*4+1],r=n[0*4+2],i=n[0*4+3],o=n[1*4+0],a=n[1*4+1],l=n[1*4+2],c=n[1*4+3],h=n[2*4+0],d=n[2*4+1],p=n[2*4+2],m=n[2*4+3],g=n[3*4+0],b=n[3*4+1],y=n[3*4+2],v=n[3*4+3],S=p*v,C=y*m,_=l*v,A=y*c,k=l*m,N=p*c,D=r*v,M=y*i,T=r*m,I=p*i,$=r*c,O=l*i,B=h*b,V=g*d,H=o*b,q=g*a,P=o*d,K=h*a,Z=t*b,U=g*s,z=t*d,ne=h*s,Y=t*a,te=o*s,he=S*a+A*d+k*b-(C*a+_*d+N*b),se=C*s+D*d+I*b-(S*s+M*d+T*b),Q=_*s+M*a+$*b-(A*s+D*a+O*b),de=N*s+T*a+O*d-(k*s+I*a+$*d),ce=1/(t*he+o*se+h*Q+g*de);return e[0]=ce*he,e[1]=ce*se,e[2]=ce*Q,e[3]=ce*de,e[4]=ce*(C*o+_*h+N*g-(S*o+A*h+k*g)),e[5]=ce*(S*t+M*h+T*g-(C*t+D*h+I*g)),e[6]=ce*(A*t+D*o+O*g-(_*t+M*o+$*g)),e[7]=ce*(k*t+I*o+$*h-(N*t+T*o+O*h)),e[8]=ce*(B*c+q*m+P*v-(V*c+H*m+K*v)),e[9]=ce*(V*i+Z*m+ne*v-(B*i+U*m+z*v)),e[10]=ce*(H*i+U*c+Y*v-(q*i+Z*c+te*v)),e[11]=ce*(K*i+z*c+te*m-(P*i+ne*c+Y*m)),e[12]=ce*(H*p+K*y+V*l-(P*y+B*l+q*p)),e[13]=ce*(z*y+B*r+U*p-(Z*p+ne*y+V*r)),e[14]=ce*(Z*l+te*y+q*r-(Y*y+H*r+U*l)),e[15]=ce*(Y*p+P*r+ne*l-(z*l+te*p+K*r)),e}function jP(n,e,t){t=t||new Ln(16);const s=n[0],r=n[1],i=n[2],o=n[3],a=n[4],l=n[5],c=n[6],h=n[7],d=n[8],p=n[9],m=n[10],g=n[11],b=n[12],y=n[13],v=n[14],S=n[15],C=e[0],_=e[1],A=e[2],k=e[3],N=e[4],D=e[5],M=e[6],T=e[7],I=e[8],$=e[9],O=e[10],B=e[11],V=e[12],H=e[13],q=e[14],P=e[15];return t[0]=s*C+a*_+d*A+b*k,t[1]=r*C+l*_+p*A+y*k,t[2]=i*C+c*_+m*A+v*k,t[3]=o*C+h*_+g*A+S*k,t[4]=s*N+a*D+d*M+b*T,t[5]=r*N+l*D+p*M+y*T,t[6]=i*N+c*D+m*M+v*T,t[7]=o*N+h*D+g*M+S*T,t[8]=s*I+a*$+d*O+b*B,t[9]=r*I+l*$+p*O+y*B,t[10]=i*I+c*$+m*O+v*B,t[11]=o*I+h*$+g*O+S*B,t[12]=s*V+a*H+d*q+b*P,t[13]=r*V+l*H+p*q+y*P,t[14]=i*V+c*H+m*q+v*P,t[15]=o*V+h*H+g*q+S*P,t}function qP(n,e,t){return t=t||FA(),n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11]),t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function KP(n,e){return e=e||Na(),e[0]=n[12],e[1]=n[13],e[2]=n[14],e}function YP(n,e,t){t=t||Na();const s=e*4;return t[0]=n[s+0],t[1]=n[s+1],t[2]=n[s+2],t}function ZP(n,e,t,s){s!==n&&(s=$A(n,s));const r=t*4;return s[r+0]=e[0],s[r+1]=e[1],s[r+2]=e[2],s}function QP(n,e,t,s,r){r=r||new Ln(16);const i=Math.tan(Math.PI*.5-.5*n),o=1/(t-s);return r[0]=i/e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=i,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=(t+s)*o,r[11]=-1,r[12]=0,r[13]=0,r[14]=t*s*o*2,r[15]=0,r}function JP(n,e,t,s,r,i,o){return o=o||new Ln(16),o[0]=2/(e-n),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(s-t),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=2/(r-i),o[11]=0,o[12]=(e+n)/(n-e),o[13]=(s+t)/(t-s),o[14]=(i+r)/(r-i),o[15]=1,o}function eO(n,e,t,s,r,i,o){o=o||new Ln(16);const a=e-n,l=s-t,c=r-i;return o[0]=2*r/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*r/l,o[6]=0,o[7]=0,o[8]=(n+e)/a,o[9]=(s+t)/l,o[10]=i/c,o[11]=-1,o[12]=0,o[13]=0,o[14]=r*i/c,o[15]=0,o}let ba,vl,Ro;function tO(n,e,t,s){return s=s||new Ln(16),ba=ba||Na(),vl=vl||Na(),Ro=Ro||Na(),iy(VP(n,e,Ro),Ro),iy(AT(t,Ro,ba),ba),iy(AT(Ro,ba,vl),vl),s[0]=ba[0],s[1]=ba[1],s[2]=ba[2],s[3]=0,s[4]=vl[0],s[5]=vl[1],s[6]=vl[2],s[7]=0,s[8]=Ro[0],s[9]=Ro[1],s[10]=Ro[2],s[11]=0,s[12]=n[0],s[13]=n[1],s[14]=n[2],s[15]=1,s}function nO(n,e){return e=e||new Ln(16),e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function sO(n,e,t){t=t||new Ln(16);const s=e[0],r=e[1],i=e[2],o=n[0],a=n[1],l=n[2],c=n[3],h=n[1*4+0],d=n[1*4+1],p=n[1*4+2],m=n[1*4+3],g=n[2*4+0],b=n[2*4+1],y=n[2*4+2],v=n[2*4+3],S=n[3*4+0],C=n[3*4+1],_=n[3*4+2],A=n[3*4+3];return n!==t&&(t[0]=o,t[1]=a,t[2]=l,t[3]=c,t[4]=h,t[5]=d,t[6]=p,t[7]=m,t[8]=g,t[9]=b,t[10]=y,t[11]=v),t[12]=o*s+h*r+g*i+S,t[13]=a*s+d*r+b*i+C,t[14]=l*s+p*r+y*i+_,t[15]=c*s+m*r+v*i+A,t}function rO(n,e){e=e||new Ln(16);const t=Math.cos(n),s=Math.sin(n);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t,e[6]=s,e[7]=0,e[8]=0,e[9]=-s,e[10]=t,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function iO(n,e,t){t=t||new Ln(16);const s=n[4],r=n[5],i=n[6],o=n[7],a=n[8],l=n[9],c=n[10],h=n[11],d=Math.cos(e),p=Math.sin(e);return t[4]=d*s+p*a,t[5]=d*r+p*l,t[6]=d*i+p*c,t[7]=d*o+p*h,t[8]=d*a-p*s,t[9]=d*l-p*r,t[10]=d*c-p*i,t[11]=d*h-p*o,n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t}function oO(n,e){e=e||new Ln(16);const t=Math.cos(n),s=Math.sin(n);return e[0]=t,e[1]=0,e[2]=-s,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=s,e[9]=0,e[10]=t,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function aO(n,e,t){t=t||new Ln(16);const s=n[0*4+0],r=n[0*4+1],i=n[0*4+2],o=n[0*4+3],a=n[2*4+0],l=n[2*4+1],c=n[2*4+2],h=n[2*4+3],d=Math.cos(e),p=Math.sin(e);return t[0]=d*s-p*a,t[1]=d*r-p*l,t[2]=d*i-p*c,t[3]=d*o-p*h,t[8]=d*a+p*s,t[9]=d*l+p*r,t[10]=d*c+p*i,t[11]=d*h+p*o,n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t}function lO(n,e){e=e||new Ln(16);const t=Math.cos(n),s=Math.sin(n);return e[0]=t,e[1]=s,e[2]=0,e[3]=0,e[4]=-s,e[5]=t,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function cO(n,e,t){t=t||new Ln(16);const s=n[0*4+0],r=n[0*4+1],i=n[0*4+2],o=n[0*4+3],a=n[1*4+0],l=n[1*4+1],c=n[1*4+2],h=n[1*4+3],d=Math.cos(e),p=Math.sin(e);return t[0]=d*s+p*a,t[1]=d*r+p*l,t[2]=d*i+p*c,t[3]=d*o+p*h,t[4]=d*a-p*s,t[5]=d*l-p*r,t[6]=d*c-p*i,t[7]=d*h-p*o,n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t}function uO(n,e,t){t=t||new Ln(16);let s=n[0],r=n[1],i=n[2];const o=Math.sqrt(s*s+r*r+i*i);s/=o,r/=o,i/=o;const a=s*s,l=r*r,c=i*i,h=Math.cos(e),d=Math.sin(e),p=1-h;return t[0]=a+(1-a)*h,t[1]=s*r*p+i*d,t[2]=s*i*p-r*d,t[3]=0,t[4]=s*r*p-i*d,t[5]=l+(1-l)*h,t[6]=r*i*p+s*d,t[7]=0,t[8]=s*i*p+r*d,t[9]=r*i*p-s*d,t[10]=c+(1-c)*h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function hO(n,e,t,s){s=s||new Ln(16);let r=e[0],i=e[1],o=e[2];const a=Math.sqrt(r*r+i*i+o*o);r/=a,i/=a,o/=a;const l=r*r,c=i*i,h=o*o,d=Math.cos(t),p=Math.sin(t),m=1-d,g=l+(1-l)*d,b=r*i*m+o*p,y=r*o*m-i*p,v=r*i*m-o*p,S=c+(1-c)*d,C=i*o*m+r*p,_=r*o*m+i*p,A=i*o*m-r*p,k=h+(1-h)*d,N=n[0],D=n[1],M=n[2],T=n[3],I=n[4],$=n[5],O=n[6],B=n[7],V=n[8],H=n[9],q=n[10],P=n[11];return s[0]=g*N+b*I+y*V,s[1]=g*D+b*$+y*H,s[2]=g*M+b*O+y*q,s[3]=g*T+b*B+y*P,s[4]=v*N+S*I+C*V,s[5]=v*D+S*$+C*H,s[6]=v*M+S*O+C*q,s[7]=v*T+S*B+C*P,s[8]=_*N+A*I+k*V,s[9]=_*D+A*$+k*H,s[10]=_*M+A*O+k*q,s[11]=_*T+A*B+k*P,n!==s&&(s[12]=n[12],s[13]=n[13],s[14]=n[14],s[15]=n[15]),s}function dO(n,e){return e=e||new Ln(16),e[0]=n[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=n[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function fO(n,e,t){t=t||new Ln(16);const s=e[0],r=e[1],i=e[2];return t[0]=s*n[0*4+0],t[1]=s*n[0*4+1],t[2]=s*n[0*4+2],t[3]=s*n[0*4+3],t[4]=r*n[1*4+0],t[5]=r*n[1*4+1],t[6]=r*n[1*4+2],t[7]=r*n[1*4+3],t[8]=i*n[2*4+0],t[9]=i*n[2*4+1],t[10]=i*n[2*4+2],t[11]=i*n[2*4+3],n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t}function pO(n,e,t){t=t||Na();const s=e[0],r=e[1],i=e[2],o=s*n[0*4+3]+r*n[1*4+3]+i*n[2*4+3]+n[3*4+3];return t[0]=(s*n[0*4+0]+r*n[1*4+0]+i*n[2*4+0]+n[3*4+0])/o,t[1]=(s*n[0*4+1]+r*n[1*4+1]+i*n[2*4+1]+n[3*4+1])/o,t[2]=(s*n[0*4+2]+r*n[1*4+2]+i*n[2*4+2]+n[3*4+2])/o,t}function mO(n,e,t){t=t||Na();const s=e[0],r=e[1],i=e[2];return t[0]=s*n[0*4+0]+r*n[1*4+0]+i*n[2*4+0],t[1]=s*n[0*4+1]+r*n[1*4+1]+i*n[2*4+1],t[2]=s*n[0*4+2]+r*n[1*4+2]+i*n[2*4+2],t}function gO(n,e,t){t=t||Na();const s=LA(n),r=e[0],i=e[1],o=e[2];return t[0]=r*s[0*4+0]+i*s[0*4+1]+o*s[0*4+2],t[1]=r*s[1*4+0]+i*s[1*4+1]+o*s[1*4+2],t[2]=r*s[2*4+0]+i*s[2*4+1]+o*s[2*4+2],t}var Dh=Object.freeze({__proto__:null,axisRotate:hO,axisRotation:uO,copy:$A,create:HP,frustum:eO,getAxis:YP,getTranslation:KP,identity:FA,inverse:LA,lookAt:tO,multiply:jP,negate:WP,ortho:JP,perspective:QP,rotateX:iO,rotateY:aO,rotateZ:cO,rotationX:rO,rotationY:oO,rotationZ:lO,scale:fO,scaling:dO,setAxis:ZP,setDefaultType:GP,setTranslation:qP,transformDirection:mO,transformNormal:gO,transformPoint:pO,translate:sO,translation:nO,transpose:XP});const zb=5120,td=5121,Bb=5122,Vb=5123,Gb=5124,Wb=5125,Hb=5126,xO=32819,vO=32820,yO=33635,bO=5131,SO=33640,wO=35899,_O=35902,CO=36269,EO=34042,PA={};{const n=PA;n[zb]=Int8Array,n[td]=Uint8Array,n[Bb]=Int16Array,n[Vb]=Uint16Array,n[Gb]=Int32Array,n[Wb]=Uint32Array,n[Hb]=Float32Array,n[xO]=Uint16Array,n[vO]=Uint16Array,n[yO]=Uint16Array,n[bO]=Uint16Array,n[SO]=Uint32Array,n[wO]=Uint32Array,n[_O]=Uint32Array,n[CO]=Uint32Array,n[EO]=Uint32Array}function OA(n){if(n instanceof Int8Array)return zb;if(n instanceof Uint8Array||n instanceof Uint8ClampedArray)return td;if(n instanceof Int16Array)return Bb;if(n instanceof Uint16Array)return Vb;if(n instanceof Int32Array)return Gb;if(n instanceof Uint32Array)return Wb;if(n instanceof Float32Array)return Hb;throw new Error("unsupported typed array type")}function UA(n){if(n===Int8Array)return zb;if(n===Uint8Array||n===Uint8ClampedArray)return td;if(n===Int16Array)return Bb;if(n===Uint16Array)return Vb;if(n===Int32Array)return Gb;if(n===Uint32Array)return Wb;if(n===Float32Array)return Hb;throw new Error("unsupported typed array type")}function TO(n){const e=PA[n];if(!e)throw new Error("unknown gl type");return e}const u1=typeof SharedArrayBuffer<"u"?function(e){return e&&e.buffer&&(e.buffer instanceof ArrayBuffer||e.buffer instanceof SharedArrayBuffer)}:function(e){return e&&e.buffer&&e.buffer instanceof ArrayBuffer};function IO(...n){console.error(...n)}const MT=new Map;function zA(n,e){if(!n||typeof n!="object")return!1;let t=MT.get(e);t||(t=new WeakMap,MT.set(e,t));let s=t.get(n);if(s===void 0){const r=Object.prototype.toString.call(n);s=r.substring(8,r.length-1)===e,t.set(n,s)}return s}function AO(n,e){return typeof WebGLBuffer<"u"&&zA(e,"WebGLBuffer")}function BA(n,e){return typeof WebGLTexture<"u"&&zA(e,"WebGLTexture")}const VA=35044,Ul=34962,MO=34963,RO=34660,kO=5120,NO=5121,DO=5122,$O=5123,FO=5124,LO=5125,GA=5126,WA={attribPrefix:""};function PO(n,e,t,s,r){n.bindBuffer(e,t),n.bufferData(e,s,r||VA)}function HA(n,e,t,s){if(AO(n,e))return e;t=t||Ul;const r=n.createBuffer();return PO(n,t,r,e,s),r}function XA(n){return n==="indices"}function OO(n){return n===Int8Array||n===Uint8Array}function UO(n){return n.length?n:n.data}const zO=/coord|texture/i,BO=/color|colour/i;function VO(n,e){let t;if(zO.test(n)?t=2:BO.test(n)?t=4:t=3,e%t>0)throw new Error(`Can not guess numComponents for attribute '${n}'. Tried ${t} but ${e} values is not evenly divisible by ${t}. You should specify it.`);return t}function GO(n,e,t){return n.numComponents||n.size||VO(e,t||UO(n).length)}function jA(n,e){if(u1(n))return n;if(u1(n.data))return n.data;Array.isArray(n)&&(n={data:n});let t=n.type?Xb(n.type):void 0;return t||(XA(e)?t=Uint16Array:t=Float32Array),new t(n.data)}function WO(n){return typeof n=="number"?n:n?UA(n):GA}function Xb(n){return typeof n=="number"?TO(n):n||Float32Array}function HO(n,e){return{buffer:e.buffer,numValues:2*3*4,type:WO(e.type),arrayType:Xb(e.type)}}function XO(n,e){const t=e.data||e,s=Xb(e.type),r=t*s.BYTES_PER_ELEMENT,i=n.createBuffer();return n.bindBuffer(Ul,i),n.bufferData(Ul,r,e.drawType||VA),{buffer:i,numValues:t,type:UA(s),arrayType:s}}function jO(n,e,t){const s=jA(e,t);return{arrayType:s.constructor,buffer:HA(n,s,void 0,e.drawType),type:OA(s),numValues:0}}function qO(n,e){const t={};return Object.keys(e).forEach(function(s){if(!XA(s)){const r=e[s],i=r.attrib||r.name||r.attribName||WA.attribPrefix+s;if(r.value){if(!Array.isArray(r.value)&&!u1(r.value))throw new Error("array.value is not array or typedarray");t[i]={value:r.value}}else{let o;r.buffer&&r.buffer instanceof WebGLBuffer?o=HO:typeof r=="number"||typeof r.data=="number"?o=XO:o=jO;const{buffer:a,type:l,numValues:c,arrayType:h}=o(n,r,s),d=r.normalize!==void 0?r.normalize:OO(h),p=GO(r,s,c);t[i]={buffer:a,numComponents:p,type:l,normalize:d,stride:r.stride||0,offset:r.offset||0,divisor:r.divisor===void 0?void 0:r.divisor,drawType:r.drawType}}}}),n.bindBuffer(Ul,null),t}function KO(n,e){return e===kO||e===NO?1:e===DO||e===$O?2:e===FO||e===LO||e===GA?4:0}const oy=["position","positions","a_position"];function YO(n,e){let t,s;for(s=0;s<oy.length&&(t=oy[s],!(t in e||(t=WA.attribPrefix+t,t in e)));++s);s===oy.length&&(t=Object.keys(e)[0]);const r=e[t];if(!r.buffer)return 1;n.bindBuffer(Ul,r.buffer);const i=n.getBufferParameter(Ul,RO);n.bindBuffer(Ul,null);const o=KO(n,r.type),a=i/o,l=r.numComponents||r.size,c=a/l;if(c%1!==0)throw new Error(`numComponents ${l} not correct for length ${length}`);return c}function ZO(n,e,t){const s=qO(n,e),r=Object.assign({},t||{});r.attribs=Object.assign({},t?t.attribs:{},s);const i=e.indices;if(i){const o=jA(i,"indices");r.indices=HA(n,o,MO),r.numElements=o.length,r.elementType=OA(o)}else r.numElements||(r.numElements=YO(n,r.attribs));return r}function jb(n){return!!n.texStorage2D}const QO=function(){const n={},e={};function t(s){const r=s.constructor.name;if(!n[r]){for(const i in s)if(typeof s[i]=="number"){const o=e[s[i]];e[s[i]]=o?`${o} | ${i}`:i}n[r]=!0}}return function(r,i){return t(r),e[i]||(typeof i=="number"?`0x${i.toString(16)}`:i)}}(),qb=IO;function qA(n){return typeof document<"u"&&document.getElementById?document.getElementById(n):null}const sg=33984,Og=34962,JO=34963,eU=35713,tU=35714,nU=35632,sU=35633,rU=35981,KA=35718,iU=35721,oU=35971,aU=35382,lU=35396,cU=35398,uU=35392,hU=35395,Ug=5126,YA=35664,ZA=35665,QA=35666,Kb=5124,JA=35667,eM=35668,tM=35669,nM=35670,sM=35671,rM=35672,iM=35673,oM=35674,aM=35675,lM=35676,dU=35678,fU=35680,pU=35679,mU=35682,gU=35685,xU=35686,vU=35687,yU=35688,bU=35689,SU=35690,wU=36289,_U=36292,CU=36293,Yb=5125,cM=36294,uM=36295,hM=36296,EU=36298,TU=36299,IU=36300,AU=36303,MU=36306,RU=36307,kU=36308,NU=36311,zg=3553,Bg=34067,Zb=32879,Vg=35866,zt={};function dM(n,e){return zt[e].bindPoint}function DU(n,e){return function(t){n.uniform1f(e,t)}}function $U(n,e){return function(t){n.uniform1fv(e,t)}}function FU(n,e){return function(t){n.uniform2fv(e,t)}}function LU(n,e){return function(t){n.uniform3fv(e,t)}}function PU(n,e){return function(t){n.uniform4fv(e,t)}}function fM(n,e){return function(t){n.uniform1i(e,t)}}function pM(n,e){return function(t){n.uniform1iv(e,t)}}function mM(n,e){return function(t){n.uniform2iv(e,t)}}function gM(n,e){return function(t){n.uniform3iv(e,t)}}function xM(n,e){return function(t){n.uniform4iv(e,t)}}function OU(n,e){return function(t){n.uniform1ui(e,t)}}function UU(n,e){return function(t){n.uniform1uiv(e,t)}}function zU(n,e){return function(t){n.uniform2uiv(e,t)}}function BU(n,e){return function(t){n.uniform3uiv(e,t)}}function VU(n,e){return function(t){n.uniform4uiv(e,t)}}function GU(n,e){return function(t){n.uniformMatrix2fv(e,!1,t)}}function WU(n,e){return function(t){n.uniformMatrix3fv(e,!1,t)}}function HU(n,e){return function(t){n.uniformMatrix4fv(e,!1,t)}}function XU(n,e){return function(t){n.uniformMatrix2x3fv(e,!1,t)}}function jU(n,e){return function(t){n.uniformMatrix3x2fv(e,!1,t)}}function qU(n,e){return function(t){n.uniformMatrix2x4fv(e,!1,t)}}function KU(n,e){return function(t){n.uniformMatrix4x2fv(e,!1,t)}}function YU(n,e){return function(t){n.uniformMatrix3x4fv(e,!1,t)}}function ZU(n,e){return function(t){n.uniformMatrix4x3fv(e,!1,t)}}function br(n,e,t,s){const r=dM(n,e);return jb(n)?function(i){let o,a;!i||BA(n,i)?(o=i,a=null):(o=i.texture,a=i.sampler),n.uniform1i(s,t),n.activeTexture(sg+t),n.bindTexture(r,o),n.bindSampler(t,a)}:function(i){n.uniform1i(s,t),n.activeTexture(sg+t),n.bindTexture(r,i)}}function Sr(n,e,t,s,r){const i=dM(n,e),o=new Int32Array(r);for(let a=0;a<r;++a)o[a]=t+a;return jb(n)?function(a){n.uniform1iv(s,o),a.forEach(function(l,c){n.activeTexture(sg+o[c]);let h,d;!l||BA(n,l)?(h=l,d=null):(h=l.texture,d=l.sampler),n.bindSampler(t,d),n.bindTexture(i,h)})}:function(a){n.uniform1iv(s,o),a.forEach(function(l,c){n.activeTexture(sg+o[c]),n.bindTexture(i,l)})}}zt[Ug]={Type:Float32Array,size:4,setter:DU,arraySetter:$U};zt[YA]={Type:Float32Array,size:8,setter:FU,cols:2};zt[ZA]={Type:Float32Array,size:12,setter:LU,cols:3};zt[QA]={Type:Float32Array,size:16,setter:PU,cols:4};zt[Kb]={Type:Int32Array,size:4,setter:fM,arraySetter:pM};zt[JA]={Type:Int32Array,size:8,setter:mM,cols:2};zt[eM]={Type:Int32Array,size:12,setter:gM,cols:3};zt[tM]={Type:Int32Array,size:16,setter:xM,cols:4};zt[Yb]={Type:Uint32Array,size:4,setter:OU,arraySetter:UU};zt[cM]={Type:Uint32Array,size:8,setter:zU,cols:2};zt[uM]={Type:Uint32Array,size:12,setter:BU,cols:3};zt[hM]={Type:Uint32Array,size:16,setter:VU,cols:4};zt[nM]={Type:Uint32Array,size:4,setter:fM,arraySetter:pM};zt[sM]={Type:Uint32Array,size:8,setter:mM,cols:2};zt[rM]={Type:Uint32Array,size:12,setter:gM,cols:3};zt[iM]={Type:Uint32Array,size:16,setter:xM,cols:4};zt[oM]={Type:Float32Array,size:32,setter:GU,rows:2,cols:2};zt[aM]={Type:Float32Array,size:48,setter:WU,rows:3,cols:3};zt[lM]={Type:Float32Array,size:64,setter:HU,rows:4,cols:4};zt[gU]={Type:Float32Array,size:32,setter:XU,rows:2,cols:3};zt[xU]={Type:Float32Array,size:32,setter:qU,rows:2,cols:4};zt[vU]={Type:Float32Array,size:48,setter:jU,rows:3,cols:2};zt[yU]={Type:Float32Array,size:48,setter:YU,rows:3,cols:4};zt[bU]={Type:Float32Array,size:64,setter:KU,rows:4,cols:2};zt[SU]={Type:Float32Array,size:64,setter:ZU,rows:4,cols:3};zt[dU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:zg};zt[fU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Bg};zt[pU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Zb};zt[mU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:zg};zt[wU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Vg};zt[_U]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Vg};zt[CU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Bg};zt[EU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:zg};zt[TU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Zb};zt[IU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Bg};zt[AU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Vg};zt[MU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:zg};zt[RU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Zb};zt[kU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Bg};zt[NU]={Type:null,size:0,setter:br,arraySetter:Sr,bindPoint:Vg};function Gg(n,e){return function(t){if(t.value)switch(n.disableVertexAttribArray(e),t.value.length){case 4:n.vertexAttrib4fv(e,t.value);break;case 3:n.vertexAttrib3fv(e,t.value);break;case 2:n.vertexAttrib2fv(e,t.value);break;case 1:n.vertexAttrib1fv(e,t.value);break;default:throw new Error("the length of a float constant value must be between 1 and 4!")}else n.bindBuffer(Og,t.buffer),n.enableVertexAttribArray(e),n.vertexAttribPointer(e,t.numComponents||t.size,t.type||Ug,t.normalize||!1,t.stride||0,t.offset||0),n.vertexAttribDivisor&&n.vertexAttribDivisor(e,t.divisor||0)}}function ja(n,e){return function(t){if(t.value)if(n.disableVertexAttribArray(e),t.value.length===4)n.vertexAttrib4iv(e,t.value);else throw new Error("The length of an integer constant value must be 4!");else n.bindBuffer(Og,t.buffer),n.enableVertexAttribArray(e),n.vertexAttribIPointer(e,t.numComponents||t.size,t.type||Kb,t.stride||0,t.offset||0),n.vertexAttribDivisor&&n.vertexAttribDivisor(e,t.divisor||0)}}function Wg(n,e){return function(t){if(t.value)if(n.disableVertexAttribArray(e),t.value.length===4)n.vertexAttrib4uiv(e,t.value);else throw new Error("The length of an unsigned integer constant value must be 4!");else n.bindBuffer(Og,t.buffer),n.enableVertexAttribArray(e),n.vertexAttribIPointer(e,t.numComponents||t.size,t.type||Yb,t.stride||0,t.offset||0),n.vertexAttribDivisor&&n.vertexAttribDivisor(e,t.divisor||0)}}function Qb(n,e,t){const s=t.size,r=t.count;return function(i){n.bindBuffer(Og,i.buffer);const o=i.size||i.numComponents||s,a=o/r,l=i.type||Ug,h=zt[l].size*o,d=i.normalize||!1,p=i.offset||0,m=h/r;for(let g=0;g<r;++g)n.enableVertexAttribArray(e+g),n.vertexAttribPointer(e+g,a,l,d,h,p+m*g),n.vertexAttribDivisor&&n.vertexAttribDivisor(e+g,i.divisor||0)}}const ps={};ps[Ug]={size:4,setter:Gg};ps[YA]={size:8,setter:Gg};ps[ZA]={size:12,setter:Gg};ps[QA]={size:16,setter:Gg};ps[Kb]={size:4,setter:ja};ps[JA]={size:8,setter:ja};ps[eM]={size:12,setter:ja};ps[tM]={size:16,setter:ja};ps[Yb]={size:4,setter:Wg};ps[cM]={size:8,setter:Wg};ps[uM]={size:12,setter:Wg};ps[hM]={size:16,setter:Wg};ps[nM]={size:4,setter:ja};ps[sM]={size:8,setter:ja};ps[rM]={size:12,setter:ja};ps[iM]={size:16,setter:ja};ps[oM]={size:4,setter:Qb,count:2};ps[aM]={size:9,setter:Qb,count:3};ps[lM]={size:16,setter:Qb,count:4};const QU=/ERROR:\s*\d+:(\d+)/gi;function JU(n,e="",t=0){const s=[...e.matchAll(QU)],r=new Map(s.map((i,o)=>{const a=parseInt(i[1]),l=s[o+1],c=l?l.index:e.length,h=e.substring(i.index,c);return[a-1,h]}));return n.split(`
`).map((i,o)=>{const a=r.get(o);return`${o+1+t}: ${i}${a?`

^^^ ${a}`:""}`}).join(`
`)}const RT=/^[ \t]*\n/;function vM(n){let e=0;return RT.test(n)&&(e=1,n=n.replace(RT,"")),{lineOffset:e,shaderSource:n}}function ez(n,e){return n.errorCallback(e),n.callback&&setTimeout(()=>{n.callback(`${e}
${n.errors.join(`
`)}`)}),null}function tz(n,e,t,s){if(s=s||qb,!n.getShaderParameter(t,eU)){const i=n.getShaderInfoLog(t),{lineOffset:o,shaderSource:a}=vM(n.getShaderSource(t)),l=`${JU(a,i,o)}
Error compiling ${QO(n,e)}: ${i}`;return s(l),l}return""}function Jb(n,e,t){let s,r,i;if(typeof e=="function"&&(t=e,e=void 0),typeof n=="function")t=n,n=void 0;else if(n&&!Array.isArray(n)){const c=n;t=c.errorCallback,n=c.attribLocations,s=c.transformFeedbackVaryings,r=c.transformFeedbackMode,i=c.callback}const o=t||qb,a=[],l={errorCallback(c,...h){a.push(c),o(c,...h)},transformFeedbackVaryings:s,transformFeedbackMode:r,callback:i,errors:a};{let c={};Array.isArray(n)?n.forEach(function(h,d){c[h]=e?e[d]:d}):c=n||{},l.attribLocations=c}return l}const nz=["VERTEX_SHADER","FRAGMENT_SHADER"];function sz(n,e){if(e.indexOf("frag")>=0)return nU;if(e.indexOf("vert")>=0)return sU}function rz(n,e,t){const s=n.getAttachedShaders(e);for(const r of s)t.has(r)&&n.deleteShader(r);n.deleteProgram(e)}const iz=(n=0)=>new Promise(e=>setTimeout(e,n));function oz(n,e,t){const s=n.createProgram(),{attribLocations:r,transformFeedbackVaryings:i,transformFeedbackMode:o}=Jb(t);for(let a=0;a<e.length;++a){let l=e[a];if(typeof l=="string"){const c=qA(l),h=c?c.text:l;let d=n[nz[a]];c&&c.type&&(d=sz(n,c.type)||d),l=n.createShader(d),n.shaderSource(l,vM(h).shaderSource),n.compileShader(l),n.attachShader(s,l)}}Object.entries(r).forEach(([a,l])=>n.bindAttribLocation(s,l,a));{let a=i;a&&(a.attribs&&(a=a.attribs),Array.isArray(a)||(a=Object.keys(a)),n.transformFeedbackVaryings(s,a,o||rU))}return n.linkProgram(s),s}function az(n,e,t,s,r){const i=Jb(t,s,r),o=new Set(e),a=oz(n,e,i);function l(c,h){const d=cz(c,h,i.errorCallback);return d&&rz(c,h,o),d}if(i.callback){lz(n,a).then(()=>{const c=l(n,a);i.callback(c,c?void 0:a)});return}return l(n,a)?void 0:a}async function lz(n,e){const t=n.getExtension("KHR_parallel_shader_compile"),s=t?(i,o)=>i.getProgramParameter(o,t.COMPLETION_STATUS_KHR):()=>!0;let r=0;do await iz(r),r=1e3/60;while(!s(n,e))}function cz(n,e,t){if(t=t||qb,!n.getProgramParameter(e,tU)){const r=n.getProgramInfoLog(e);t(`Error in program linking: ${r}`);const o=n.getAttachedShaders(e).map(a=>tz(n,n.getShaderParameter(a,n.SHADER_TYPE),a,t));return`${r}
${o.filter(a=>a).join(`
`)}`}}function uz(n,e,t,s,r){return az(n,e,t,s,r)}function yM(n){const e=n.name;return e.startsWith("gl_")||e.startsWith("webgl_")}const hz=/(\.|\[|]|\w+)/g,dz=n=>n>="0"&&n<="9";function fz(n,e,t,s){const r=n.split(hz).filter(a=>a!=="");let i=0,o="";for(;;){const a=r[i++];o+=a;const l=dz(a[0]),c=l?parseInt(a):a;if(l&&(o+=r[i++]),i===r.length){t[c]=e;break}else{const d=r[i++],p=d==="[",m=t[c]||(p?[]:{});t[c]=m,t=m,s[o]=s[o]||function(g){return function(b){bM(g,b)}}(m),o+=d}}}function pz(n,e){let t=0;function s(a,l,c){const h=l.name.endsWith("[0]"),d=l.type,p=zt[d];if(!p)throw new Error(`unknown type: 0x${d.toString(16)}`);let m;if(p.bindPoint){const g=t;t+=l.size,h?m=p.arraySetter(n,d,g,c,l.size):m=p.setter(n,d,g,c,l.size)}else p.arraySetter&&h?m=p.arraySetter(n,c):m=p.setter(n,c);return m.location=c,m}const r={},i={},o=n.getProgramParameter(e,KA);for(let a=0;a<o;++a){const l=n.getActiveUniform(e,a);if(yM(l))continue;let c=l.name;c.endsWith("[0]")&&(c=c.substr(0,c.length-3));const h=n.getUniformLocation(e,l.name);if(h){const d=s(e,l,h);r[c]=d,fz(c,d,i,r)}}return r}function mz(n,e){const t={},s=n.getProgramParameter(e,oU);for(let r=0;r<s;++r){const i=n.getTransformFeedbackVarying(e,r);t[i.name]={index:r,type:i.type,size:i.size}}return t}function gz(n,e){const t=n.getProgramParameter(e,KA),s=[],r=[];for(let a=0;a<t;++a){r.push(a),s.push({});const l=n.getActiveUniform(e,a);s[a].name=l.name}[["UNIFORM_TYPE","type"],["UNIFORM_SIZE","size"],["UNIFORM_BLOCK_INDEX","blockNdx"],["UNIFORM_OFFSET","offset"]].forEach(function(a){const l=a[0],c=a[1];n.getActiveUniforms(e,r,n[l]).forEach(function(h,d){s[d][c]=h})});const i={},o=n.getProgramParameter(e,aU);for(let a=0;a<o;++a){const l=n.getActiveUniformBlockName(e,a),c={index:n.getUniformBlockIndex(e,l),usedByVertexShader:n.getActiveUniformBlockParameter(e,a,lU),usedByFragmentShader:n.getActiveUniformBlockParameter(e,a,cU),size:n.getActiveUniformBlockParameter(e,a,uU),uniformIndices:n.getActiveUniformBlockParameter(e,a,hU)};c.used=c.usedByVertexShader||c.usedByFragmentShader,i[l]=c}return{blockSpecs:i,uniformData:s}}function bM(n,e){for(const t in e){const s=n[t];typeof s=="function"?s(e[t]):bM(n[t],e[t])}}function SM(n,...e){const t=n.uniformSetters||n,s=e.length;for(let r=0;r<s;++r){const i=e[r];if(Array.isArray(i)){const o=i.length;for(let a=0;a<o;++a)SM(t,i[a])}else for(const o in i){const a=t[o];a&&a(i[o])}}}function xz(n,e){const t={},s=n.getProgramParameter(e,iU);for(let r=0;r<s;++r){const i=n.getActiveAttrib(e,r);if(yM(i))continue;const o=n.getAttribLocation(e,i.name),a=ps[i.type],l=a.setter(n,o,a);l.location=o,t[i.name]=l}return t}function vz(n,e){for(const t in e){const s=n[t];s&&s(e[t])}}function yz(n,e,t){t.vertexArrayObject?n.bindVertexArray(t.vertexArrayObject):(vz(e.attribSetters||e,t.attribs),t.indices&&n.bindBuffer(JO,t.indices))}function kT(n,e){const t=pz(n,e),s=xz(n,e),r={program:e,uniformSetters:t,attribSetters:s};return jb(n)&&(r.uniformBlockSpec=gz(n,e),r.transformFeedbackInfo=mz(n,e)),r}const bz=/\s|{|}|;/;function Sz(n,e,t,s,r){const i=Jb(t,s,r),o=[];if(e=e.map(function(c){if(!bz.test(c)){const h=qA(c);if(h)c=h.text;else{const d=`no element with id: ${c}`;i.errorCallback(d),o.push(d)}}return c}),o.length)return ez(i,"");const a=i.callback;a&&(i.callback=(c,h)=>{a(c,c?void 0:kT(n,h))});const l=uz(n,e,i);return l?kT(n,l):null}const wz=4,NT=5123;function _z(n,e,t,s,r,i){t=t===void 0?wz:t;const o=e.indices,a=e.elementType,l=s===void 0?e.numElements:s;r=r===void 0?0:r,a||o?i!==void 0?n.drawElementsInstanced(t,l,a===void 0?NT:e.elementType,r,i):n.drawElements(t,l,a===void 0?NT:e.elementType,r):i!==void 0?n.drawArraysInstanced(t,r,l,i):n.drawArrays(t,r,l)}function Cz(n,e){e=e||1,e=Math.max(0,e);const t=n.clientWidth*e|0,s=n.clientHeight*e|0;return n.width!==t||n.height!==s?(n.width=t,n.height=s,!0):!1}const Ez=`
  attribute vec2 a_position;
  uniform mat4 u_matrix;
  void main() {
    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);
  }
`,Tz=`
  precision mediump float;
  uniform vec4 u_color;
  void main() {
    gl_FragColor = u_color;
  }
`,Iz=[0,0,0,1],Az=[1,1,1,1],Mz=[.5,.5,.5,1],Rz=({width:n=500,height:e=500,currentGrid:t,onCellToggle:s})=>{const r=Ae.useRef(null),i=Ae.useRef(null),o=Ae.useRef(null),a=Ae.useRef(null),[l,c]=Ae.useState(""),[h,d]=Ae.useState(!1),p=Ae.useRef({r:-1,c:-1});console.log("[View] Automaton2DView rendering/re-rendering. Instance created or updated.");const m=Ae.useCallback(C=>{if(!r.current||!t||t.length===0||!i.current)return null;const _=r.current.getBoundingClientRect(),A=C.clientX-_.left,k=C.clientY-_.top,N=i.current,D=t.length,M=t[0].length,T=N.canvas.width/M,I=N.canvas.height/D,$=Math.floor(A/T),O=Math.floor(k/I);return O>=0&&O<D&&$>=0&&$<M?{rowIndex:O,colIndex:$}:null},[t]),g=Ae.useCallback(C=>{console.log("[View] handleMouseDown: FIRED"),d(!0);const _=m(C);console.log("[View] handleMouseDown: cell from getCellFromMouseEvent",_),_&&s&&(s(_.rowIndex,_.colIndex),p.current={r:_.rowIndex,c:_.colIndex},console.log("[View] handleMouseDown: onCellToggle called with",_.rowIndex,_.colIndex))},[s,m]),b=Ae.useCallback(C=>{if(console.log("[View] handleMouseMove: dragging?",h),!h)return;const _=m(C);console.log("[View] handleMouseMove: cell",_),_&&s&&(_.rowIndex!==p.current.r||_.colIndex!==p.current.c)&&(s(_.rowIndex,_.colIndex),p.current={r:_.rowIndex,c:_.colIndex},console.log("[View] handleMouseMove: onCellToggle called with",_.rowIndex,_.colIndex))},[h,s,m]),y=Ae.useCallback(()=>{d(!1),p.current={r:-1,c:-1}},[]),v=Ae.useCallback(()=>{d(!1),p.current={r:-1,c:-1}},[]),S=Ae.useCallback(()=>{const C=i.current,_=o.current,A=a.current;if(!C||!_||!A||!t||t.length===0){console.log("[View] drawGrid: Bailing or clearing - missing GL resources or invalid grid.",{glExists:!!C,programInfoExists:!!_,quadBufferInfoExists:!!A,currentGridValid:!!(t&&t.length>0)}),C&&(C.clearColor(.95,.95,.95,1),C.clear(C.COLOR_BUFFER_BIT));return}const k=t.length,N=t[0].length;if(k===0||N===0){C&&(C.clearColor(.95,.95,.95,1),C.clear(C.COLOR_BUFFER_BIT));return}if(Cz(C.canvas),C.viewport(0,0,C.canvas.width,C.canvas.height),C.clearColor(.95,.95,.95,1),C.clear(C.COLOR_BUFFER_BIT),C.useProgram(_.program),yz(C,_,A),r.current){const I=r.current.getBoundingClientRect();(C.canvas.width!==I.width||C.canvas.height!==I.height)&&(C.canvas.width=I.width,C.canvas.height=I.height,C.viewport(0,0,C.canvas.width,C.canvas.height))}const D=C.canvas.width/N,M=C.canvas.height/k,T=Dh.ortho(0,C.canvas.width,C.canvas.height,0,-1,1);for(let I=0;I<k;I++)for(let $=0;$<N;$++){const O=Dh.identity();Dh.translate(O,[$*D,I*M,0],O),Dh.scale(O,[D,M,1],O);const B=Dh.multiply(T,O);let V;t[I][$]===1?V=Iz:t[I][$]===2?V=Mz:V=Az,SM(_,{u_matrix:B,u_color:V}),_z(C,A)}},[t]);return Ae.useEffect(()=>{console.log("[View] GL Resource Management Effect: Running setup phase.");const C=r.current;if(!C){console.error("[View] GL Setup: Canvas ref not available.");return}const _=C.getContext("webgl2");if(!_){c("WebGL2 is not available. Please use a compatible browser."),console.error("[View] GL Setup: Failed to get WebGL2 context.");return}i.current=_,console.log("[View] GL Setup: WebGL2 context obtained.");const A=Sz(_,[Ez,Tz]);if(!A||!A.program){c("Failed to compile/link shader program.");const D=_.getProgramInfoLog(A&&A.program);console.error("[View] GL Setup: Shader program creation failed.",D),i.current=null;return}o.current=A,console.log("[View] GL Setup: Shader program created.");const N=ZO(_,{a_position:{numComponents:2,data:[0,0,1,0,0,1,0,1,1,0,1,1]}});return a.current=N,console.log("[View] GL Setup: Quad buffer created."),c(""),()=>{var M,T;console.log("[View] GL Resource Management Effect: Running cleanup phase.");const D=i.current;D&&(o.current&&o.current.program&&(D.deleteProgram(o.current.program),console.log("[View] Cleanup: Program deleted.")),a.current&&((T=(M=a.current.attribs)==null?void 0:M.a_position)!=null&&T.buffer&&(D.deleteBuffer(a.current.attribs.a_position.buffer),console.log("[View] Cleanup: Vertex buffer deleted.")),a.current.indices&&(D.deleteBuffer(a.current.indices),console.log("[View] Cleanup: Index buffer deleted (if existed).")))),o.current=null,a.current=null,i.current=null,console.log("[View] Cleanup: GL Refs (glRef, programInfoRef, quadBufferInfoRef) nullified.")}},[]),Ae.useEffect(()=>{console.log("[View] Drawing Effect triggered. Checking conditions to draw."),i.current&&o.current&&a.current&&t&&t.length>0?(console.log("[View] Drawing Effect: All resources ready, calling drawGrid."),S()):(console.log("[View] Drawing Effect: Not drawing - GL resources or currentGrid not ready/valid."),i.current&&(console.log("[View] Drawing Effect: Clearing canvas due to incomplete setup or invalid grid."),i.current.clearColor(.95,.95,.95,1),i.current.clear(i.current.COLOR_BUFFER_BIT)))},[t]),Ae.useEffect(()=>{const C=()=>{console.log("[View] Resize handler triggered."),i.current&&o.current&&a.current&&t&&t.length>0?(console.log("[View] Resize handler: All resources ready, calling drawGrid."),S()):console.log("[View] Resize handler: Not redrawing - GL resources or currentGrid not ready/valid.")};return window.addEventListener("resize",C),i.current&&o.current&&a.current&&t&&t.length>0&&(console.log("[View] Initial resize setup: Calling handleResize for initial sizing."),C()),()=>window.removeEventListener("resize",C)},[S,t]),l?pe.jsx("div",{style:{width:n,height:e,border:"1px solid red",padding:"10px",color:"red"},children:pe.jsxs("p",{children:["Error: ",l]})}):pe.jsx("div",{children:pe.jsx("canvas",{ref:r,width:n,height:e,style:{border:"1px solid #000",display:"block",cursor:"pointer",width:`${n}px`,height:`${e}px`},onMouseDown:g,onMouseMove:b,onMouseUp:y,onMouseLeave:v})})},kz={conway:"Conway's Game of Life (B3/S23)",highlife:"High Life (B36/S23)",daynight:"Day & Night (B3678/S34678)",seeds:"Seeds (B2/S)",maze:"Maze (B3/S12345)",lifewithoutdeath:"Life Without Death (B3/S012345678)",replicator:"Replicator (B1357/S1357)","2x2":"2x2 (B36/S125)",briansbrain:"Brian's Brain (3-state)"},Nz=({onStart:n,onPause:e,onReset:t,isRunning:s,currentRule:r="conway",onRuleChange:i,simulationSpeed:o=200,onSpeedChange:a})=>{const l={controlsContainer:{display:"flex",alignItems:"center",gap:"10px",padding:"10px",marginBottom:"20px",flexWrap:"wrap",justifyContent:"center"},button:{padding:"8px 15px",border:"none",borderRadius:"4px",cursor:"pointer",backgroundColor:"#28a745",color:"white"},buttonDisabled:{backgroundColor:"#6c757d"},ruleText:{fontSize:"1em",color:"#333",fontWeight:"bold"},select:{padding:"8px 15px",borderRadius:"4px",marginLeft:"10px"},controlGroup:{display:"flex",alignItems:"center",gap:"10px",marginLeft:"10px"},slider:{width:"100px"},sliderLabel:{fontSize:"0.9em",color:"#333",minWidth:"100px",textAlign:"right"}},c=d=>{i&&i(d.target.value)},h=d=>{const p=parseInt(d.target.value,10);a&&a(p)};return pe.jsxs("div",{style:l.controlsContainer,children:[pe.jsx("button",{onClick:n,disabled:s,style:{...l.button,...s&&l.buttonDisabled},children:"Start"}),pe.jsx("button",{onClick:e,disabled:!s,style:{...l.button,...!s&&l.buttonDisabled},children:"Pause"}),pe.jsx("button",{onClick:t,style:l.button,children:"Reset"}),pe.jsxs("div",{children:[pe.jsx("label",{style:l.ruleText,children:"Rule:"}),pe.jsx("select",{value:r,onChange:c,style:l.select,disabled:s,children:Object.entries(kz).map(([d,p])=>pe.jsx("option",{value:d,children:p},d))})]}),pe.jsxs("div",{style:l.controlGroup,children:[pe.jsx("label",{style:l.sliderLabel,children:"Speed:"}),pe.jsx("input",{type:"range",min:"50",max:"1000",step:"50",value:o,onChange:h,style:l.slider}),pe.jsxs("span",{style:{marginLeft:"5px",fontSize:"0.9em"},children:[o,"ms"]})]})]})},DT={conway:{birth:[3],survival:[2,3]},highlife:{birth:[3,6],survival:[2,3]},daynight:{birth:[3,6,7,8],survival:[3,4,6,7,8]},seeds:{birth:[2],survival:[]},maze:{birth:[3],survival:[1,2,3,4,5]},lifewithoutdeath:{birth:[3],survival:[0,1,2,3,4,5,6,7,8]},replicator:{birth:[1,3,5,7],survival:[1,3,5,7]},"2x2":{birth:[3,6],survival:[1,2,5]},briansbrain:{type:"special"}},Dz=(n,e,t)=>{let s=0;const r=n.length,i=n[0].length;for(let o=-1;o<=1;o++)for(let a=-1;a<=1;a++){if(o===0&&a===0)continue;const l=(e+o+r)%r,c=(t+a+i)%i;n[l][c]===1&&s++}return s},$z=n=>{const e=n.length,t=n[0].length,s=Array(e).fill(null).map(()=>Array(t).fill(0));for(let r=0;r<e;r++)for(let i=0;i<t;i++){const o=n[r][i];if(o===0){let a=0;for(let l=-1;l<=1;l++)for(let c=-1;c<=1;c++){if(l===0&&c===0)continue;const h=(r+l+e)%e,d=(i+c+t)%t;n[h][d]===1&&a++}s[r][i]=a===2?1:0}else o===1?s[r][i]=2:o===2&&(s[r][i]=0)}return s},Fz=(n,e="conway")=>{if(!n||n.length===0||!n[0]||n[0].length===0)return console.warn("[automataLogic2D] Invalid or empty grid provided."),[];if(e==="briansbrain")return $z(n);const t=DT[e]||DT.conway,{birth:s,survival:r}=t,i=n.length,o=n[0].length,a=Array(i).fill(null).map(()=>Array(o).fill(0));for(let l=0;l<i;l++)for(let c=0;c<o;c++){const h=Dz(n,l,c);n[l][c]===1?a[l][c]=r.includes(h)?1:0:a[l][c]=s.includes(h)?1:0}return a};/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const eS="176",Lz=0,$T=1,Pz=2,wM=1,tS=2,Lo=3,Ua=0,sr=1,Oo=2,Da=0,cu=1,FT=2,LT=3,PT=4,Oz=5,Rl=100,Uz=101,zz=102,Bz=103,Vz=104,Gz=200,Wz=201,Hz=202,Xz=203,h1=204,d1=205,jz=206,qz=207,Kz=208,Yz=209,Zz=210,Qz=211,Jz=212,eB=213,tB=214,f1=0,p1=1,m1=2,gu=3,g1=4,x1=5,v1=6,y1=7,_M=0,nB=1,sB=2,$a=0,rB=1,iB=2,oB=3,aB=4,lB=5,cB=6,uB=7,CM=300,xu=301,vu=302,b1=303,S1=304,Hg=306,Gl=1e3,Fl=1001,w1=1002,mr=1003,hB=1004,Qp=1005,io=1006,ay=1007,Ll=1008,Ui=1009,EM=1010,TM=1011,nd=1012,nS=1013,Wl=1014,oo=1015,wd=1016,sS=1017,rS=1018,sd=1020,IM=35902,AM=1021,MM=1022,Hr=1023,rd=1026,id=1027,iS=1028,oS=1029,RM=1030,aS=1031,lS=1033,Bm=33776,Vm=33777,Gm=33778,Wm=33779,_1=35840,C1=35841,E1=35842,T1=35843,I1=36196,A1=37492,M1=37496,R1=37808,k1=37809,N1=37810,D1=37811,$1=37812,F1=37813,L1=37814,P1=37815,O1=37816,U1=37817,z1=37818,B1=37819,V1=37820,G1=37821,Hm=36492,W1=36494,H1=36495,kM=36283,X1=36284,j1=36285,q1=36286,dB=3200,fB=3201,NM=0,pB=1,Aa="",ci="srgb",yu="srgb-linear",rg="linear",wn="srgb",Bc=7680,OT=519,mB=512,gB=513,xB=514,DM=515,vB=516,yB=517,bB=518,SB=519,UT=35044,zT="300 es",zo=2e3,ig=2001;class Nu{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){const s=this._listeners;return s===void 0?!1:s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){const s=this._listeners;if(s===void 0)return;const r=s[e];if(r!==void 0){const i=r.indexOf(t);i!==-1&&r.splice(i,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const s=t[e.type];if(s!==void 0){e.target=this;const r=s.slice(0);for(let i=0,o=r.length;i<o;i++)r[i].call(this,e);e.target=null}}}const Zs=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],ly=Math.PI/180,K1=180/Math.PI;function _d(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(Zs[n&255]+Zs[n>>8&255]+Zs[n>>16&255]+Zs[n>>24&255]+"-"+Zs[e&255]+Zs[e>>8&255]+"-"+Zs[e>>16&15|64]+Zs[e>>24&255]+"-"+Zs[t&63|128]+Zs[t>>8&255]+"-"+Zs[t>>16&255]+Zs[t>>24&255]+Zs[s&255]+Zs[s>>8&255]+Zs[s>>16&255]+Zs[s>>24&255]).toLowerCase()}function Jt(n,e,t){return Math.max(e,Math.min(t,n))}function wB(n,e){return(n%e+e)%e}function cy(n,e,t){return(1-t)*n+t*e}function $h(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Mr(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}class gn{constructor(e=0,t=0){gn.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6],this.y=r[1]*t+r[4]*s+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Jt(this.x,e.x,t.x),this.y=Jt(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=Jt(this.x,e,t),this.y=Jt(this.y,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Jt(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Jt(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),r=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*s-o*r+e.x,this.y=i*r+o*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Ht{constructor(e,t,s,r,i,o,a,l,c){Ht.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,s,r,i,o,a,l,c)}set(e,t,s,r,i,o,a,l,c){const h=this.elements;return h[0]=e,h[1]=r,h[2]=a,h[3]=t,h[4]=i,h[5]=l,h[6]=s,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,i=this.elements,o=s[0],a=s[3],l=s[6],c=s[1],h=s[4],d=s[7],p=s[2],m=s[5],g=s[8],b=r[0],y=r[3],v=r[6],S=r[1],C=r[4],_=r[7],A=r[2],k=r[5],N=r[8];return i[0]=o*b+a*S+l*A,i[3]=o*y+a*C+l*k,i[6]=o*v+a*_+l*N,i[1]=c*b+h*S+d*A,i[4]=c*y+h*C+d*k,i[7]=c*v+h*_+d*N,i[2]=p*b+m*S+g*A,i[5]=p*y+m*C+g*k,i[8]=p*v+m*_+g*N,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8];return t*o*h-t*a*c-s*i*h+s*a*l+r*i*c-r*o*l}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],d=h*o-a*c,p=a*l-h*i,m=c*i-o*l,g=t*d+s*p+r*m;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/g;return e[0]=d*b,e[1]=(r*c-h*s)*b,e[2]=(a*s-r*o)*b,e[3]=p*b,e[4]=(h*t-r*l)*b,e[5]=(r*i-a*t)*b,e[6]=m*b,e[7]=(s*l-c*t)*b,e[8]=(o*t-s*i)*b,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,r,i,o,a){const l=Math.cos(i),c=Math.sin(i);return this.set(s*l,s*c,-s*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(uy.makeScale(e,t)),this}rotate(e){return this.premultiply(uy.makeRotation(-e)),this}translate(e,t){return this.premultiply(uy.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<9;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const uy=new Ht;function $M(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}function od(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function _B(){const n=od("canvas");return n.style.display="block",n}const BT={};function Xm(n){n in BT||(BT[n]=!0,console.warn(n))}function CB(n,e,t){return new Promise(function(s,r){function i(){switch(n.clientWaitSync(e,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:r();break;case n.TIMEOUT_EXPIRED:setTimeout(i,t);break;default:s()}}setTimeout(i,t)})}function EB(n){const e=n.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}function TB(n){const e=n.elements;e[11]===-1?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=-e[14]+1)}const VT=new Ht().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),GT=new Ht().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function IB(){const n={enabled:!0,workingColorSpace:yu,spaces:{},convert:function(r,i,o){return this.enabled===!1||i===o||!i||!o||(this.spaces[i].transfer===wn&&(r.r=Vo(r.r),r.g=Vo(r.g),r.b=Vo(r.b)),this.spaces[i].primaries!==this.spaces[o].primaries&&(r.applyMatrix3(this.spaces[i].toXYZ),r.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===wn&&(r.r=uu(r.r),r.g=uu(r.g),r.b=uu(r.b))),r},fromWorkingColorSpace:function(r,i){return this.convert(r,this.workingColorSpace,i)},toWorkingColorSpace:function(r,i){return this.convert(r,i,this.workingColorSpace)},getPrimaries:function(r){return this.spaces[r].primaries},getTransfer:function(r){return r===Aa?rg:this.spaces[r].transfer},getLuminanceCoefficients:function(r,i=this.workingColorSpace){return r.fromArray(this.spaces[i].luminanceCoefficients)},define:function(r){Object.assign(this.spaces,r)},_getMatrix:function(r,i,o){return r.copy(this.spaces[i].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(r){return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(r=this.workingColorSpace){return this.spaces[r].workingColorSpaceConfig.unpackColorSpace}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],s=[.3127,.329];return n.define({[yu]:{primaries:e,whitePoint:s,transfer:rg,toXYZ:VT,fromXYZ:GT,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:ci},outputColorSpaceConfig:{drawingBufferColorSpace:ci}},[ci]:{primaries:e,whitePoint:s,transfer:wn,toXYZ:VT,fromXYZ:GT,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:ci}}}),n}const fn=IB();function Vo(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function uu(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let Vc;class AB{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let s;if(e instanceof HTMLCanvasElement)s=e;else{Vc===void 0&&(Vc=od("canvas")),Vc.width=e.width,Vc.height=e.height;const r=Vc.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),s=Vc}return s.toDataURL(t)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=od("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const r=s.getImageData(0,0,e.width,e.height),i=r.data;for(let o=0;o<i.length;o++)i[o]=Vo(i[o]/255)*255;return s.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(Vo(t[s]/255)*255):t[s]=Vo(t[s]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let MB=0;class cS{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:MB++}),this.uuid=_d(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},r=this.data;if(r!==null){let i;if(Array.isArray(r)){i=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?i.push(hy(r[o].image)):i.push(hy(r[o]))}else i=hy(r);s.url=i}return t||(e.images[this.uuid]=s),s}}function hy(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?AB.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let RB=0;class rr extends Nu{constructor(e=rr.DEFAULT_IMAGE,t=rr.DEFAULT_MAPPING,s=Fl,r=Fl,i=io,o=Ll,a=Hr,l=Ui,c=rr.DEFAULT_ANISOTROPY,h=Aa){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:RB++}),this.uuid=_d(),this.name="",this.source=new cS(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=s,this.wrapT=r,this.magFilter=i,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new gn(0,0),this.repeat=new gn(1,1),this.center=new gn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ht,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isTextureArray=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.isTextureArray=e.isTextureArray,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==CM)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Gl:e.x=e.x-Math.floor(e.x);break;case Fl:e.x=e.x<0?0:1;break;case w1:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Gl:e.y=e.y-Math.floor(e.y);break;case Fl:e.y=e.y<0?0:1;break;case w1:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}rr.DEFAULT_IMAGE=null;rr.DEFAULT_MAPPING=CM;rr.DEFAULT_ANISOTROPY=1;class Xn{constructor(e=0,t=0,s=0,r=1){Xn.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,r){return this.x=e,this.y=t,this.z=s,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*s+o[8]*r+o[12]*i,this.y=o[1]*t+o[5]*s+o[9]*r+o[13]*i,this.z=o[2]*t+o[6]*s+o[10]*r+o[14]*i,this.w=o[3]*t+o[7]*s+o[11]*r+o[15]*i,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,r,i;const l=e.elements,c=l[0],h=l[4],d=l[8],p=l[1],m=l[5],g=l[9],b=l[2],y=l[6],v=l[10];if(Math.abs(h-p)<.01&&Math.abs(d-b)<.01&&Math.abs(g-y)<.01){if(Math.abs(h+p)<.1&&Math.abs(d+b)<.1&&Math.abs(g+y)<.1&&Math.abs(c+m+v-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const C=(c+1)/2,_=(m+1)/2,A=(v+1)/2,k=(h+p)/4,N=(d+b)/4,D=(g+y)/4;return C>_&&C>A?C<.01?(s=0,r=.707106781,i=.707106781):(s=Math.sqrt(C),r=k/s,i=N/s):_>A?_<.01?(s=.707106781,r=0,i=.707106781):(r=Math.sqrt(_),s=k/r,i=D/r):A<.01?(s=.707106781,r=.707106781,i=0):(i=Math.sqrt(A),s=N/i,r=D/i),this.set(s,r,i,t),this}let S=Math.sqrt((y-g)*(y-g)+(d-b)*(d-b)+(p-h)*(p-h));return Math.abs(S)<.001&&(S=1),this.x=(y-g)/S,this.y=(d-b)/S,this.z=(p-h)/S,this.w=Math.acos((c+m+v-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Jt(this.x,e.x,t.x),this.y=Jt(this.y,e.y,t.y),this.z=Jt(this.z,e.z,t.z),this.w=Jt(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=Jt(this.x,e,t),this.y=Jt(this.y,e,t),this.z=Jt(this.z,e,t),this.w=Jt(this.w,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Jt(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class kB extends Nu{constructor(e=1,t=1,s={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=s.depth?s.depth:1,this.scissor=new Xn(0,0,e,t),this.scissorTest=!1,this.viewport=new Xn(0,0,e,t);const r={width:e,height:t,depth:this.depth};s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:io,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,multiview:!1},s);const i=new rr(r,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace);i.flipY=!1,i.generateMipmaps=s.generateMipmaps,i.internalFormat=s.internalFormat,this.textures=[];const o=s.count;for(let a=0;a<o;a++)this.textures[a]=i.clone(),this.textures[a].isRenderTargetTexture=!0,this.textures[a].renderTarget=this;this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.resolveDepthBuffer=s.resolveDepthBuffer,this.resolveStencilBuffer=s.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=s.depthTexture,this.samples=s.samples,this.multiview=s.multiview}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){this.width=e,this.height=t,this.depth=s;for(let r=0,i=this.textures.length;r<i;r++)this.textures[r].image.width=e,this.textures[r].image.height=t,this.textures[r].image.depth=s;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,s=e.textures.length;t<s;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const r=Object.assign({},e.textures[t].image);this.textures[t].source=new cS(r)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class za extends kB{constructor(e=1,t=1,s={}){super(e,t,s),this.isWebGLRenderTarget=!0}}class FM extends rr{constructor(e=null,t=1,s=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:r},this.magFilter=mr,this.minFilter=mr,this.wrapR=Fl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class NB extends rr{constructor(e=null,t=1,s=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:s,depth:r},this.magFilter=mr,this.minFilter=mr,this.wrapR=Fl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Cd{constructor(e=0,t=0,s=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=r}static slerpFlat(e,t,s,r,i,o,a){let l=s[r+0],c=s[r+1],h=s[r+2],d=s[r+3];const p=i[o+0],m=i[o+1],g=i[o+2],b=i[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d;return}if(a===1){e[t+0]=p,e[t+1]=m,e[t+2]=g,e[t+3]=b;return}if(d!==b||l!==p||c!==m||h!==g){let y=1-a;const v=l*p+c*m+h*g+d*b,S=v>=0?1:-1,C=1-v*v;if(C>Number.EPSILON){const A=Math.sqrt(C),k=Math.atan2(A,v*S);y=Math.sin(y*k)/A,a=Math.sin(a*k)/A}const _=a*S;if(l=l*y+p*_,c=c*y+m*_,h=h*y+g*_,d=d*y+b*_,y===1-a){const A=1/Math.sqrt(l*l+c*c+h*h+d*d);l*=A,c*=A,h*=A,d*=A}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d}static multiplyQuaternionsFlat(e,t,s,r,i,o){const a=s[r],l=s[r+1],c=s[r+2],h=s[r+3],d=i[o],p=i[o+1],m=i[o+2],g=i[o+3];return e[t]=a*g+h*d+l*m-c*p,e[t+1]=l*g+h*p+c*d-a*m,e[t+2]=c*g+h*m+a*p-l*d,e[t+3]=h*g-a*d-l*p-c*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,r){return this._x=e,this._y=t,this._z=s,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const s=e._x,r=e._y,i=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(s/2),h=a(r/2),d=a(i/2),p=l(s/2),m=l(r/2),g=l(i/2);switch(o){case"XYZ":this._x=p*h*d+c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d-p*m*g;break;case"YXZ":this._x=p*h*d+c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d+p*m*g;break;case"ZXY":this._x=p*h*d-c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d-p*m*g;break;case"ZYX":this._x=p*h*d-c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d+p*m*g;break;case"YZX":this._x=p*h*d+c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d-p*m*g;break;case"XZY":this._x=p*h*d-c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d+p*m*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,r=Math.sin(s);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],r=t[4],i=t[8],o=t[1],a=t[5],l=t[9],c=t[2],h=t[6],d=t[10],p=s+a+d;if(p>0){const m=.5/Math.sqrt(p+1);this._w=.25/m,this._x=(h-l)*m,this._y=(i-c)*m,this._z=(o-r)*m}else if(s>a&&s>d){const m=2*Math.sqrt(1+s-a-d);this._w=(h-l)/m,this._x=.25*m,this._y=(r+o)/m,this._z=(i+c)/m}else if(a>d){const m=2*Math.sqrt(1+a-s-d);this._w=(i-c)/m,this._x=(r+o)/m,this._y=.25*m,this._z=(l+h)/m}else{const m=2*Math.sqrt(1+d-s-a);this._w=(o-r)/m,this._x=(i+c)/m,this._y=(l+h)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Jt(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const r=Math.min(1,t/s);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,r=e._y,i=e._z,o=e._w,a=t._x,l=t._y,c=t._z,h=t._w;return this._x=s*h+o*a+r*c-i*l,this._y=r*h+o*l+i*a-s*c,this._z=i*h+o*c+s*l-r*a,this._w=o*h-s*a-r*l-i*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,r=this._y,i=this._z,o=this._w;let a=o*e._w+s*e._x+r*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=s,this._y=r,this._z=i,this;const l=1-a*a;if(l<=Number.EPSILON){const m=1-t;return this._w=m*o+t*this._w,this._x=m*s+t*this._x,this._y=m*r+t*this._y,this._z=m*i+t*this._z,this.normalize(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),d=Math.sin((1-t)*h)/c,p=Math.sin(t*h)/c;return this._w=o*d+this._w*p,this._x=s*d+this._x*p,this._y=r*d+this._y*p,this._z=i*d+this._z*p,this._onChangeCallback(),this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),s=Math.random(),r=Math.sqrt(1-s),i=Math.sqrt(s);return this.set(r*Math.sin(e),r*Math.cos(e),i*Math.sin(t),i*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Ce{constructor(e=0,t=0,s=0){Ce.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(WT.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(WT.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6]*r,this.y=i[1]*t+i[4]*s+i[7]*r,this.z=i[2]*t+i[5]*s+i[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,i=e.elements,o=1/(i[3]*t+i[7]*s+i[11]*r+i[15]);return this.x=(i[0]*t+i[4]*s+i[8]*r+i[12])*o,this.y=(i[1]*t+i[5]*s+i[9]*r+i[13])*o,this.z=(i[2]*t+i[6]*s+i[10]*r+i[14])*o,this}applyQuaternion(e){const t=this.x,s=this.y,r=this.z,i=e.x,o=e.y,a=e.z,l=e.w,c=2*(o*r-a*s),h=2*(a*t-i*r),d=2*(i*s-o*t);return this.x=t+l*c+o*d-a*h,this.y=s+l*h+a*c-i*d,this.z=r+l*d+i*h-o*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[4]*s+i[8]*r,this.y=i[1]*t+i[5]*s+i[9]*r,this.z=i[2]*t+i[6]*s+i[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Jt(this.x,e.x,t.x),this.y=Jt(this.y,e.y,t.y),this.z=Jt(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=Jt(this.x,e,t),this.y=Jt(this.y,e,t),this.z=Jt(this.z,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Jt(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,r=e.y,i=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-i*a,this.y=i*o-s*l,this.z=s*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return dy.copy(this).projectOnVector(e),this.sub(dy)}reflect(e){return this.sub(dy.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Jt(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,r=this.z-e.z;return t*t+s*s+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const r=Math.sin(t)*e;return this.x=r*Math.sin(s),this.y=Math.cos(t)*e,this.z=r*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,s=Math.sqrt(1-t*t);return this.x=s*Math.cos(e),this.y=t,this.z=s*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const dy=new Ce,WT=new Cd;class ic{constructor(e=new Ce(1/0,1/0,1/0),t=new Ce(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t+=3)this.expandByPoint(Ei.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,s=e.count;t<s;t++)this.expandByPoint(Ei.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=Ei.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const i=s.getAttribute("position");if(t===!0&&i!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=i.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,Ei):Ei.fromBufferAttribute(i,o),Ei.applyMatrix4(e.matrixWorld),this.expandByPoint(Ei);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),Jp.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),Jp.copy(s.boundingBox)),Jp.applyMatrix4(e.matrixWorld),this.union(Jp)}const r=e.children;for(let i=0,o=r.length;i<o;i++)this.expandByObject(r[i],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Ei),Ei.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Fh),em.subVectors(this.max,Fh),Gc.subVectors(e.a,Fh),Wc.subVectors(e.b,Fh),Hc.subVectors(e.c,Fh),Sa.subVectors(Wc,Gc),wa.subVectors(Hc,Wc),yl.subVectors(Gc,Hc);let t=[0,-Sa.z,Sa.y,0,-wa.z,wa.y,0,-yl.z,yl.y,Sa.z,0,-Sa.x,wa.z,0,-wa.x,yl.z,0,-yl.x,-Sa.y,Sa.x,0,-wa.y,wa.x,0,-yl.y,yl.x,0];return!fy(t,Gc,Wc,Hc,em)||(t=[1,0,0,0,1,0,0,0,1],!fy(t,Gc,Wc,Hc,em))?!1:(tm.crossVectors(Sa,wa),t=[tm.x,tm.y,tm.z],fy(t,Gc,Wc,Hc,em))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Ei).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Ei).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(ko[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),ko[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),ko[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),ko[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),ko[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),ko[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),ko[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),ko[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(ko),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const ko=[new Ce,new Ce,new Ce,new Ce,new Ce,new Ce,new Ce,new Ce],Ei=new Ce,Jp=new ic,Gc=new Ce,Wc=new Ce,Hc=new Ce,Sa=new Ce,wa=new Ce,yl=new Ce,Fh=new Ce,em=new Ce,tm=new Ce,bl=new Ce;function fy(n,e,t,s,r){for(let i=0,o=n.length-3;i<=o;i+=3){bl.fromArray(n,i);const a=r.x*Math.abs(bl.x)+r.y*Math.abs(bl.y)+r.z*Math.abs(bl.z),l=e.dot(bl),c=t.dot(bl),h=s.dot(bl);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}const DB=new ic,Lh=new Ce,py=new Ce;class Du{constructor(e=new Ce,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):DB.setFromPoints(e).getCenter(s);let r=0;for(let i=0,o=e.length;i<o;i++)r=Math.max(r,s.distanceToSquared(e[i]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Lh.subVectors(e,this.center);const t=Lh.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),r=(s-this.radius)*.5;this.center.addScaledVector(Lh,r/s),this.radius+=r}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(py.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Lh.copy(e.center).add(py)),this.expandByPoint(Lh.copy(e.center).sub(py))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const No=new Ce,my=new Ce,nm=new Ce,_a=new Ce,gy=new Ce,sm=new Ce,xy=new Ce;class LM{constructor(e=new Ce,t=new Ce(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,No)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=No.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(No.copy(this.origin).addScaledVector(this.direction,t),No.distanceToSquared(e))}distanceSqToSegment(e,t,s,r){my.copy(e).add(t).multiplyScalar(.5),nm.copy(t).sub(e).normalize(),_a.copy(this.origin).sub(my);const i=e.distanceTo(t)*.5,o=-this.direction.dot(nm),a=_a.dot(this.direction),l=-_a.dot(nm),c=_a.lengthSq(),h=Math.abs(1-o*o);let d,p,m,g;if(h>0)if(d=o*l-a,p=o*a-l,g=i*h,d>=0)if(p>=-g)if(p<=g){const b=1/h;d*=b,p*=b,m=d*(d+o*p+2*a)+p*(o*d+p+2*l)+c}else p=i,d=Math.max(0,-(o*p+a)),m=-d*d+p*(p+2*l)+c;else p=-i,d=Math.max(0,-(o*p+a)),m=-d*d+p*(p+2*l)+c;else p<=-g?(d=Math.max(0,-(-o*i+a)),p=d>0?-i:Math.min(Math.max(-i,-l),i),m=-d*d+p*(p+2*l)+c):p<=g?(d=0,p=Math.min(Math.max(-i,-l),i),m=p*(p+2*l)+c):(d=Math.max(0,-(o*i+a)),p=d>0?i:Math.min(Math.max(-i,-l),i),m=-d*d+p*(p+2*l)+c);else p=o>0?-i:i,d=Math.max(0,-(o*p+a)),m=-d*d+p*(p+2*l)+c;return s&&s.copy(this.origin).addScaledVector(this.direction,d),r&&r.copy(my).addScaledVector(nm,p),m}intersectSphere(e,t){No.subVectors(e.center,this.origin);const s=No.dot(this.direction),r=No.dot(No)-s*s,i=e.radius*e.radius;if(r>i)return null;const o=Math.sqrt(i-r),a=s-o,l=s+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,r,i,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,d=1/this.direction.z,p=this.origin;return c>=0?(s=(e.min.x-p.x)*c,r=(e.max.x-p.x)*c):(s=(e.max.x-p.x)*c,r=(e.min.x-p.x)*c),h>=0?(i=(e.min.y-p.y)*h,o=(e.max.y-p.y)*h):(i=(e.max.y-p.y)*h,o=(e.min.y-p.y)*h),s>o||i>r||((i>s||isNaN(s))&&(s=i),(o<r||isNaN(r))&&(r=o),d>=0?(a=(e.min.z-p.z)*d,l=(e.max.z-p.z)*d):(a=(e.max.z-p.z)*d,l=(e.min.z-p.z)*d),s>l||a>r)||((a>s||s!==s)&&(s=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(s>=0?s:r,t)}intersectsBox(e){return this.intersectBox(e,No)!==null}intersectTriangle(e,t,s,r,i){gy.subVectors(t,e),sm.subVectors(s,e),xy.crossVectors(gy,sm);let o=this.direction.dot(xy),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;_a.subVectors(this.origin,e);const l=a*this.direction.dot(sm.crossVectors(_a,sm));if(l<0)return null;const c=a*this.direction.dot(gy.cross(_a));if(c<0||l+c>o)return null;const h=-a*_a.dot(xy);return h<0?null:this.at(h/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class An{constructor(e,t,s,r,i,o,a,l,c,h,d,p,m,g,b,y){An.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,s,r,i,o,a,l,c,h,d,p,m,g,b,y)}set(e,t,s,r,i,o,a,l,c,h,d,p,m,g,b,y){const v=this.elements;return v[0]=e,v[4]=t,v[8]=s,v[12]=r,v[1]=i,v[5]=o,v[9]=a,v[13]=l,v[2]=c,v[6]=h,v[10]=d,v[14]=p,v[3]=m,v[7]=g,v[11]=b,v[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new An().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,r=1/Xc.setFromMatrixColumn(e,0).length(),i=1/Xc.setFromMatrixColumn(e,1).length(),o=1/Xc.setFromMatrixColumn(e,2).length();return t[0]=s[0]*r,t[1]=s[1]*r,t[2]=s[2]*r,t[3]=0,t[4]=s[4]*i,t[5]=s[5]*i,t[6]=s[6]*i,t[7]=0,t[8]=s[8]*o,t[9]=s[9]*o,t[10]=s[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,r=e.y,i=e.z,o=Math.cos(s),a=Math.sin(s),l=Math.cos(r),c=Math.sin(r),h=Math.cos(i),d=Math.sin(i);if(e.order==="XYZ"){const p=o*h,m=o*d,g=a*h,b=a*d;t[0]=l*h,t[4]=-l*d,t[8]=c,t[1]=m+g*c,t[5]=p-b*c,t[9]=-a*l,t[2]=b-p*c,t[6]=g+m*c,t[10]=o*l}else if(e.order==="YXZ"){const p=l*h,m=l*d,g=c*h,b=c*d;t[0]=p+b*a,t[4]=g*a-m,t[8]=o*c,t[1]=o*d,t[5]=o*h,t[9]=-a,t[2]=m*a-g,t[6]=b+p*a,t[10]=o*l}else if(e.order==="ZXY"){const p=l*h,m=l*d,g=c*h,b=c*d;t[0]=p-b*a,t[4]=-o*d,t[8]=g+m*a,t[1]=m+g*a,t[5]=o*h,t[9]=b-p*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const p=o*h,m=o*d,g=a*h,b=a*d;t[0]=l*h,t[4]=g*c-m,t[8]=p*c+b,t[1]=l*d,t[5]=b*c+p,t[9]=m*c-g,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const p=o*l,m=o*c,g=a*l,b=a*c;t[0]=l*h,t[4]=b-p*d,t[8]=g*d+m,t[1]=d,t[5]=o*h,t[9]=-a*h,t[2]=-c*h,t[6]=m*d+g,t[10]=p-b*d}else if(e.order==="XZY"){const p=o*l,m=o*c,g=a*l,b=a*c;t[0]=l*h,t[4]=-d,t[8]=c*h,t[1]=p*d+b,t[5]=o*h,t[9]=m*d-g,t[2]=g*d-m,t[6]=a*h,t[10]=b*d+p}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose($B,e,FB)}lookAt(e,t,s){const r=this.elements;return Br.subVectors(e,t),Br.lengthSq()===0&&(Br.z=1),Br.normalize(),Ca.crossVectors(s,Br),Ca.lengthSq()===0&&(Math.abs(s.z)===1?Br.x+=1e-4:Br.z+=1e-4,Br.normalize(),Ca.crossVectors(s,Br)),Ca.normalize(),rm.crossVectors(Br,Ca),r[0]=Ca.x,r[4]=rm.x,r[8]=Br.x,r[1]=Ca.y,r[5]=rm.y,r[9]=Br.y,r[2]=Ca.z,r[6]=rm.z,r[10]=Br.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,i=this.elements,o=s[0],a=s[4],l=s[8],c=s[12],h=s[1],d=s[5],p=s[9],m=s[13],g=s[2],b=s[6],y=s[10],v=s[14],S=s[3],C=s[7],_=s[11],A=s[15],k=r[0],N=r[4],D=r[8],M=r[12],T=r[1],I=r[5],$=r[9],O=r[13],B=r[2],V=r[6],H=r[10],q=r[14],P=r[3],K=r[7],Z=r[11],U=r[15];return i[0]=o*k+a*T+l*B+c*P,i[4]=o*N+a*I+l*V+c*K,i[8]=o*D+a*$+l*H+c*Z,i[12]=o*M+a*O+l*q+c*U,i[1]=h*k+d*T+p*B+m*P,i[5]=h*N+d*I+p*V+m*K,i[9]=h*D+d*$+p*H+m*Z,i[13]=h*M+d*O+p*q+m*U,i[2]=g*k+b*T+y*B+v*P,i[6]=g*N+b*I+y*V+v*K,i[10]=g*D+b*$+y*H+v*Z,i[14]=g*M+b*O+y*q+v*U,i[3]=S*k+C*T+_*B+A*P,i[7]=S*N+C*I+_*V+A*K,i[11]=S*D+C*$+_*H+A*Z,i[15]=S*M+C*O+_*q+A*U,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],r=e[8],i=e[12],o=e[1],a=e[5],l=e[9],c=e[13],h=e[2],d=e[6],p=e[10],m=e[14],g=e[3],b=e[7],y=e[11],v=e[15];return g*(+i*l*d-r*c*d-i*a*p+s*c*p+r*a*m-s*l*m)+b*(+t*l*m-t*c*p+i*o*p-r*o*m+r*c*h-i*l*h)+y*(+t*c*d-t*a*m-i*o*d+s*o*m+i*a*h-s*c*h)+v*(-r*a*h-t*l*d+t*a*p+r*o*d-s*o*p+s*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],d=e[9],p=e[10],m=e[11],g=e[12],b=e[13],y=e[14],v=e[15],S=d*y*c-b*p*c+b*l*m-a*y*m-d*l*v+a*p*v,C=g*p*c-h*y*c-g*l*m+o*y*m+h*l*v-o*p*v,_=h*b*c-g*d*c+g*a*m-o*b*m-h*a*v+o*d*v,A=g*d*l-h*b*l-g*a*p+o*b*p+h*a*y-o*d*y,k=t*S+s*C+r*_+i*A;if(k===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const N=1/k;return e[0]=S*N,e[1]=(b*p*i-d*y*i-b*r*m+s*y*m+d*r*v-s*p*v)*N,e[2]=(a*y*i-b*l*i+b*r*c-s*y*c-a*r*v+s*l*v)*N,e[3]=(d*l*i-a*p*i-d*r*c+s*p*c+a*r*m-s*l*m)*N,e[4]=C*N,e[5]=(h*y*i-g*p*i+g*r*m-t*y*m-h*r*v+t*p*v)*N,e[6]=(g*l*i-o*y*i-g*r*c+t*y*c+o*r*v-t*l*v)*N,e[7]=(o*p*i-h*l*i+h*r*c-t*p*c-o*r*m+t*l*m)*N,e[8]=_*N,e[9]=(g*d*i-h*b*i-g*s*m+t*b*m+h*s*v-t*d*v)*N,e[10]=(o*b*i-g*a*i+g*s*c-t*b*c-o*s*v+t*a*v)*N,e[11]=(h*a*i-o*d*i-h*s*c+t*d*c+o*s*m-t*a*m)*N,e[12]=A*N,e[13]=(h*b*r-g*d*r+g*s*p-t*b*p-h*s*y+t*d*y)*N,e[14]=(g*a*r-o*b*r-g*s*l+t*b*l+o*s*y-t*a*y)*N,e[15]=(o*d*r-h*a*r+h*s*l-t*d*l-o*s*p+t*a*p)*N,this}scale(e){const t=this.elements,s=e.x,r=e.y,i=e.z;return t[0]*=s,t[4]*=r,t[8]*=i,t[1]*=s,t[5]*=r,t[9]*=i,t[2]*=s,t[6]*=r,t[10]*=i,t[3]*=s,t[7]*=r,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,r))}makeTranslation(e,t,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),r=Math.sin(t),i=1-s,o=e.x,a=e.y,l=e.z,c=i*o,h=i*a;return this.set(c*o+s,c*a-r*l,c*l+r*a,0,c*a+r*l,h*a+s,h*l-r*o,0,c*l-r*a,h*l+r*o,i*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,r,i,o){return this.set(1,s,i,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,s){const r=this.elements,i=t._x,o=t._y,a=t._z,l=t._w,c=i+i,h=o+o,d=a+a,p=i*c,m=i*h,g=i*d,b=o*h,y=o*d,v=a*d,S=l*c,C=l*h,_=l*d,A=s.x,k=s.y,N=s.z;return r[0]=(1-(b+v))*A,r[1]=(m+_)*A,r[2]=(g-C)*A,r[3]=0,r[4]=(m-_)*k,r[5]=(1-(p+v))*k,r[6]=(y+S)*k,r[7]=0,r[8]=(g+C)*N,r[9]=(y-S)*N,r[10]=(1-(p+b))*N,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,s){const r=this.elements;let i=Xc.set(r[0],r[1],r[2]).length();const o=Xc.set(r[4],r[5],r[6]).length(),a=Xc.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),e.x=r[12],e.y=r[13],e.z=r[14],Ti.copy(this);const c=1/i,h=1/o,d=1/a;return Ti.elements[0]*=c,Ti.elements[1]*=c,Ti.elements[2]*=c,Ti.elements[4]*=h,Ti.elements[5]*=h,Ti.elements[6]*=h,Ti.elements[8]*=d,Ti.elements[9]*=d,Ti.elements[10]*=d,t.setFromRotationMatrix(Ti),s.x=i,s.y=o,s.z=a,this}makePerspective(e,t,s,r,i,o,a=zo){const l=this.elements,c=2*i/(t-e),h=2*i/(s-r),d=(t+e)/(t-e),p=(s+r)/(s-r);let m,g;if(a===zo)m=-(o+i)/(o-i),g=-2*o*i/(o-i);else if(a===ig)m=-o/(o-i),g=-o*i/(o-i);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=c,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=h,l[9]=p,l[13]=0,l[2]=0,l[6]=0,l[10]=m,l[14]=g,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,s,r,i,o,a=zo){const l=this.elements,c=1/(t-e),h=1/(s-r),d=1/(o-i),p=(t+e)*c,m=(s+r)*h;let g,b;if(a===zo)g=(o+i)*d,b=-2*d;else if(a===ig)g=i*d,b=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-p,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-m,l[2]=0,l[6]=0,l[10]=b,l[14]=-g,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<16;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const Xc=new Ce,Ti=new An,$B=new Ce(0,0,0),FB=new Ce(1,1,1),Ca=new Ce,rm=new Ce,Br=new Ce,HT=new An,XT=new Cd;class po{constructor(e=0,t=0,s=0,r=po.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,r=this._order){return this._x=e,this._y=t,this._z=s,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const r=e.elements,i=r[0],o=r[4],a=r[8],l=r[1],c=r[5],h=r[9],d=r[2],p=r[6],m=r[10];switch(t){case"XYZ":this._y=Math.asin(Jt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,m),this._z=Math.atan2(-o,i)):(this._x=Math.atan2(p,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Jt(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,m),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-d,i),this._z=0);break;case"ZXY":this._x=Math.asin(Jt(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-d,m),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,i));break;case"ZYX":this._y=Math.asin(-Jt(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(p,m),this._z=Math.atan2(l,i)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Jt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-d,i)):(this._x=0,this._y=Math.atan2(a,m));break;case"XZY":this._z=Math.asin(-Jt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(p,c),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-h,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return HT.makeRotationFromQuaternion(e),this.setFromRotationMatrix(HT,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return XT.setFromEuler(this),this.setFromQuaternion(XT,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}po.DEFAULT_ORDER="XYZ";class PM{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let LB=0;const jT=new Ce,jc=new Cd,Do=new An,im=new Ce,Ph=new Ce,PB=new Ce,OB=new Cd,qT=new Ce(1,0,0),KT=new Ce(0,1,0),YT=new Ce(0,0,1),ZT={type:"added"},UB={type:"removed"},qc={type:"childadded",child:null},vy={type:"childremoved",child:null};class Rs extends Nu{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:LB++}),this.uuid=_d(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Rs.DEFAULT_UP.clone();const e=new Ce,t=new po,s=new Cd,r=new Ce(1,1,1);function i(){s.setFromEuler(t,!1)}function o(){t.setFromQuaternion(s,void 0,!1)}t._onChange(i),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new An},normalMatrix:{value:new Ht}}),this.matrix=new An,this.matrixWorld=new An,this.matrixAutoUpdate=Rs.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Rs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new PM,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return jc.setFromAxisAngle(e,t),this.quaternion.multiply(jc),this}rotateOnWorldAxis(e,t){return jc.setFromAxisAngle(e,t),this.quaternion.premultiply(jc),this}rotateX(e){return this.rotateOnAxis(qT,e)}rotateY(e){return this.rotateOnAxis(KT,e)}rotateZ(e){return this.rotateOnAxis(YT,e)}translateOnAxis(e,t){return jT.copy(e).applyQuaternion(this.quaternion),this.position.add(jT.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(qT,e)}translateY(e){return this.translateOnAxis(KT,e)}translateZ(e){return this.translateOnAxis(YT,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Do.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?im.copy(e):im.set(e,t,s);const r=this.parent;this.updateWorldMatrix(!0,!1),Ph.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Do.lookAt(Ph,im,this.up):Do.lookAt(im,Ph,this.up),this.quaternion.setFromRotationMatrix(Do),r&&(Do.extractRotation(r.matrixWorld),jc.setFromRotationMatrix(Do),this.quaternion.premultiply(jc.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(ZT),qc.child=e,this.dispatchEvent(qc),qc.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(UB),vy.child=e,this.dispatchEvent(vy),vy.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Do.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Do.multiply(e.parent.matrixWorld)),e.applyMatrix4(Do),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(ZT),qc.child=e,this.dispatchEvent(qc),qc.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,r=this.children.length;s<r;s++){const o=this.children[s].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,s=[]){this[e]===t&&s.push(this);const r=this.children;for(let i=0,o=r.length;i<o;i++)r[i].getObjectsByProperty(e,t,s);return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ph,e,PB),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ph,OB,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].updateMatrixWorld(e)}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const r=this.children;for(let i=0,o=r.length;i<o;i++)r[i].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),r.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(r.type="BatchedMesh",r.perObjectFrustumCulled=this.perObjectFrustumCulled,r.sortObjects=this.sortObjects,r.drawRanges=this._drawRanges,r.reservedRanges=this._reservedRanges,r.geometryInfo=this._geometryInfo.map(a=>({...a,boundingBox:a.boundingBox?{min:a.boundingBox.min.toArray(),max:a.boundingBox.max.toArray()}:void 0,boundingSphere:a.boundingSphere?{radius:a.boundingSphere.radius,center:a.boundingSphere.center.toArray()}:void 0})),r.instanceInfo=this._instanceInfo.map(a=>({...a})),r.availableInstanceIds=this._availableInstanceIds.slice(),r.availableGeometryIds=this._availableGeometryIds.slice(),r.nextIndexStart=this._nextIndexStart,r.nextVertexStart=this._nextVertexStart,r.geometryCount=this._geometryCount,r.maxInstanceCount=this._maxInstanceCount,r.maxVertexCount=this._maxVertexCount,r.maxIndexCount=this._maxIndexCount,r.geometryInitialized=this._geometryInitialized,r.matricesTexture=this._matricesTexture.toJSON(e),r.indirectTexture=this._indirectTexture.toJSON(e),this._colorsTexture!==null&&(r.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(r.boundingSphere={center:this.boundingSphere.center.toArray(),radius:this.boundingSphere.radius}),this.boundingBox!==null&&(r.boundingBox={min:this.boundingBox.min.toArray(),max:this.boundingBox.max.toArray()}));function i(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const d=l[c];i(e.shapes,d)}else i(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(i(e.materials,this.material[l]));r.material=a}else r.material=i(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(i(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),h=o(e.images),d=o(e.shapes),p=o(e.skeletons),m=o(e.animations),g=o(e.nodes);a.length>0&&(s.geometries=a),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),h.length>0&&(s.images=h),d.length>0&&(s.shapes=d),p.length>0&&(s.skeletons=p),m.length>0&&(s.animations=m),g.length>0&&(s.nodes=g)}return s.object=r,s;function o(a){const l=[];for(const c in a){const h=a[c];delete h.metadata,l.push(h)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const r=e.children[s];this.add(r.clone())}return this}}Rs.DEFAULT_UP=new Ce(0,1,0);Rs.DEFAULT_MATRIX_AUTO_UPDATE=!0;Rs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Ii=new Ce,$o=new Ce,yy=new Ce,Fo=new Ce,Kc=new Ce,Yc=new Ce,QT=new Ce,by=new Ce,Sy=new Ce,wy=new Ce,_y=new Xn,Cy=new Xn,Ey=new Xn;class Ni{constructor(e=new Ce,t=new Ce,s=new Ce){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,r){r.subVectors(s,t),Ii.subVectors(e,t),r.cross(Ii);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,s,r,i){Ii.subVectors(r,t),$o.subVectors(s,t),yy.subVectors(e,t);const o=Ii.dot(Ii),a=Ii.dot($o),l=Ii.dot(yy),c=$o.dot($o),h=$o.dot(yy),d=o*c-a*a;if(d===0)return i.set(0,0,0),null;const p=1/d,m=(c*l-a*h)*p,g=(o*h-a*l)*p;return i.set(1-m-g,g,m)}static containsPoint(e,t,s,r){return this.getBarycoord(e,t,s,r,Fo)===null?!1:Fo.x>=0&&Fo.y>=0&&Fo.x+Fo.y<=1}static getInterpolation(e,t,s,r,i,o,a,l){return this.getBarycoord(e,t,s,r,Fo)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(i,Fo.x),l.addScaledVector(o,Fo.y),l.addScaledVector(a,Fo.z),l)}static getInterpolatedAttribute(e,t,s,r,i,o){return _y.setScalar(0),Cy.setScalar(0),Ey.setScalar(0),_y.fromBufferAttribute(e,t),Cy.fromBufferAttribute(e,s),Ey.fromBufferAttribute(e,r),o.setScalar(0),o.addScaledVector(_y,i.x),o.addScaledVector(Cy,i.y),o.addScaledVector(Ey,i.z),o}static isFrontFacing(e,t,s,r){return Ii.subVectors(s,t),$o.subVectors(e,t),Ii.cross($o).dot(r)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,r){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,s,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Ii.subVectors(this.c,this.b),$o.subVectors(this.a,this.b),Ii.cross($o).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ni.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ni.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,s,r,i){return Ni.getInterpolation(e,this.a,this.b,this.c,t,s,r,i)}containsPoint(e){return Ni.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ni.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,r=this.b,i=this.c;let o,a;Kc.subVectors(r,s),Yc.subVectors(i,s),by.subVectors(e,s);const l=Kc.dot(by),c=Yc.dot(by);if(l<=0&&c<=0)return t.copy(s);Sy.subVectors(e,r);const h=Kc.dot(Sy),d=Yc.dot(Sy);if(h>=0&&d<=h)return t.copy(r);const p=l*d-h*c;if(p<=0&&l>=0&&h<=0)return o=l/(l-h),t.copy(s).addScaledVector(Kc,o);wy.subVectors(e,i);const m=Kc.dot(wy),g=Yc.dot(wy);if(g>=0&&m<=g)return t.copy(i);const b=m*c-l*g;if(b<=0&&c>=0&&g<=0)return a=c/(c-g),t.copy(s).addScaledVector(Yc,a);const y=h*g-m*d;if(y<=0&&d-h>=0&&m-g>=0)return QT.subVectors(i,r),a=(d-h)/(d-h+(m-g)),t.copy(r).addScaledVector(QT,a);const v=1/(y+b+p);return o=b*v,a=p*v,t.copy(s).addScaledVector(Kc,o).addScaledVector(Yc,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const OM={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ea={h:0,s:0,l:0},om={h:0,s:0,l:0};function Ty(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class Gt{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,s)}set(e,t,s){if(t===void 0&&s===void 0){const r=e;r&&r.isColor?this.copy(r):typeof r=="number"?this.setHex(r):typeof r=="string"&&this.setStyle(r)}else this.setRGB(e,t,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=ci){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,fn.toWorkingColorSpace(this,t),this}setRGB(e,t,s,r=fn.workingColorSpace){return this.r=e,this.g=t,this.b=s,fn.toWorkingColorSpace(this,r),this}setHSL(e,t,s,r=fn.workingColorSpace){if(e=wB(e,1),t=Jt(t,0,1),s=Jt(s,0,1),t===0)this.r=this.g=this.b=s;else{const i=s<=.5?s*(1+t):s+t-s*t,o=2*s-i;this.r=Ty(o,i,e+1/3),this.g=Ty(o,i,e),this.b=Ty(o,i,e-1/3)}return fn.toWorkingColorSpace(this,r),this}setStyle(e,t=ci){function s(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(e)){let i;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,t);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,t);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=r[1],o=i.length;if(o===3)return this.setRGB(parseInt(i.charAt(0),16)/15,parseInt(i.charAt(1),16)/15,parseInt(i.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(i,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=ci){const s=OM[e.toLowerCase()];return s!==void 0?this.setHex(s,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Vo(e.r),this.g=Vo(e.g),this.b=Vo(e.b),this}copyLinearToSRGB(e){return this.r=uu(e.r),this.g=uu(e.g),this.b=uu(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=ci){return fn.fromWorkingColorSpace(Qs.copy(this),e),Math.round(Jt(Qs.r*255,0,255))*65536+Math.round(Jt(Qs.g*255,0,255))*256+Math.round(Jt(Qs.b*255,0,255))}getHexString(e=ci){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=fn.workingColorSpace){fn.fromWorkingColorSpace(Qs.copy(this),t);const s=Qs.r,r=Qs.g,i=Qs.b,o=Math.max(s,r,i),a=Math.min(s,r,i);let l,c;const h=(a+o)/2;if(a===o)l=0,c=0;else{const d=o-a;switch(c=h<=.5?d/(o+a):d/(2-o-a),o){case s:l=(r-i)/d+(r<i?6:0);break;case r:l=(i-s)/d+2;break;case i:l=(s-r)/d+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=fn.workingColorSpace){return fn.fromWorkingColorSpace(Qs.copy(this),t),e.r=Qs.r,e.g=Qs.g,e.b=Qs.b,e}getStyle(e=ci){fn.fromWorkingColorSpace(Qs.copy(this),e);const t=Qs.r,s=Qs.g,r=Qs.b;return e!==ci?`color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(s*255)},${Math.round(r*255)})`}offsetHSL(e,t,s){return this.getHSL(Ea),this.setHSL(Ea.h+e,Ea.s+t,Ea.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(Ea),e.getHSL(om);const s=cy(Ea.h,om.h,t),r=cy(Ea.s,om.s,t),i=cy(Ea.l,om.l,t);return this.setHSL(s,r,i),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,s=this.g,r=this.b,i=e.elements;return this.r=i[0]*t+i[3]*s+i[6]*r,this.g=i[1]*t+i[4]*s+i[7]*r,this.b=i[2]*t+i[5]*s+i[8]*r,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Qs=new Gt;Gt.NAMES=OM;let zB=0;class $u extends Nu{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:zB++}),this.uuid=_d(),this.name="",this.type="Material",this.blending=cu,this.side=Ua,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=h1,this.blendDst=d1,this.blendEquation=Rl,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Gt(0,0,0),this.blendAlpha=0,this.depthFunc=gu,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=OT,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Bc,this.stencilZFail=Bc,this.stencilZPass=Bc,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const r=this[t];if(r===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}r&&r.isColor?r.set(s):r&&r.isVector3&&s&&s.isVector3?r.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==cu&&(s.blending=this.blending),this.side!==Ua&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==h1&&(s.blendSrc=this.blendSrc),this.blendDst!==d1&&(s.blendDst=this.blendDst),this.blendEquation!==Rl&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==gu&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==OT&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Bc&&(s.stencilFail=this.stencilFail),this.stencilZFail!==Bc&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==Bc&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function r(i){const o=[];for(const a in i){const l=i[a];delete l.metadata,o.push(l)}return o}if(t){const i=r(e.textures),o=r(e.images);i.length>0&&(s.textures=i),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const r=t.length;s=new Array(r);for(let i=0;i!==r;++i)s[i]=t[i].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class UM extends $u{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Gt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new po,this.combine=_M,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const os=new Ce,am=new gn;let BB=0;class $i{constructor(e,t,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:BB++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s,this.usage=UT,this.updateRanges=[],this.gpuType=oo,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[s+r];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)am.fromBufferAttribute(this,t),am.applyMatrix3(e),this.setXY(t,am.x,am.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)os.fromBufferAttribute(this,t),os.applyMatrix3(e),this.setXYZ(t,os.x,os.y,os.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)os.fromBufferAttribute(this,t),os.applyMatrix4(e),this.setXYZ(t,os.x,os.y,os.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)os.fromBufferAttribute(this,t),os.applyNormalMatrix(e),this.setXYZ(t,os.x,os.y,os.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)os.fromBufferAttribute(this,t),os.transformDirection(e),this.setXYZ(t,os.x,os.y,os.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let s=this.array[e*this.itemSize+t];return this.normalized&&(s=$h(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Mr(s,this.array)),this.array[e*this.itemSize+t]=s,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=$h(t,this.array)),t}setX(e,t){return this.normalized&&(t=Mr(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=$h(t,this.array)),t}setY(e,t){return this.normalized&&(t=Mr(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=$h(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Mr(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=$h(t,this.array)),t}setW(e,t){return this.normalized&&(t=Mr(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Mr(t,this.array),s=Mr(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,r){return e*=this.itemSize,this.normalized&&(t=Mr(t,this.array),s=Mr(s,this.array),r=Mr(r,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this}setXYZW(e,t,s,r,i){return e*=this.itemSize,this.normalized&&(t=Mr(t,this.array),s=Mr(s,this.array),r=Mr(r,this.array),i=Mr(i,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==UT&&(e.usage=this.usage),e}}class zM extends $i{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class BM extends $i{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class gr extends $i{constructor(e,t,s){super(new Float32Array(e),t,s)}}let VB=0;const si=new An,Iy=new Rs,Zc=new Ce,Vr=new ic,Oh=new ic,As=new Ce;class fi extends Nu{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:VB++}),this.uuid=_d(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new($M(e)?BM:zM)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const i=new Ht().getNormalMatrix(e);s.applyNormalMatrix(i),s.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return si.makeRotationFromQuaternion(e),this.applyMatrix4(si),this}rotateX(e){return si.makeRotationX(e),this.applyMatrix4(si),this}rotateY(e){return si.makeRotationY(e),this.applyMatrix4(si),this}rotateZ(e){return si.makeRotationZ(e),this.applyMatrix4(si),this}translate(e,t,s){return si.makeTranslation(e,t,s),this.applyMatrix4(si),this}scale(e,t,s){return si.makeScale(e,t,s),this.applyMatrix4(si),this}lookAt(e){return Iy.lookAt(e),Iy.updateMatrix(),this.applyMatrix4(Iy.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Zc).negate(),this.translate(Zc.x,Zc.y,Zc.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const s=[];for(let r=0,i=e.length;r<i;r++){const o=e[r];s.push(o.x,o.y,o.z||0)}this.setAttribute("position",new gr(s,3))}else{const s=Math.min(e.length,t.count);for(let r=0;r<s;r++){const i=e[r];t.setXYZ(r,i.x,i.y,i.z||0)}e.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ic);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Ce(-1/0,-1/0,-1/0),new Ce(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,r=t.length;s<r;s++){const i=t[s];Vr.setFromBufferAttribute(i),this.morphTargetsRelative?(As.addVectors(this.boundingBox.min,Vr.min),this.boundingBox.expandByPoint(As),As.addVectors(this.boundingBox.max,Vr.max),this.boundingBox.expandByPoint(As)):(this.boundingBox.expandByPoint(Vr.min),this.boundingBox.expandByPoint(Vr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Du);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Ce,1/0);return}if(e){const s=this.boundingSphere.center;if(Vr.setFromBufferAttribute(e),t)for(let i=0,o=t.length;i<o;i++){const a=t[i];Oh.setFromBufferAttribute(a),this.morphTargetsRelative?(As.addVectors(Vr.min,Oh.min),Vr.expandByPoint(As),As.addVectors(Vr.max,Oh.max),Vr.expandByPoint(As)):(Vr.expandByPoint(Oh.min),Vr.expandByPoint(Oh.max))}Vr.getCenter(s);let r=0;for(let i=0,o=e.count;i<o;i++)As.fromBufferAttribute(e,i),r=Math.max(r,s.distanceToSquared(As));if(t)for(let i=0,o=t.length;i<o;i++){const a=t[i],l=this.morphTargetsRelative;for(let c=0,h=a.count;c<h;c++)As.fromBufferAttribute(a,c),l&&(Zc.fromBufferAttribute(e,c),As.add(Zc)),r=Math.max(r,s.distanceToSquared(As))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=t.position,r=t.normal,i=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new $i(new Float32Array(4*s.count),4));const o=this.getAttribute("tangent"),a=[],l=[];for(let D=0;D<s.count;D++)a[D]=new Ce,l[D]=new Ce;const c=new Ce,h=new Ce,d=new Ce,p=new gn,m=new gn,g=new gn,b=new Ce,y=new Ce;function v(D,M,T){c.fromBufferAttribute(s,D),h.fromBufferAttribute(s,M),d.fromBufferAttribute(s,T),p.fromBufferAttribute(i,D),m.fromBufferAttribute(i,M),g.fromBufferAttribute(i,T),h.sub(c),d.sub(c),m.sub(p),g.sub(p);const I=1/(m.x*g.y-g.x*m.y);isFinite(I)&&(b.copy(h).multiplyScalar(g.y).addScaledVector(d,-m.y).multiplyScalar(I),y.copy(d).multiplyScalar(m.x).addScaledVector(h,-g.x).multiplyScalar(I),a[D].add(b),a[M].add(b),a[T].add(b),l[D].add(y),l[M].add(y),l[T].add(y))}let S=this.groups;S.length===0&&(S=[{start:0,count:e.count}]);for(let D=0,M=S.length;D<M;++D){const T=S[D],I=T.start,$=T.count;for(let O=I,B=I+$;O<B;O+=3)v(e.getX(O+0),e.getX(O+1),e.getX(O+2))}const C=new Ce,_=new Ce,A=new Ce,k=new Ce;function N(D){A.fromBufferAttribute(r,D),k.copy(A);const M=a[D];C.copy(M),C.sub(A.multiplyScalar(A.dot(M))).normalize(),_.crossVectors(k,M);const I=_.dot(l[D])<0?-1:1;o.setXYZW(D,C.x,C.y,C.z,I)}for(let D=0,M=S.length;D<M;++D){const T=S[D],I=T.start,$=T.count;for(let O=I,B=I+$;O<B;O+=3)N(e.getX(O+0)),N(e.getX(O+1)),N(e.getX(O+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new $i(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let p=0,m=s.count;p<m;p++)s.setXYZ(p,0,0,0);const r=new Ce,i=new Ce,o=new Ce,a=new Ce,l=new Ce,c=new Ce,h=new Ce,d=new Ce;if(e)for(let p=0,m=e.count;p<m;p+=3){const g=e.getX(p+0),b=e.getX(p+1),y=e.getX(p+2);r.fromBufferAttribute(t,g),i.fromBufferAttribute(t,b),o.fromBufferAttribute(t,y),h.subVectors(o,i),d.subVectors(r,i),h.cross(d),a.fromBufferAttribute(s,g),l.fromBufferAttribute(s,b),c.fromBufferAttribute(s,y),a.add(h),l.add(h),c.add(h),s.setXYZ(g,a.x,a.y,a.z),s.setXYZ(b,l.x,l.y,l.z),s.setXYZ(y,c.x,c.y,c.z)}else for(let p=0,m=t.count;p<m;p+=3)r.fromBufferAttribute(t,p+0),i.fromBufferAttribute(t,p+1),o.fromBufferAttribute(t,p+2),h.subVectors(o,i),d.subVectors(r,i),h.cross(d),s.setXYZ(p+0,h.x,h.y,h.z),s.setXYZ(p+1,h.x,h.y,h.z),s.setXYZ(p+2,h.x,h.y,h.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)As.fromBufferAttribute(e,t),As.normalize(),e.setXYZ(t,As.x,As.y,As.z)}toNonIndexed(){function e(a,l){const c=a.array,h=a.itemSize,d=a.normalized,p=new c.constructor(l.length*h);let m=0,g=0;for(let b=0,y=l.length;b<y;b++){a.isInterleavedBufferAttribute?m=l[b]*a.data.stride+a.offset:m=l[b]*h;for(let v=0;v<h;v++)p[g++]=c[m++]}return new $i(p,h,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new fi,s=this.index.array,r=this.attributes;for(const a in r){const l=r[a],c=e(l,s);t.setAttribute(a,c)}const i=this.morphAttributes;for(const a in i){const l=[],c=i[a];for(let h=0,d=c.length;h<d;h++){const p=c[h],m=e(p,s);l.push(m)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const c=s[l];e.data.attributes[l]=c.toJSON(e.data)}const r={};let i=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let d=0,p=c.length;d<p;d++){const m=c[d];h.push(m.toJSON(e.data))}h.length>0&&(r[l]=h,i=!0)}i&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone());const r=e.attributes;for(const c in r){const h=r[c];this.setAttribute(c,h.clone(t))}const i=e.morphAttributes;for(const c in i){const h=[],d=i[c];for(let p=0,m=d.length;p<m;p++)h.push(d[p].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,h=o.length;c<h;c++){const d=o[c];this.addGroup(d.start,d.count,d.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const JT=new An,Sl=new LM,lm=new Du,eI=new Ce,cm=new Ce,um=new Ce,hm=new Ce,Ay=new Ce,dm=new Ce,tI=new Ce,fm=new Ce;class Os extends Rs{constructor(e=new fi,t=new UM){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}getVertexPosition(e,t){const s=this.geometry,r=s.attributes.position,i=s.morphAttributes.position,o=s.morphTargetsRelative;t.fromBufferAttribute(r,e);const a=this.morphTargetInfluences;if(i&&a){dm.set(0,0,0);for(let l=0,c=i.length;l<c;l++){const h=a[l],d=i[l];h!==0&&(Ay.fromBufferAttribute(d,e),o?dm.addScaledVector(Ay,h):dm.addScaledVector(Ay.sub(t),h))}t.add(dm)}return t}raycast(e,t){const s=this.geometry,r=this.material,i=this.matrixWorld;r!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),lm.copy(s.boundingSphere),lm.applyMatrix4(i),Sl.copy(e.ray).recast(e.near),!(lm.containsPoint(Sl.origin)===!1&&(Sl.intersectSphere(lm,eI)===null||Sl.origin.distanceToSquared(eI)>(e.far-e.near)**2))&&(JT.copy(i).invert(),Sl.copy(e.ray).applyMatrix4(JT),!(s.boundingBox!==null&&Sl.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,t,Sl)))}_computeIntersections(e,t,s){let r;const i=this.geometry,o=this.material,a=i.index,l=i.attributes.position,c=i.attributes.uv,h=i.attributes.uv1,d=i.attributes.normal,p=i.groups,m=i.drawRange;if(a!==null)if(Array.isArray(o))for(let g=0,b=p.length;g<b;g++){const y=p[g],v=o[y.materialIndex],S=Math.max(y.start,m.start),C=Math.min(a.count,Math.min(y.start+y.count,m.start+m.count));for(let _=S,A=C;_<A;_+=3){const k=a.getX(_),N=a.getX(_+1),D=a.getX(_+2);r=pm(this,v,e,s,c,h,d,k,N,D),r&&(r.faceIndex=Math.floor(_/3),r.face.materialIndex=y.materialIndex,t.push(r))}}else{const g=Math.max(0,m.start),b=Math.min(a.count,m.start+m.count);for(let y=g,v=b;y<v;y+=3){const S=a.getX(y),C=a.getX(y+1),_=a.getX(y+2);r=pm(this,o,e,s,c,h,d,S,C,_),r&&(r.faceIndex=Math.floor(y/3),t.push(r))}}else if(l!==void 0)if(Array.isArray(o))for(let g=0,b=p.length;g<b;g++){const y=p[g],v=o[y.materialIndex],S=Math.max(y.start,m.start),C=Math.min(l.count,Math.min(y.start+y.count,m.start+m.count));for(let _=S,A=C;_<A;_+=3){const k=_,N=_+1,D=_+2;r=pm(this,v,e,s,c,h,d,k,N,D),r&&(r.faceIndex=Math.floor(_/3),r.face.materialIndex=y.materialIndex,t.push(r))}}else{const g=Math.max(0,m.start),b=Math.min(l.count,m.start+m.count);for(let y=g,v=b;y<v;y+=3){const S=y,C=y+1,_=y+2;r=pm(this,o,e,s,c,h,d,S,C,_),r&&(r.faceIndex=Math.floor(y/3),t.push(r))}}}}function GB(n,e,t,s,r,i,o,a){let l;if(e.side===sr?l=s.intersectTriangle(o,i,r,!0,a):l=s.intersectTriangle(r,i,o,e.side===Ua,a),l===null)return null;fm.copy(a),fm.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(fm);return c<t.near||c>t.far?null:{distance:c,point:fm.clone(),object:n}}function pm(n,e,t,s,r,i,o,a,l,c){n.getVertexPosition(a,cm),n.getVertexPosition(l,um),n.getVertexPosition(c,hm);const h=GB(n,e,t,s,cm,um,hm,tI);if(h){const d=new Ce;Ni.getBarycoord(tI,cm,um,hm,d),r&&(h.uv=Ni.getInterpolatedAttribute(r,a,l,c,d,new gn)),i&&(h.uv1=Ni.getInterpolatedAttribute(i,a,l,c,d,new gn)),o&&(h.normal=Ni.getInterpolatedAttribute(o,a,l,c,d,new Ce),h.normal.dot(s.direction)>0&&h.normal.multiplyScalar(-1));const p={a,b:l,c,normal:new Ce,materialIndex:0};Ni.getNormal(cm,um,hm,p.normal),h.face=p,h.barycoord=d}return h}class Wo extends fi{constructor(e=1,t=1,s=1,r=1,i=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:r,heightSegments:i,depthSegments:o};const a=this;r=Math.floor(r),i=Math.floor(i),o=Math.floor(o);const l=[],c=[],h=[],d=[];let p=0,m=0;g("z","y","x",-1,-1,s,t,e,o,i,0),g("z","y","x",1,-1,s,t,-e,o,i,1),g("x","z","y",1,1,e,s,t,r,o,2),g("x","z","y",1,-1,e,s,-t,r,o,3),g("x","y","z",1,-1,e,t,s,r,i,4),g("x","y","z",-1,-1,e,t,-s,r,i,5),this.setIndex(l),this.setAttribute("position",new gr(c,3)),this.setAttribute("normal",new gr(h,3)),this.setAttribute("uv",new gr(d,2));function g(b,y,v,S,C,_,A,k,N,D,M){const T=_/N,I=A/D,$=_/2,O=A/2,B=k/2,V=N+1,H=D+1;let q=0,P=0;const K=new Ce;for(let Z=0;Z<H;Z++){const U=Z*I-O;for(let z=0;z<V;z++){const ne=z*T-$;K[b]=ne*S,K[y]=U*C,K[v]=B,c.push(K.x,K.y,K.z),K[b]=0,K[y]=0,K[v]=k>0?1:-1,h.push(K.x,K.y,K.z),d.push(z/N),d.push(1-Z/D),q+=1}}for(let Z=0;Z<D;Z++)for(let U=0;U<N;U++){const z=p+U+V*Z,ne=p+U+V*(Z+1),Y=p+(U+1)+V*(Z+1),te=p+(U+1)+V*Z;l.push(z,ne,te),l.push(ne,Y,te),P+=6}a.addGroup(m,P,M),m+=P,p+=q}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Wo(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function bu(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const r=n[t][s];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][s]=null):e[t][s]=r.clone():Array.isArray(r)?e[t][s]=r.slice():e[t][s]=r}}return e}function hr(n){const e={};for(let t=0;t<n.length;t++){const s=bu(n[t]);for(const r in s)e[r]=s[r]}return e}function WB(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function VM(n){const e=n.getRenderTarget();return e===null?n.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:fn.workingColorSpace}const HB={clone:bu,merge:hr};var XB=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,jB=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Fi extends $u{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=XB,this.fragmentShader=jB,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=bu(e.uniforms),this.uniformsGroups=WB(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const s={};for(const r in this.extensions)this.extensions[r]===!0&&(s[r]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class GM extends Rs{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new An,this.projectionMatrix=new An,this.projectionMatrixInverse=new An,this.coordinateSystem=zo}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Ta=new Ce,nI=new gn,sI=new gn;class Gr extends GM{constructor(e=50,t=1,s=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=K1*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(ly*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return K1*2*Math.atan(Math.tan(ly*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,s){Ta.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(Ta.x,Ta.y).multiplyScalar(-e/Ta.z),Ta.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(Ta.x,Ta.y).multiplyScalar(-e/Ta.z)}getViewSize(e,t){return this.getViewBounds(e,nI,sI),t.subVectors(sI,nI)}setViewOffset(e,t,s,r,i,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(ly*.5*this.fov)/this.zoom,s=2*t,r=this.aspect*s,i=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;i+=o.offsetX*r/l,t-=o.offsetY*s/c,r*=o.width/l,s*=o.height/c}const a=this.filmOffset;a!==0&&(i+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,t,t-s,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Qc=-90,Jc=1;class qB extends Rs{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const r=new Gr(Qc,Jc,e,t);r.layers=this.layers,this.add(r);const i=new Gr(Qc,Jc,e,t);i.layers=this.layers,this.add(i);const o=new Gr(Qc,Jc,e,t);o.layers=this.layers,this.add(o);const a=new Gr(Qc,Jc,e,t);a.layers=this.layers,this.add(a);const l=new Gr(Qc,Jc,e,t);l.layers=this.layers,this.add(l);const c=new Gr(Qc,Jc,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[s,r,i,o,a,l]=t;for(const c of t)this.remove(c);if(e===zo)s.up.set(0,1,0),s.lookAt(1,0,0),r.up.set(0,1,0),r.lookAt(-1,0,0),i.up.set(0,0,-1),i.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===ig)s.up.set(0,-1,0),s.lookAt(-1,0,0),r.up.set(0,-1,0),r.lookAt(1,0,0),i.up.set(0,0,1),i.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:r}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[i,o,a,l,c,h]=this.children,d=e.getRenderTarget(),p=e.getActiveCubeFace(),m=e.getActiveMipmapLevel(),g=e.xr.enabled;e.xr.enabled=!1;const b=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,r),e.render(t,i),e.setRenderTarget(s,1,r),e.render(t,o),e.setRenderTarget(s,2,r),e.render(t,a),e.setRenderTarget(s,3,r),e.render(t,l),e.setRenderTarget(s,4,r),e.render(t,c),s.texture.generateMipmaps=b,e.setRenderTarget(s,5,r),e.render(t,h),e.setRenderTarget(d,p,m),e.xr.enabled=g,s.texture.needsPMREMUpdate=!0}}class WM extends rr{constructor(e=[],t=xu,s,r,i,o,a,l,c,h){super(e,t,s,r,i,o,a,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class KB extends za{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},r=[s,s,s,s,s,s];this.texture=new WM(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:io}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Wo(5,5,5),i=new Fi({name:"CubemapFromEquirect",uniforms:bu(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:sr,blending:Da});i.uniforms.tEquirect.value=t;const o=new Os(r,i),a=t.minFilter;return t.minFilter===Ll&&(t.minFilter=io),new qB(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t=!0,s=!0,r=!0){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,s,r);e.setRenderTarget(i)}}class mm extends Rs{constructor(){super(),this.isGroup=!0,this.type="Group"}}const YB={type:"move"};class My{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new mm,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new mm,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Ce,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Ce),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new mm,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Ce,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Ce),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let r=null,i=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const b of e.hand.values()){const y=t.getJointPose(b,s),v=this._getHandJoint(c,b);y!==null&&(v.matrix.fromArray(y.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.matrixWorldNeedsUpdate=!0,v.jointRadius=y.radius),v.visible=y!==null}const h=c.joints["index-finger-tip"],d=c.joints["thumb-tip"],p=h.position.distanceTo(d.position),m=.02,g=.005;c.inputState.pinching&&p>m+g?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&p<=m-g&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(i=t.getPose(e.gripSpace,s),i!==null&&(l.matrix.fromArray(i.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,i.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(i.linearVelocity)):l.hasLinearVelocity=!1,i.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(i.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(r=t.getPose(e.targetRaySpace,s),r===null&&i!==null&&(r=i),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(YB)))}return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=i!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new mm;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class ad extends Rs{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new po,this.environmentIntensity=1,this.environmentRotation=new po,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class HM extends rr{constructor(e=null,t=1,s=1,r,i,o,a,l,c=mr,h=mr,d,p){super(null,o,a,l,c,h,r,i,d,p),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class rI extends $i{constructor(e,t,s,r=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const eu=new An,iI=new An,gm=[],oI=new ic,ZB=new An,Uh=new Os,zh=new Du;class aI extends Os{constructor(e,t,s){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new rI(new Float32Array(s*16),16),this.instanceColor=null,this.morphTexture=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let r=0;r<s;r++)this.setMatrixAt(r,ZB)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new ic),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,eu),oI.copy(e.boundingBox).applyMatrix4(eu),this.boundingBox.union(oI)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new Du),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,eu),zh.copy(e.boundingSphere).applyMatrix4(eu),this.boundingSphere.union(zh)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const s=t.morphTargetInfluences,r=this.morphTexture.source.data.data,i=s.length+1,o=e*i+1;for(let a=0;a<s.length;a++)s[a]=r[o+a]}raycast(e,t){const s=this.matrixWorld,r=this.count;if(Uh.geometry=this.geometry,Uh.material=this.material,Uh.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),zh.copy(this.boundingSphere),zh.applyMatrix4(s),e.ray.intersectsSphere(zh)!==!1))for(let i=0;i<r;i++){this.getMatrixAt(i,eu),iI.multiplyMatrices(s,eu),Uh.matrixWorld=iI,Uh.raycast(e,gm);for(let o=0,a=gm.length;o<a;o++){const l=gm[o];l.instanceId=i,l.object=this,t.push(l)}gm.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new rI(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const s=t.morphTargetInfluences,r=s.length+1;this.morphTexture===null&&(this.morphTexture=new HM(new Float32Array(r*this.count),r,this.count,iS,oo));const i=this.morphTexture.source.data.data;let o=0;for(let c=0;c<s.length;c++)o+=s[c];const a=this.geometry.morphTargetsRelative?1:1-o,l=r*e;i[l]=a,i.set(s,l+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const Ry=new Ce,QB=new Ce,JB=new Ht;class Il{constructor(e=new Ce(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,r){return this.normal.set(e,t,s),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const r=Ry.subVectors(s,t).cross(QB.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const s=e.delta(Ry),r=this.normal.dot(s);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:t.copy(e.start).addScaledVector(s,i)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||JB.getNormalMatrix(e),r=this.coplanarPoint(Ry).applyMatrix4(e),i=this.normal.applyMatrix3(s).normalize();return this.constant=-r.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const wl=new Du,xm=new Ce;class uS{constructor(e=new Il,t=new Il,s=new Il,r=new Il,i=new Il,o=new Il){this.planes=[e,t,s,r,i,o]}set(e,t,s,r,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(s),a[3].copy(r),a[4].copy(i),a[5].copy(o),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,t=zo){const s=this.planes,r=e.elements,i=r[0],o=r[1],a=r[2],l=r[3],c=r[4],h=r[5],d=r[6],p=r[7],m=r[8],g=r[9],b=r[10],y=r[11],v=r[12],S=r[13],C=r[14],_=r[15];if(s[0].setComponents(l-i,p-c,y-m,_-v).normalize(),s[1].setComponents(l+i,p+c,y+m,_+v).normalize(),s[2].setComponents(l+o,p+h,y+g,_+S).normalize(),s[3].setComponents(l-o,p-h,y-g,_-S).normalize(),s[4].setComponents(l-a,p-d,y-b,_-C).normalize(),t===zo)s[5].setComponents(l+a,p+d,y+b,_+C).normalize();else if(t===ig)s[5].setComponents(a,d,b,C).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),wl.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),wl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(wl)}intersectsSprite(e){return wl.center.set(0,0,0),wl.radius=.7071067811865476,wl.applyMatrix4(e.matrixWorld),this.intersectsSphere(wl)}intersectsSphere(e){const t=this.planes,s=e.center,r=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(s)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const r=t[s];if(xm.x=r.normal.x>0?e.max.x:e.min.x,xm.y=r.normal.y>0?e.max.y:e.min.y,xm.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(xm)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class Xg extends $u{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Gt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const og=new Ce,ag=new Ce,lI=new An,Bh=new LM,vm=new Du,ky=new Ce,cI=new Ce;class Y1 extends Rs{constructor(e=new fi,t=new Xg){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[0];for(let r=1,i=t.count;r<i;r++)og.fromBufferAttribute(t,r-1),ag.fromBufferAttribute(t,r),s[r]=s[r-1],s[r]+=og.distanceTo(ag);e.setAttribute("lineDistance",new gr(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const s=this.geometry,r=this.matrixWorld,i=e.params.Line.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),vm.copy(s.boundingSphere),vm.applyMatrix4(r),vm.radius+=i,e.ray.intersectsSphere(vm)===!1)return;lI.copy(r).invert(),Bh.copy(e.ray).applyMatrix4(lI);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=this.isLineSegments?2:1,h=s.index,p=s.attributes.position;if(h!==null){const m=Math.max(0,o.start),g=Math.min(h.count,o.start+o.count);for(let b=m,y=g-1;b<y;b+=c){const v=h.getX(b),S=h.getX(b+1),C=ym(this,e,Bh,l,v,S,b);C&&t.push(C)}if(this.isLineLoop){const b=h.getX(g-1),y=h.getX(m),v=ym(this,e,Bh,l,b,y,g-1);v&&t.push(v)}}else{const m=Math.max(0,o.start),g=Math.min(p.count,o.start+o.count);for(let b=m,y=g-1;b<y;b+=c){const v=ym(this,e,Bh,l,b,b+1,b);v&&t.push(v)}if(this.isLineLoop){const b=ym(this,e,Bh,l,g-1,m,g-1);b&&t.push(b)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}}function ym(n,e,t,s,r,i,o){const a=n.geometry.attributes.position;if(og.fromBufferAttribute(a,r),ag.fromBufferAttribute(a,i),t.distanceSqToSegment(og,ag,ky,cI)>s)return;ky.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(ky);if(!(c<e.near||c>e.far))return{distance:c,point:cI.clone().applyMatrix4(n.matrixWorld),index:o,face:null,faceIndex:null,barycoord:null,object:n}}const uI=new Ce,hI=new Ce;class XM extends Y1{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[];for(let r=0,i=t.count;r<i;r+=2)uI.fromBufferAttribute(t,r),hI.fromBufferAttribute(t,r+1),s[r]=r===0?0:s[r-1],s[r+1]=s[r]+uI.distanceTo(hI);e.setAttribute("lineDistance",new gr(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class jM extends rr{constructor(e,t,s=Wl,r,i,o,a=mr,l=mr,c,h=rd){if(h!==rd&&h!==id)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super(null,r,i,o,a,l,h,s,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new cS(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class oc extends fi{constructor(e=1,t=1,s=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:r};const i=e/2,o=t/2,a=Math.floor(s),l=Math.floor(r),c=a+1,h=l+1,d=e/a,p=t/l,m=[],g=[],b=[],y=[];for(let v=0;v<h;v++){const S=v*p-o;for(let C=0;C<c;C++){const _=C*d-i;g.push(_,-S,0),b.push(0,0,1),y.push(C/a),y.push(1-v/l)}}for(let v=0;v<l;v++)for(let S=0;S<a;S++){const C=S+c*v,_=S+c*(v+1),A=S+1+c*(v+1),k=S+1+c*v;m.push(C,_,k),m.push(_,A,k)}this.setIndex(m),this.setAttribute("position",new gr(g,3)),this.setAttribute("normal",new gr(b,3)),this.setAttribute("uv",new gr(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oc(e.width,e.height,e.widthSegments,e.heightSegments)}}class ld extends $u{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Gt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Gt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=NM,this.normalScale=new gn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new po,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Z1 extends ld{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new gn(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Jt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Gt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Gt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Gt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class e4 extends $u{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=dB,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class t4 extends $u{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const dI={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class n4{constructor(e,t,s){const r=this;let i=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this.itemStart=function(h){a++,i===!1&&r.onStart!==void 0&&r.onStart(h,o,a),i=!0},this.itemEnd=function(h){o++,r.onProgress!==void 0&&r.onProgress(h,o,a),o===a&&(i=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(h){r.onError!==void 0&&r.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,d){return c.push(h,d),this},this.removeHandler=function(h){const d=c.indexOf(h);return d!==-1&&c.splice(d,2),this},this.getHandler=function(h){for(let d=0,p=c.length;d<p;d+=2){const m=c[d],g=c[d+1];if(m.global&&(m.lastIndex=0),m.test(h))return g}return null}}}const s4=new n4;class hS{constructor(e){this.manager=e!==void 0?e:s4,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(r,i){s.load(e,r,t,i)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}hS.DEFAULT_MATERIAL_NAME="__DEFAULT";class r4 extends hS{constructor(e){super(e)}load(e,t,s,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=dI.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;const a=od("img");function l(){h(),dI.add(e,this),t&&t(this),i.manager.itemEnd(e)}function c(d){h(),r&&r(d),i.manager.itemError(e),i.manager.itemEnd(e)}function h(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(e),a.src=e,a}}class qM extends hS{constructor(e){super(e)}load(e,t,s,r){const i=new rr,o=new r4(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){i.image=a,i.needsUpdate=!0,t!==void 0&&t(i)},s,r),i}}class KM extends Rs{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Gt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}const Ny=new An,fI=new Ce,pI=new Ce;class i4{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new gn(512,512),this.mapType=Ui,this.map=null,this.mapPass=null,this.matrix=new An,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new uS,this._frameExtents=new gn(1,1),this._viewportCount=1,this._viewports=[new Xn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;fI.setFromMatrixPosition(e.matrixWorld),t.position.copy(fI),pI.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(pI),t.updateMatrixWorld(),Ny.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ny),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(Ny)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.autoUpdate=e.autoUpdate,this.needsUpdate=e.needsUpdate,this.normalBias=e.normalBias,this.blurSamples=e.blurSamples,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class dS extends GM{constructor(e=-1,t=1,s=1,r=-1,i=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=r,this.near=i,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,r,i,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=s-e,o=s+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=c*this.view.offsetX,o=i+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(i,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class o4 extends i4{constructor(){super(new dS(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class kr extends KM{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Rs.DEFAULT_UP),this.updateMatrix(),this.target=new Rs,this.shadow=new o4}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class YM extends KM{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class a4 extends Gr{constructor(e=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=e}}class ZM extends XM{constructor(e=10,t=10,s=4473924,r=8947848){s=new Gt(s),r=new Gt(r);const i=t/2,o=e/t,a=e/2,l=[],c=[];for(let p=0,m=0,g=-a;p<=t;p++,g+=o){l.push(-a,0,g,a,0,g),l.push(g,0,-a,g,0,a);const b=p===i?s:r;b.toArray(c,m),m+=3,b.toArray(c,m),m+=3,b.toArray(c,m),m+=3,b.toArray(c,m),m+=3}const h=new fi;h.setAttribute("position",new gr(l,3)),h.setAttribute("color",new gr(c,3));const d=new Xg({vertexColors:!0,toneMapped:!1});super(h,d),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const mI=new Ce,bm=new Ce,gI=new Ce;class ro extends Rs{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="DirectionalLightHelper",t===void 0&&(t=1);let r=new fi;r.setAttribute("position",new gr([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new Xg({fog:!1,toneMapped:!1});this.lightPlane=new Y1(r,i),this.add(this.lightPlane),r=new fi,r.setAttribute("position",new gr([0,0,0,0,0,1],3)),this.targetLine=new Y1(r,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),mI.setFromMatrixPosition(this.light.matrixWorld),bm.setFromMatrixPosition(this.light.target.matrixWorld),gI.subVectors(bm,mI),this.lightPlane.lookAt(bm),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(bm),this.targetLine.scale.z=gI.length()}}class QM extends XM{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new fi;r.setAttribute("position",new gr(t,3)),r.setAttribute("color",new gr(s,3));const i=new Xg({vertexColors:!0,toneMapped:!1});super(r,i),this.type="AxesHelper"}setColors(e,t,s){const r=new Gt,i=this.geometry.attributes.color.array;return r.set(e),r.toArray(i,0),r.toArray(i,3),r.set(t),r.toArray(i,6),r.toArray(i,9),r.set(s),r.toArray(i,12),r.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}function xI(n,e,t,s){const r=l4(s);switch(t){case AM:return n*e;case iS:return n*e/r.components*r.byteLength;case oS:return n*e/r.components*r.byteLength;case RM:return n*e*2/r.components*r.byteLength;case aS:return n*e*2/r.components*r.byteLength;case MM:return n*e*3/r.components*r.byteLength;case Hr:return n*e*4/r.components*r.byteLength;case lS:return n*e*4/r.components*r.byteLength;case Bm:case Vm:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case Gm:case Wm:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case C1:case T1:return Math.max(n,16)*Math.max(e,8)/4;case _1:case E1:return Math.max(n,8)*Math.max(e,8)/2;case I1:case A1:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case M1:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case R1:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case k1:return Math.floor((n+4)/5)*Math.floor((e+3)/4)*16;case N1:return Math.floor((n+4)/5)*Math.floor((e+4)/5)*16;case D1:return Math.floor((n+5)/6)*Math.floor((e+4)/5)*16;case $1:return Math.floor((n+5)/6)*Math.floor((e+5)/6)*16;case F1:return Math.floor((n+7)/8)*Math.floor((e+4)/5)*16;case L1:return Math.floor((n+7)/8)*Math.floor((e+5)/6)*16;case P1:return Math.floor((n+7)/8)*Math.floor((e+7)/8)*16;case O1:return Math.floor((n+9)/10)*Math.floor((e+4)/5)*16;case U1:return Math.floor((n+9)/10)*Math.floor((e+5)/6)*16;case z1:return Math.floor((n+9)/10)*Math.floor((e+7)/8)*16;case B1:return Math.floor((n+9)/10)*Math.floor((e+9)/10)*16;case V1:return Math.floor((n+11)/12)*Math.floor((e+9)/10)*16;case G1:return Math.floor((n+11)/12)*Math.floor((e+11)/12)*16;case Hm:case W1:case H1:return Math.ceil(n/4)*Math.ceil(e/4)*16;case kM:case X1:return Math.ceil(n/4)*Math.ceil(e/4)*8;case j1:case q1:return Math.ceil(n/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function l4(n){switch(n){case Ui:case EM:return{byteLength:1,components:1};case nd:case TM:case wd:return{byteLength:2,components:1};case sS:case rS:return{byteLength:2,components:4};case Wl:case nS:case oo:return{byteLength:4,components:1};case IM:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:eS}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=eS);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function JM(){let n=null,e=!1,t=null,s=null;function r(i,o){t(i,o),s=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){n=i}}}function c4(n){const e=new WeakMap;function t(a,l){const c=a.array,h=a.usage,d=c.byteLength,p=n.createBuffer();n.bindBuffer(l,p),n.bufferData(l,c,h),a.onUploadCallback();let m;if(c instanceof Float32Array)m=n.FLOAT;else if(c instanceof Uint16Array)a.isFloat16BufferAttribute?m=n.HALF_FLOAT:m=n.UNSIGNED_SHORT;else if(c instanceof Int16Array)m=n.SHORT;else if(c instanceof Uint32Array)m=n.UNSIGNED_INT;else if(c instanceof Int32Array)m=n.INT;else if(c instanceof Int8Array)m=n.BYTE;else if(c instanceof Uint8Array)m=n.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)m=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:p,type:m,bytesPerElement:c.BYTES_PER_ELEMENT,version:a.version,size:d}}function s(a,l,c){const h=l.array,d=l.updateRanges;if(n.bindBuffer(c,a),d.length===0)n.bufferSubData(c,0,h);else{d.sort((m,g)=>m.start-g.start);let p=0;for(let m=1;m<d.length;m++){const g=d[p],b=d[m];b.start<=g.start+g.count+1?g.count=Math.max(g.count,b.start+b.count-g.start):(++p,d[p]=b)}d.length=p+1;for(let m=0,g=d.length;m<g;m++){const b=d[m];n.bufferSubData(c,b.start*h.BYTES_PER_ELEMENT,h,b.start,b.count)}l.clearUpdateRanges()}l.onUploadCallback()}function r(a){return a.isInterleavedBufferAttribute&&(a=a.data),e.get(a)}function i(a){a.isInterleavedBufferAttribute&&(a=a.data);const l=e.get(a);l&&(n.deleteBuffer(l.buffer),e.delete(a))}function o(a,l){if(a.isInterleavedBufferAttribute&&(a=a.data),a.isGLBufferAttribute){const h=e.get(a);(!h||h.version<a.version)&&e.set(a,{buffer:a.buffer,type:a.type,bytesPerElement:a.elementSize,version:a.version});return}const c=e.get(a);if(c===void 0)e.set(a,t(a,l));else if(c.version<a.version){if(c.size!==a.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");s(c.buffer,a,l),c.version=a.version}}return{get:r,remove:i,update:o}}var u4=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,h4=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,d4=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,f4=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,p4=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,m4=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,g4=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,x4=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,v4=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,y4=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,b4=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,S4=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,w4=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,_4=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,C4=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,E4=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,T4=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,I4=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,A4=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,M4=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,R4=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,k4=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,N4=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,D4=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,$4=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,F4=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,L4=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,P4=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,O4=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,U4=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,z4="gl_FragColor = linearToOutputTexel( gl_FragColor );",B4=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,V4=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,G4=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,W4=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,H4=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,X4=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,j4=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,q4=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,K4=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Y4=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Z4=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Q4=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,J4=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,eV=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,tV=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,nV=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,sV=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,rV=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,iV=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,oV=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,aV=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,lV=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,cV=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,uV=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,hV=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,dV=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,fV=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,pV=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,mV=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,gV=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,xV=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,vV=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,yV=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,bV=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,SV=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,wV=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,_V=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,CV=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,EV=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,TV=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,IV=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,AV=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,MV=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,RV=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,kV=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,NV=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,DV=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,$V=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,FV=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,LV=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,PV=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,OV=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,UV=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,zV=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,BV=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,VV=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,GV=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,WV=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,HV=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,XV=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,jV=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,qV=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,KV=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,YV=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,ZV=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,QV=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,JV=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,eG=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tG=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,nG=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,sG=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,rG=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,iG=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,oG=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,aG=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,lG=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const cG=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,uG=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,hG=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,dG=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,fG=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,pG=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,mG=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,gG=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,xG=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,vG=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,yG=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,bG=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,SG=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,wG=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,_G=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,CG=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,EG=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,TG=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,IG=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,AG=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,MG=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,RG=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,kG=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,NG=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,DG=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,$G=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,FG=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,LG=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,PG=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,OG=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,UG=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,zG=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,BG=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,VG=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Xt={alphahash_fragment:u4,alphahash_pars_fragment:h4,alphamap_fragment:d4,alphamap_pars_fragment:f4,alphatest_fragment:p4,alphatest_pars_fragment:m4,aomap_fragment:g4,aomap_pars_fragment:x4,batching_pars_vertex:v4,batching_vertex:y4,begin_vertex:b4,beginnormal_vertex:S4,bsdfs:w4,iridescence_fragment:_4,bumpmap_pars_fragment:C4,clipping_planes_fragment:E4,clipping_planes_pars_fragment:T4,clipping_planes_pars_vertex:I4,clipping_planes_vertex:A4,color_fragment:M4,color_pars_fragment:R4,color_pars_vertex:k4,color_vertex:N4,common:D4,cube_uv_reflection_fragment:$4,defaultnormal_vertex:F4,displacementmap_pars_vertex:L4,displacementmap_vertex:P4,emissivemap_fragment:O4,emissivemap_pars_fragment:U4,colorspace_fragment:z4,colorspace_pars_fragment:B4,envmap_fragment:V4,envmap_common_pars_fragment:G4,envmap_pars_fragment:W4,envmap_pars_vertex:H4,envmap_physical_pars_fragment:nV,envmap_vertex:X4,fog_vertex:j4,fog_pars_vertex:q4,fog_fragment:K4,fog_pars_fragment:Y4,gradientmap_pars_fragment:Z4,lightmap_pars_fragment:Q4,lights_lambert_fragment:J4,lights_lambert_pars_fragment:eV,lights_pars_begin:tV,lights_toon_fragment:sV,lights_toon_pars_fragment:rV,lights_phong_fragment:iV,lights_phong_pars_fragment:oV,lights_physical_fragment:aV,lights_physical_pars_fragment:lV,lights_fragment_begin:cV,lights_fragment_maps:uV,lights_fragment_end:hV,logdepthbuf_fragment:dV,logdepthbuf_pars_fragment:fV,logdepthbuf_pars_vertex:pV,logdepthbuf_vertex:mV,map_fragment:gV,map_pars_fragment:xV,map_particle_fragment:vV,map_particle_pars_fragment:yV,metalnessmap_fragment:bV,metalnessmap_pars_fragment:SV,morphinstance_vertex:wV,morphcolor_vertex:_V,morphnormal_vertex:CV,morphtarget_pars_vertex:EV,morphtarget_vertex:TV,normal_fragment_begin:IV,normal_fragment_maps:AV,normal_pars_fragment:MV,normal_pars_vertex:RV,normal_vertex:kV,normalmap_pars_fragment:NV,clearcoat_normal_fragment_begin:DV,clearcoat_normal_fragment_maps:$V,clearcoat_pars_fragment:FV,iridescence_pars_fragment:LV,opaque_fragment:PV,packing:OV,premultiplied_alpha_fragment:UV,project_vertex:zV,dithering_fragment:BV,dithering_pars_fragment:VV,roughnessmap_fragment:GV,roughnessmap_pars_fragment:WV,shadowmap_pars_fragment:HV,shadowmap_pars_vertex:XV,shadowmap_vertex:jV,shadowmask_pars_fragment:qV,skinbase_vertex:KV,skinning_pars_vertex:YV,skinning_vertex:ZV,skinnormal_vertex:QV,specularmap_fragment:JV,specularmap_pars_fragment:eG,tonemapping_fragment:tG,tonemapping_pars_fragment:nG,transmission_fragment:sG,transmission_pars_fragment:rG,uv_pars_fragment:iG,uv_pars_vertex:oG,uv_vertex:aG,worldpos_vertex:lG,background_vert:cG,background_frag:uG,backgroundCube_vert:hG,backgroundCube_frag:dG,cube_vert:fG,cube_frag:pG,depth_vert:mG,depth_frag:gG,distanceRGBA_vert:xG,distanceRGBA_frag:vG,equirect_vert:yG,equirect_frag:bG,linedashed_vert:SG,linedashed_frag:wG,meshbasic_vert:_G,meshbasic_frag:CG,meshlambert_vert:EG,meshlambert_frag:TG,meshmatcap_vert:IG,meshmatcap_frag:AG,meshnormal_vert:MG,meshnormal_frag:RG,meshphong_vert:kG,meshphong_frag:NG,meshphysical_vert:DG,meshphysical_frag:$G,meshtoon_vert:FG,meshtoon_frag:LG,points_vert:PG,points_frag:OG,shadow_vert:UG,shadow_frag:zG,sprite_vert:BG,sprite_frag:VG},rt={common:{diffuse:{value:new Gt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Ht},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Ht}},envmap:{envMap:{value:null},envMapRotation:{value:new Ht},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Ht}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Ht}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Ht},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Ht},normalScale:{value:new gn(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Ht},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Ht}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Ht}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Ht}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Gt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Gt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0},uvTransform:{value:new Ht}},sprite:{diffuse:{value:new Gt(16777215)},opacity:{value:1},center:{value:new gn(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Ht},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0}}},eo={basic:{uniforms:hr([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.fog]),vertexShader:Xt.meshbasic_vert,fragmentShader:Xt.meshbasic_frag},lambert:{uniforms:hr([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,rt.lights,{emissive:{value:new Gt(0)}}]),vertexShader:Xt.meshlambert_vert,fragmentShader:Xt.meshlambert_frag},phong:{uniforms:hr([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,rt.lights,{emissive:{value:new Gt(0)},specular:{value:new Gt(1118481)},shininess:{value:30}}]),vertexShader:Xt.meshphong_vert,fragmentShader:Xt.meshphong_frag},standard:{uniforms:hr([rt.common,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.roughnessmap,rt.metalnessmap,rt.fog,rt.lights,{emissive:{value:new Gt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Xt.meshphysical_vert,fragmentShader:Xt.meshphysical_frag},toon:{uniforms:hr([rt.common,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.gradientmap,rt.fog,rt.lights,{emissive:{value:new Gt(0)}}]),vertexShader:Xt.meshtoon_vert,fragmentShader:Xt.meshtoon_frag},matcap:{uniforms:hr([rt.common,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,{matcap:{value:null}}]),vertexShader:Xt.meshmatcap_vert,fragmentShader:Xt.meshmatcap_frag},points:{uniforms:hr([rt.points,rt.fog]),vertexShader:Xt.points_vert,fragmentShader:Xt.points_frag},dashed:{uniforms:hr([rt.common,rt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Xt.linedashed_vert,fragmentShader:Xt.linedashed_frag},depth:{uniforms:hr([rt.common,rt.displacementmap]),vertexShader:Xt.depth_vert,fragmentShader:Xt.depth_frag},normal:{uniforms:hr([rt.common,rt.bumpmap,rt.normalmap,rt.displacementmap,{opacity:{value:1}}]),vertexShader:Xt.meshnormal_vert,fragmentShader:Xt.meshnormal_frag},sprite:{uniforms:hr([rt.sprite,rt.fog]),vertexShader:Xt.sprite_vert,fragmentShader:Xt.sprite_frag},background:{uniforms:{uvTransform:{value:new Ht},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Xt.background_vert,fragmentShader:Xt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Ht}},vertexShader:Xt.backgroundCube_vert,fragmentShader:Xt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Xt.cube_vert,fragmentShader:Xt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Xt.equirect_vert,fragmentShader:Xt.equirect_frag},distanceRGBA:{uniforms:hr([rt.common,rt.displacementmap,{referencePosition:{value:new Ce},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Xt.distanceRGBA_vert,fragmentShader:Xt.distanceRGBA_frag},shadow:{uniforms:hr([rt.lights,rt.fog,{color:{value:new Gt(0)},opacity:{value:1}}]),vertexShader:Xt.shadow_vert,fragmentShader:Xt.shadow_frag}};eo.physical={uniforms:hr([eo.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Ht},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Ht},clearcoatNormalScale:{value:new gn(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Ht},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Ht},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Ht},sheen:{value:0},sheenColor:{value:new Gt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Ht},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Ht},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Ht},transmissionSamplerSize:{value:new gn},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Ht},attenuationDistance:{value:0},attenuationColor:{value:new Gt(0)},specularColor:{value:new Gt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Ht},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Ht},anisotropyVector:{value:new gn},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Ht}}]),vertexShader:Xt.meshphysical_vert,fragmentShader:Xt.meshphysical_frag};const Sm={r:0,b:0,g:0},_l=new po,GG=new An;function WG(n,e,t,s,r,i,o){const a=new Gt(0);let l=i===!0?0:1,c,h,d=null,p=0,m=null;function g(C){let _=C.isScene===!0?C.background:null;return _&&_.isTexture&&(_=(C.backgroundBlurriness>0?t:e).get(_)),_}function b(C){let _=!1;const A=g(C);A===null?v(a,l):A&&A.isColor&&(v(A,1),_=!0);const k=n.xr.getEnvironmentBlendMode();k==="additive"?s.buffers.color.setClear(0,0,0,1,o):k==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,o),(n.autoClear||_)&&(s.buffers.depth.setTest(!0),s.buffers.depth.setMask(!0),s.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function y(C,_){const A=g(_);A&&(A.isCubeTexture||A.mapping===Hg)?(h===void 0&&(h=new Os(new Wo(1,1,1),new Fi({name:"BackgroundCubeMaterial",uniforms:bu(eo.backgroundCube.uniforms),vertexShader:eo.backgroundCube.vertexShader,fragmentShader:eo.backgroundCube.fragmentShader,side:sr,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(k,N,D){this.matrixWorld.copyPosition(D.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(h)),_l.copy(_.backgroundRotation),_l.x*=-1,_l.y*=-1,_l.z*=-1,A.isCubeTexture&&A.isRenderTargetTexture===!1&&(_l.y*=-1,_l.z*=-1),h.material.uniforms.envMap.value=A,h.material.uniforms.flipEnvMap.value=A.isCubeTexture&&A.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=_.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(GG.makeRotationFromEuler(_l)),h.material.toneMapped=fn.getTransfer(A.colorSpace)!==wn,(d!==A||p!==A.version||m!==n.toneMapping)&&(h.material.needsUpdate=!0,d=A,p=A.version,m=n.toneMapping),h.layers.enableAll(),C.unshift(h,h.geometry,h.material,0,0,null)):A&&A.isTexture&&(c===void 0&&(c=new Os(new oc(2,2),new Fi({name:"BackgroundMaterial",uniforms:bu(eo.background.uniforms),vertexShader:eo.background.vertexShader,fragmentShader:eo.background.fragmentShader,side:Ua,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(c)),c.material.uniforms.t2D.value=A,c.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,c.material.toneMapped=fn.getTransfer(A.colorSpace)!==wn,A.matrixAutoUpdate===!0&&A.updateMatrix(),c.material.uniforms.uvTransform.value.copy(A.matrix),(d!==A||p!==A.version||m!==n.toneMapping)&&(c.material.needsUpdate=!0,d=A,p=A.version,m=n.toneMapping),c.layers.enableAll(),C.unshift(c,c.geometry,c.material,0,0,null))}function v(C,_){C.getRGB(Sm,VM(n)),s.buffers.color.setClear(Sm.r,Sm.g,Sm.b,_,o)}function S(){h!==void 0&&(h.geometry.dispose(),h.material.dispose(),h=void 0),c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0)}return{getClearColor:function(){return a},setClearColor:function(C,_=1){a.set(C),l=_,v(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(C){l=C,v(a,l)},render:b,addToRenderList:y,dispose:S}}function HG(n,e){const t=n.getParameter(n.MAX_VERTEX_ATTRIBS),s={},r=p(null);let i=r,o=!1;function a(T,I,$,O,B){let V=!1;const H=d(O,$,I);i!==H&&(i=H,c(i.object)),V=m(T,O,$,B),V&&g(T,O,$,B),B!==null&&e.update(B,n.ELEMENT_ARRAY_BUFFER),(V||o)&&(o=!1,_(T,I,$,O),B!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e.get(B).buffer))}function l(){return n.createVertexArray()}function c(T){return n.bindVertexArray(T)}function h(T){return n.deleteVertexArray(T)}function d(T,I,$){const O=$.wireframe===!0;let B=s[T.id];B===void 0&&(B={},s[T.id]=B);let V=B[I.id];V===void 0&&(V={},B[I.id]=V);let H=V[O];return H===void 0&&(H=p(l()),V[O]=H),H}function p(T){const I=[],$=[],O=[];for(let B=0;B<t;B++)I[B]=0,$[B]=0,O[B]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:I,enabledAttributes:$,attributeDivisors:O,object:T,attributes:{},index:null}}function m(T,I,$,O){const B=i.attributes,V=I.attributes;let H=0;const q=$.getAttributes();for(const P in q)if(q[P].location>=0){const Z=B[P];let U=V[P];if(U===void 0&&(P==="instanceMatrix"&&T.instanceMatrix&&(U=T.instanceMatrix),P==="instanceColor"&&T.instanceColor&&(U=T.instanceColor)),Z===void 0||Z.attribute!==U||U&&Z.data!==U.data)return!0;H++}return i.attributesNum!==H||i.index!==O}function g(T,I,$,O){const B={},V=I.attributes;let H=0;const q=$.getAttributes();for(const P in q)if(q[P].location>=0){let Z=V[P];Z===void 0&&(P==="instanceMatrix"&&T.instanceMatrix&&(Z=T.instanceMatrix),P==="instanceColor"&&T.instanceColor&&(Z=T.instanceColor));const U={};U.attribute=Z,Z&&Z.data&&(U.data=Z.data),B[P]=U,H++}i.attributes=B,i.attributesNum=H,i.index=O}function b(){const T=i.newAttributes;for(let I=0,$=T.length;I<$;I++)T[I]=0}function y(T){v(T,0)}function v(T,I){const $=i.newAttributes,O=i.enabledAttributes,B=i.attributeDivisors;$[T]=1,O[T]===0&&(n.enableVertexAttribArray(T),O[T]=1),B[T]!==I&&(n.vertexAttribDivisor(T,I),B[T]=I)}function S(){const T=i.newAttributes,I=i.enabledAttributes;for(let $=0,O=I.length;$<O;$++)I[$]!==T[$]&&(n.disableVertexAttribArray($),I[$]=0)}function C(T,I,$,O,B,V,H){H===!0?n.vertexAttribIPointer(T,I,$,B,V):n.vertexAttribPointer(T,I,$,O,B,V)}function _(T,I,$,O){b();const B=O.attributes,V=$.getAttributes(),H=I.defaultAttributeValues;for(const q in V){const P=V[q];if(P.location>=0){let K=B[q];if(K===void 0&&(q==="instanceMatrix"&&T.instanceMatrix&&(K=T.instanceMatrix),q==="instanceColor"&&T.instanceColor&&(K=T.instanceColor)),K!==void 0){const Z=K.normalized,U=K.itemSize,z=e.get(K);if(z===void 0)continue;const ne=z.buffer,Y=z.type,te=z.bytesPerElement,he=Y===n.INT||Y===n.UNSIGNED_INT||K.gpuType===nS;if(K.isInterleavedBufferAttribute){const se=K.data,Q=se.stride,de=K.offset;if(se.isInstancedInterleavedBuffer){for(let ce=0;ce<P.locationSize;ce++)v(P.location+ce,se.meshPerAttribute);T.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=se.meshPerAttribute*se.count)}else for(let ce=0;ce<P.locationSize;ce++)y(P.location+ce);n.bindBuffer(n.ARRAY_BUFFER,ne);for(let ce=0;ce<P.locationSize;ce++)C(P.location+ce,U/P.locationSize,Y,Z,Q*te,(de+U/P.locationSize*ce)*te,he)}else{if(K.isInstancedBufferAttribute){for(let se=0;se<P.locationSize;se++)v(P.location+se,K.meshPerAttribute);T.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=K.meshPerAttribute*K.count)}else for(let se=0;se<P.locationSize;se++)y(P.location+se);n.bindBuffer(n.ARRAY_BUFFER,ne);for(let se=0;se<P.locationSize;se++)C(P.location+se,U/P.locationSize,Y,Z,U*te,U/P.locationSize*se*te,he)}}else if(H!==void 0){const Z=H[q];if(Z!==void 0)switch(Z.length){case 2:n.vertexAttrib2fv(P.location,Z);break;case 3:n.vertexAttrib3fv(P.location,Z);break;case 4:n.vertexAttrib4fv(P.location,Z);break;default:n.vertexAttrib1fv(P.location,Z)}}}}S()}function A(){D();for(const T in s){const I=s[T];for(const $ in I){const O=I[$];for(const B in O)h(O[B].object),delete O[B];delete I[$]}delete s[T]}}function k(T){if(s[T.id]===void 0)return;const I=s[T.id];for(const $ in I){const O=I[$];for(const B in O)h(O[B].object),delete O[B];delete I[$]}delete s[T.id]}function N(T){for(const I in s){const $=s[I];if($[T.id]===void 0)continue;const O=$[T.id];for(const B in O)h(O[B].object),delete O[B];delete $[T.id]}}function D(){M(),o=!0,i!==r&&(i=r,c(i.object))}function M(){r.geometry=null,r.program=null,r.wireframe=!1}return{setup:a,reset:D,resetDefaultState:M,dispose:A,releaseStatesOfGeometry:k,releaseStatesOfProgram:N,initAttributes:b,enableAttribute:y,disableUnusedAttributes:S}}function XG(n,e,t){let s;function r(c){s=c}function i(c,h){n.drawArrays(s,c,h),t.update(h,s,1)}function o(c,h,d){d!==0&&(n.drawArraysInstanced(s,c,h,d),t.update(h,s,d))}function a(c,h,d){if(d===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(s,c,0,h,0,d);let m=0;for(let g=0;g<d;g++)m+=h[g];t.update(m,s,1)}function l(c,h,d,p){if(d===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let g=0;g<c.length;g++)o(c[g],h[g],p[g]);else{m.multiDrawArraysInstancedWEBGL(s,c,0,h,0,p,0,d);let g=0;for(let b=0;b<d;b++)g+=h[b]*p[b];t.update(g,s,1)}}this.setMode=r,this.render=i,this.renderInstances=o,this.renderMultiDraw=a,this.renderMultiDrawInstances=l}function jG(n,e,t,s){let r;function i(){if(r!==void 0)return r;if(e.has("EXT_texture_filter_anisotropic")===!0){const N=e.get("EXT_texture_filter_anisotropic");r=n.getParameter(N.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function o(N){return!(N!==Hr&&s.convert(N)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function a(N){const D=N===wd&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(N!==Ui&&s.convert(N)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&N!==oo&&!D)}function l(N){if(N==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";N="mediump"}return N==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=t.precision!==void 0?t.precision:"highp";const h=l(c);h!==c&&(console.warn("THREE.WebGLRenderer:",c,"not supported, using",h,"instead."),c=h);const d=t.logarithmicDepthBuffer===!0,p=t.reverseDepthBuffer===!0&&e.has("EXT_clip_control"),m=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),g=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),b=n.getParameter(n.MAX_TEXTURE_SIZE),y=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),v=n.getParameter(n.MAX_VERTEX_ATTRIBS),S=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),C=n.getParameter(n.MAX_VARYING_VECTORS),_=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),A=g>0,k=n.getParameter(n.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:i,getMaxPrecision:l,textureFormatReadable:o,textureTypeReadable:a,precision:c,logarithmicDepthBuffer:d,reverseDepthBuffer:p,maxTextures:m,maxVertexTextures:g,maxTextureSize:b,maxCubemapSize:y,maxAttributes:v,maxVertexUniforms:S,maxVaryings:C,maxFragmentUniforms:_,vertexTextures:A,maxSamples:k}}function qG(n){const e=this;let t=null,s=0,r=!1,i=!1;const o=new Il,a=new Ht,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(d,p){const m=d.length!==0||p||s!==0||r;return r=p,s=d.length,m},this.beginShadows=function(){i=!0,h(null)},this.endShadows=function(){i=!1},this.setGlobalState=function(d,p){t=h(d,p,0)},this.setState=function(d,p,m){const g=d.clippingPlanes,b=d.clipIntersection,y=d.clipShadows,v=n.get(d);if(!r||g===null||g.length===0||i&&!y)i?h(null):c();else{const S=i?0:s,C=S*4;let _=v.clippingState||null;l.value=_,_=h(g,p,C,m);for(let A=0;A!==C;++A)_[A]=t[A];v.clippingState=_,this.numIntersection=b?this.numPlanes:0,this.numPlanes+=S}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function h(d,p,m,g){const b=d!==null?d.length:0;let y=null;if(b!==0){if(y=l.value,g!==!0||y===null){const v=m+b*4,S=p.matrixWorldInverse;a.getNormalMatrix(S),(y===null||y.length<v)&&(y=new Float32Array(v));for(let C=0,_=m;C!==b;++C,_+=4)o.copy(d[C]).applyMatrix4(S,a),o.normal.toArray(y,_),y[_+3]=o.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=b,e.numIntersection=0,y}}function KG(n){let e=new WeakMap;function t(o,a){return a===b1?o.mapping=xu:a===S1&&(o.mapping=vu),o}function s(o){if(o&&o.isTexture){const a=o.mapping;if(a===b1||a===S1)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new KB(l.height);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",r),t(c.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function i(){e=new WeakMap}return{get:s,dispose:i}}const lu=4,vI=[.125,.215,.35,.446,.526,.582],kl=20,Dy=new dS,yI=new Gt;let $y=null,Fy=0,Ly=0,Py=!1;const Al=(1+Math.sqrt(5))/2,tu=1/Al,bI=[new Ce(-Al,tu,0),new Ce(Al,tu,0),new Ce(-tu,0,Al),new Ce(tu,0,Al),new Ce(0,Al,-tu),new Ce(0,Al,tu),new Ce(-1,1,-1),new Ce(1,1,-1),new Ce(-1,1,1),new Ce(1,1,1)],YG=new Ce;class lg{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,s=.1,r=100,i={}){const{size:o=256,position:a=YG}=i;$y=this._renderer.getRenderTarget(),Fy=this._renderer.getActiveCubeFace(),Ly=this._renderer.getActiveMipmapLevel(),Py=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(o);const l=this._allocateTargets();return l.depthBuffer=!0,this._sceneToCubeUV(e,s,r,l,a),t>0&&this._blur(l,0,0,t),this._applyPMREM(l),this._cleanup(l),l}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_I(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=wI(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget($y,Fy,Ly),this._renderer.xr.enabled=Py,e.scissorTest=!1,wm(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===xu||e.mapping===vu?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),$y=this._renderer.getRenderTarget(),Fy=this._renderer.getActiveCubeFace(),Ly=this._renderer.getActiveMipmapLevel(),Py=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const s=t||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,s={magFilter:io,minFilter:io,generateMipmaps:!1,type:wd,format:Hr,colorSpace:yu,depthBuffer:!1},r=SI(e,t,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=SI(e,t,s);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=ZG(i)),this._blurMaterial=QG(i,e,t)}return r}_compileMaterial(e){const t=new Os(this._lodPlanes[0],e);this._renderer.compile(t,Dy)}_sceneToCubeUV(e,t,s,r,i){const l=new Gr(90,1,t,s),c=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],d=this._renderer,p=d.autoClear,m=d.toneMapping;d.getClearColor(yI),d.toneMapping=$a,d.autoClear=!1;const g=new UM({name:"PMREM.Background",side:sr,depthWrite:!1,depthTest:!1}),b=new Os(new Wo,g);let y=!1;const v=e.background;v?v.isColor&&(g.color.copy(v),e.background=null,y=!0):(g.color.copy(yI),y=!0);for(let S=0;S<6;S++){const C=S%3;C===0?(l.up.set(0,c[S],0),l.position.set(i.x,i.y,i.z),l.lookAt(i.x+h[S],i.y,i.z)):C===1?(l.up.set(0,0,c[S]),l.position.set(i.x,i.y,i.z),l.lookAt(i.x,i.y+h[S],i.z)):(l.up.set(0,c[S],0),l.position.set(i.x,i.y,i.z),l.lookAt(i.x,i.y,i.z+h[S]));const _=this._cubeSize;wm(r,C*_,S>2?_:0,_,_),d.setRenderTarget(r),y&&d.render(b,l),d.render(e,l)}b.geometry.dispose(),b.material.dispose(),d.toneMapping=m,d.autoClear=p,e.background=v}_textureToCubeUV(e,t){const s=this._renderer,r=e.mapping===xu||e.mapping===vu;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=_I()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=wI());const i=r?this._cubemapMaterial:this._equirectMaterial,o=new Os(this._lodPlanes[0],i),a=i.uniforms;a.envMap.value=e;const l=this._cubeSize;wm(t,0,0,3*l,2*l),s.setRenderTarget(t),s.render(o,Dy)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;const r=this._lodPlanes.length;for(let i=1;i<r;i++){const o=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),a=bI[(r-i-1)%bI.length];this._blur(e,i-1,i,o,a)}t.autoClear=s}_blur(e,t,s,r,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,s,r,"latitudinal",i),this._halfBlur(o,e,s,s,r,"longitudinal",i)}_halfBlur(e,t,s,r,i,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,d=new Os(this._lodPlanes[r],c),p=c.uniforms,m=this._sizeLods[s]-1,g=isFinite(i)?Math.PI/(2*m):2*Math.PI/(2*kl-1),b=i/g,y=isFinite(i)?1+Math.floor(h*b):kl;y>kl&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${kl}`);const v=[];let S=0;for(let N=0;N<kl;++N){const D=N/b,M=Math.exp(-D*D/2);v.push(M),N===0?S+=M:N<y&&(S+=2*M)}for(let N=0;N<v.length;N++)v[N]=v[N]/S;p.envMap.value=e.texture,p.samples.value=y,p.weights.value=v,p.latitudinal.value=o==="latitudinal",a&&(p.poleAxis.value=a);const{_lodMax:C}=this;p.dTheta.value=g,p.mipInt.value=C-s;const _=this._sizeLods[r],A=3*_*(r>C-lu?r-C+lu:0),k=4*(this._cubeSize-_);wm(t,A,k,3*_,2*_),l.setRenderTarget(t),l.render(d,Dy)}}function ZG(n){const e=[],t=[],s=[];let r=n;const i=n-lu+1+vI.length;for(let o=0;o<i;o++){const a=Math.pow(2,r);t.push(a);let l=1/a;o>n-lu?l=vI[o-n+lu-1]:o===0&&(l=0),s.push(l);const c=1/(a-2),h=-c,d=1+c,p=[h,h,d,h,d,d,h,h,d,d,h,d],m=6,g=6,b=3,y=2,v=1,S=new Float32Array(b*g*m),C=new Float32Array(y*g*m),_=new Float32Array(v*g*m);for(let k=0;k<m;k++){const N=k%3*2/3-1,D=k>2?0:-1,M=[N,D,0,N+2/3,D,0,N+2/3,D+1,0,N,D,0,N+2/3,D+1,0,N,D+1,0];S.set(M,b*g*k),C.set(p,y*g*k);const T=[k,k,k,k,k,k];_.set(T,v*g*k)}const A=new fi;A.setAttribute("position",new $i(S,b)),A.setAttribute("uv",new $i(C,y)),A.setAttribute("faceIndex",new $i(_,v)),e.push(A),r>lu&&r--}return{lodPlanes:e,sizeLods:t,sigmas:s}}function SI(n,e,t){const s=new za(n,e,t);return s.texture.mapping=Hg,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function wm(n,e,t,s,r){n.viewport.set(e,t,s,r),n.scissor.set(e,t,s,r)}function QG(n,e,t){const s=new Float32Array(kl),r=new Ce(0,1,0);return new Fi({name:"SphericalGaussianBlur",defines:{n:kl,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:fS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Da,depthTest:!1,depthWrite:!1})}function wI(){return new Fi({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:fS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Da,depthTest:!1,depthWrite:!1})}function _I(){return new Fi({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:fS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Da,depthTest:!1,depthWrite:!1})}function fS(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function JG(n){let e=new WeakMap,t=null;function s(a){if(a&&a.isTexture){const l=a.mapping,c=l===b1||l===S1,h=l===xu||l===vu;if(c||h){let d=e.get(a);const p=d!==void 0?d.texture.pmremVersion:0;if(a.isRenderTargetTexture&&a.pmremVersion!==p)return t===null&&(t=new lg(n)),d=c?t.fromEquirectangular(a,d):t.fromCubemap(a,d),d.texture.pmremVersion=a.pmremVersion,e.set(a,d),d.texture;if(d!==void 0)return d.texture;{const m=a.image;return c&&m&&m.height>0||h&&m&&r(m)?(t===null&&(t=new lg(n)),d=c?t.fromEquirectangular(a):t.fromCubemap(a),d.texture.pmremVersion=a.pmremVersion,e.set(a,d),a.addEventListener("dispose",i),d.texture):null}}}return a}function r(a){let l=0;const c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}function i(a){const l=a.target;l.removeEventListener("dispose",i);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:o}}function eW(n){const e={};function t(s){if(e[s]!==void 0)return e[s];let r;switch(s){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(s)}return e[s]=r,r}return{has:function(s){return t(s)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(s){const r=t(s);return r===null&&Xm("THREE.WebGLRenderer: "+s+" extension not supported."),r}}}function tW(n,e,t,s){const r={},i=new WeakMap;function o(d){const p=d.target;p.index!==null&&e.remove(p.index);for(const g in p.attributes)e.remove(p.attributes[g]);p.removeEventListener("dispose",o),delete r[p.id];const m=i.get(p);m&&(e.remove(m),i.delete(p)),s.releaseStatesOfGeometry(p),p.isInstancedBufferGeometry===!0&&delete p._maxInstanceCount,t.memory.geometries--}function a(d,p){return r[p.id]===!0||(p.addEventListener("dispose",o),r[p.id]=!0,t.memory.geometries++),p}function l(d){const p=d.attributes;for(const m in p)e.update(p[m],n.ARRAY_BUFFER)}function c(d){const p=[],m=d.index,g=d.attributes.position;let b=0;if(m!==null){const S=m.array;b=m.version;for(let C=0,_=S.length;C<_;C+=3){const A=S[C+0],k=S[C+1],N=S[C+2];p.push(A,k,k,N,N,A)}}else if(g!==void 0){const S=g.array;b=g.version;for(let C=0,_=S.length/3-1;C<_;C+=3){const A=C+0,k=C+1,N=C+2;p.push(A,k,k,N,N,A)}}else return;const y=new($M(p)?BM:zM)(p,1);y.version=b;const v=i.get(d);v&&e.remove(v),i.set(d,y)}function h(d){const p=i.get(d);if(p){const m=d.index;m!==null&&p.version<m.version&&c(d)}else c(d);return i.get(d)}return{get:a,update:l,getWireframeAttribute:h}}function nW(n,e,t){let s;function r(p){s=p}let i,o;function a(p){i=p.type,o=p.bytesPerElement}function l(p,m){n.drawElements(s,m,i,p*o),t.update(m,s,1)}function c(p,m,g){g!==0&&(n.drawElementsInstanced(s,m,i,p*o,g),t.update(m,s,g))}function h(p,m,g){if(g===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(s,m,0,i,p,0,g);let y=0;for(let v=0;v<g;v++)y+=m[v];t.update(y,s,1)}function d(p,m,g,b){if(g===0)return;const y=e.get("WEBGL_multi_draw");if(y===null)for(let v=0;v<p.length;v++)c(p[v]/o,m[v],b[v]);else{y.multiDrawElementsInstancedWEBGL(s,m,0,i,p,0,b,0,g);let v=0;for(let S=0;S<g;S++)v+=m[S]*b[S];t.update(v,s,1)}}this.setMode=r,this.setIndex=a,this.render=l,this.renderInstances=c,this.renderMultiDraw=h,this.renderMultiDrawInstances=d}function sW(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(i,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(i/3);break;case n.LINES:t.lines+=a*(i/2);break;case n.LINE_STRIP:t.lines+=a*(i-1);break;case n.LINE_LOOP:t.lines+=a*i;break;case n.POINTS:t.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:s}}function rW(n,e,t){const s=new WeakMap,r=new Xn;function i(o,a,l){const c=o.morphTargetInfluences,h=a.morphAttributes.position||a.morphAttributes.normal||a.morphAttributes.color,d=h!==void 0?h.length:0;let p=s.get(a);if(p===void 0||p.count!==d){let T=function(){D.dispose(),s.delete(a),a.removeEventListener("dispose",T)};var m=T;p!==void 0&&p.texture.dispose();const g=a.morphAttributes.position!==void 0,b=a.morphAttributes.normal!==void 0,y=a.morphAttributes.color!==void 0,v=a.morphAttributes.position||[],S=a.morphAttributes.normal||[],C=a.morphAttributes.color||[];let _=0;g===!0&&(_=1),b===!0&&(_=2),y===!0&&(_=3);let A=a.attributes.position.count*_,k=1;A>e.maxTextureSize&&(k=Math.ceil(A/e.maxTextureSize),A=e.maxTextureSize);const N=new Float32Array(A*k*4*d),D=new FM(N,A,k,d);D.type=oo,D.needsUpdate=!0;const M=_*4;for(let I=0;I<d;I++){const $=v[I],O=S[I],B=C[I],V=A*k*4*I;for(let H=0;H<$.count;H++){const q=H*M;g===!0&&(r.fromBufferAttribute($,H),N[V+q+0]=r.x,N[V+q+1]=r.y,N[V+q+2]=r.z,N[V+q+3]=0),b===!0&&(r.fromBufferAttribute(O,H),N[V+q+4]=r.x,N[V+q+5]=r.y,N[V+q+6]=r.z,N[V+q+7]=0),y===!0&&(r.fromBufferAttribute(B,H),N[V+q+8]=r.x,N[V+q+9]=r.y,N[V+q+10]=r.z,N[V+q+11]=B.itemSize===4?r.w:1)}}p={count:d,texture:D,size:new gn(A,k)},s.set(a,p),a.addEventListener("dispose",T)}if(o.isInstancedMesh===!0&&o.morphTexture!==null)l.getUniforms().setValue(n,"morphTexture",o.morphTexture,t);else{let g=0;for(let y=0;y<c.length;y++)g+=c[y];const b=a.morphTargetsRelative?1:1-g;l.getUniforms().setValue(n,"morphTargetBaseInfluence",b),l.getUniforms().setValue(n,"morphTargetInfluences",c)}l.getUniforms().setValue(n,"morphTargetsTexture",p.texture,t),l.getUniforms().setValue(n,"morphTargetsTextureSize",p.size)}return{update:i}}function iW(n,e,t,s){let r=new WeakMap;function i(l){const c=s.render.frame,h=l.geometry,d=e.get(l,h);if(r.get(d)!==c&&(e.update(d),r.set(d,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),r.get(l)!==c&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),r.set(l,c))),l.isSkinnedMesh){const p=l.skeleton;r.get(p)!==c&&(p.update(),r.set(p,c))}return d}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:i,dispose:o}}const eR=new rr,CI=new jM(1,1),tR=new FM,nR=new NB,sR=new WM,EI=[],TI=[],II=new Float32Array(16),AI=new Float32Array(9),MI=new Float32Array(4);function Fu(n,e,t){const s=n[0];if(s<=0||s>0)return n;const r=e*t;let i=EI[r];if(i===void 0&&(i=new Float32Array(r),EI[r]=i),e!==0){s.toArray(i,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(i,a)}return i}function bs(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function Ss(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function jg(n,e){let t=TI[e];t===void 0&&(t=new Int32Array(e),TI[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function oW(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function aW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(bs(t,e))return;n.uniform2fv(this.addr,e),Ss(t,e)}}function lW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(bs(t,e))return;n.uniform3fv(this.addr,e),Ss(t,e)}}function cW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(bs(t,e))return;n.uniform4fv(this.addr,e),Ss(t,e)}}function uW(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(bs(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Ss(t,e)}else{if(bs(t,s))return;MI.set(s),n.uniformMatrix2fv(this.addr,!1,MI),Ss(t,s)}}function hW(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(bs(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Ss(t,e)}else{if(bs(t,s))return;AI.set(s),n.uniformMatrix3fv(this.addr,!1,AI),Ss(t,s)}}function dW(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(bs(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Ss(t,e)}else{if(bs(t,s))return;II.set(s),n.uniformMatrix4fv(this.addr,!1,II),Ss(t,s)}}function fW(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function pW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(bs(t,e))return;n.uniform2iv(this.addr,e),Ss(t,e)}}function mW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(bs(t,e))return;n.uniform3iv(this.addr,e),Ss(t,e)}}function gW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(bs(t,e))return;n.uniform4iv(this.addr,e),Ss(t,e)}}function xW(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function vW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(bs(t,e))return;n.uniform2uiv(this.addr,e),Ss(t,e)}}function yW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(bs(t,e))return;n.uniform3uiv(this.addr,e),Ss(t,e)}}function bW(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(bs(t,e))return;n.uniform4uiv(this.addr,e),Ss(t,e)}}function SW(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r);let i;this.type===n.SAMPLER_2D_SHADOW?(CI.compareFunction=DM,i=CI):i=eR,t.setTexture2D(e||i,r)}function wW(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTexture3D(e||nR,r)}function _W(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTextureCube(e||sR,r)}function CW(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTexture2DArray(e||tR,r)}function EW(n){switch(n){case 5126:return oW;case 35664:return aW;case 35665:return lW;case 35666:return cW;case 35674:return uW;case 35675:return hW;case 35676:return dW;case 5124:case 35670:return fW;case 35667:case 35671:return pW;case 35668:case 35672:return mW;case 35669:case 35673:return gW;case 5125:return xW;case 36294:return vW;case 36295:return yW;case 36296:return bW;case 35678:case 36198:case 36298:case 36306:case 35682:return SW;case 35679:case 36299:case 36307:return wW;case 35680:case 36300:case 36308:case 36293:return _W;case 36289:case 36303:case 36311:case 36292:return CW}}function TW(n,e){n.uniform1fv(this.addr,e)}function IW(n,e){const t=Fu(e,this.size,2);n.uniform2fv(this.addr,t)}function AW(n,e){const t=Fu(e,this.size,3);n.uniform3fv(this.addr,t)}function MW(n,e){const t=Fu(e,this.size,4);n.uniform4fv(this.addr,t)}function RW(n,e){const t=Fu(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function kW(n,e){const t=Fu(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function NW(n,e){const t=Fu(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function DW(n,e){n.uniform1iv(this.addr,e)}function $W(n,e){n.uniform2iv(this.addr,e)}function FW(n,e){n.uniform3iv(this.addr,e)}function LW(n,e){n.uniform4iv(this.addr,e)}function PW(n,e){n.uniform1uiv(this.addr,e)}function OW(n,e){n.uniform2uiv(this.addr,e)}function UW(n,e){n.uniform3uiv(this.addr,e)}function zW(n,e){n.uniform4uiv(this.addr,e)}function BW(n,e,t){const s=this.cache,r=e.length,i=jg(t,r);bs(s,i)||(n.uniform1iv(this.addr,i),Ss(s,i));for(let o=0;o!==r;++o)t.setTexture2D(e[o]||eR,i[o])}function VW(n,e,t){const s=this.cache,r=e.length,i=jg(t,r);bs(s,i)||(n.uniform1iv(this.addr,i),Ss(s,i));for(let o=0;o!==r;++o)t.setTexture3D(e[o]||nR,i[o])}function GW(n,e,t){const s=this.cache,r=e.length,i=jg(t,r);bs(s,i)||(n.uniform1iv(this.addr,i),Ss(s,i));for(let o=0;o!==r;++o)t.setTextureCube(e[o]||sR,i[o])}function WW(n,e,t){const s=this.cache,r=e.length,i=jg(t,r);bs(s,i)||(n.uniform1iv(this.addr,i),Ss(s,i));for(let o=0;o!==r;++o)t.setTexture2DArray(e[o]||tR,i[o])}function HW(n){switch(n){case 5126:return TW;case 35664:return IW;case 35665:return AW;case 35666:return MW;case 35674:return RW;case 35675:return kW;case 35676:return NW;case 5124:case 35670:return DW;case 35667:case 35671:return $W;case 35668:case 35672:return FW;case 35669:case 35673:return LW;case 5125:return PW;case 36294:return OW;case 36295:return UW;case 36296:return zW;case 35678:case 36198:case 36298:case 36306:case 35682:return BW;case 35679:case 36299:case 36307:return VW;case 35680:case 36300:case 36308:case 36293:return GW;case 36289:case 36303:case 36311:case 36292:return WW}}class XW{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.setValue=EW(t.type)}}class jW{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=HW(t.type)}}class qW{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,s){const r=this.seq;for(let i=0,o=r.length;i!==o;++i){const a=r[i];a.setValue(e,t[a.id],s)}}}const Oy=/(\w+)(\])?(\[|\.)?/g;function RI(n,e){n.seq.push(e),n.map[e.id]=e}function KW(n,e,t){const s=n.name,r=s.length;for(Oy.lastIndex=0;;){const i=Oy.exec(s),o=Oy.lastIndex;let a=i[1];const l=i[2]==="]",c=i[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){RI(t,c===void 0?new XW(a,n,e):new jW(a,n,e));break}else{let d=t.map[a];d===void 0&&(d=new qW(a),RI(t,d)),t=d}}}class jm{constructor(e,t){this.seq=[],this.map={};const s=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<s;++r){const i=e.getActiveUniform(t,r),o=e.getUniformLocation(t,i.name);KW(i,o,this)}}setValue(e,t,s,r){const i=this.map[t];i!==void 0&&i.setValue(e,s,r)}setOptional(e,t,s){const r=t[s];r!==void 0&&this.setValue(e,s,r)}static upload(e,t,s,r){for(let i=0,o=t.length;i!==o;++i){const a=t[i],l=s[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,r)}}static seqWithValue(e,t){const s=[];for(let r=0,i=e.length;r!==i;++r){const o=e[r];o.id in t&&s.push(o)}return s}}function kI(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}const YW=37297;let ZW=0;function QW(n,e){const t=n.split(`
`),s=[],r=Math.max(e-6,0),i=Math.min(e+6,t.length);for(let o=r;o<i;o++){const a=o+1;s.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return s.join(`
`)}const NI=new Ht;function JW(n){fn._getMatrix(NI,fn.workingColorSpace,n);const e=`mat3( ${NI.elements.map(t=>t.toFixed(4))} )`;switch(fn.getTransfer(n)){case rg:return[e,"LinearTransferOETF"];case wn:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",n),[e,"LinearTransferOETF"]}}function DI(n,e,t){const s=n.getShaderParameter(e,n.COMPILE_STATUS),r=n.getShaderInfoLog(e).trim();if(s&&r==="")return"";const i=/ERROR: 0:(\d+)/.exec(r);if(i){const o=parseInt(i[1]);return t.toUpperCase()+`

`+r+`

`+QW(n.getShaderSource(e),o)}else return r}function eH(n,e){const t=JW(e);return[`vec4 ${n}( vec4 value ) {`,`	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,"}"].join(`
`)}function tH(n,e){let t;switch(e){case rB:t="Linear";break;case iB:t="Reinhard";break;case oB:t="Cineon";break;case aB:t="ACESFilmic";break;case cB:t="AgX";break;case uB:t="Neutral";break;case lB:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const _m=new Ce;function nH(){fn.getLuminanceCoefficients(_m);const n=_m.x.toFixed(4),e=_m.y.toFixed(4),t=_m.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function sH(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Xh).join(`
`)}function rH(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function iH(n,e){const t={},s=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let r=0;r<s;r++){const i=n.getActiveAttrib(e,r),o=i.name;let a=1;i.type===n.FLOAT_MAT2&&(a=2),i.type===n.FLOAT_MAT3&&(a=3),i.type===n.FLOAT_MAT4&&(a=4),t[o]={type:i.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Xh(n){return n!==""}function $I(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function FI(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const oH=/^[ \t]*#include +<([\w\d./]+)>/gm;function Q1(n){return n.replace(oH,lH)}const aH=new Map;function lH(n,e){let t=Xt[e];if(t===void 0){const s=aH.get(e);if(s!==void 0)t=Xt[s],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return Q1(t)}const cH=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function LI(n){return n.replace(cH,uH)}function uH(n,e,t,s){let r="";for(let i=parseInt(e);i<parseInt(t);i++)r+=s.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return r}function PI(n){let e=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function hH(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===wM?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===tS?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Lo&&(e="SHADOWMAP_TYPE_VSM"),e}function dH(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case xu:case vu:e="ENVMAP_TYPE_CUBE";break;case Hg:e="ENVMAP_TYPE_CUBE_UV";break}return e}function fH(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case vu:e="ENVMAP_MODE_REFRACTION";break}return e}function pH(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case _M:e="ENVMAP_BLENDING_MULTIPLY";break;case nB:e="ENVMAP_BLENDING_MIX";break;case sB:e="ENVMAP_BLENDING_ADD";break}return e}function mH(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:s,maxMip:t}}function gH(n,e,t,s){const r=n.getContext(),i=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=hH(t),c=dH(t),h=fH(t),d=pH(t),p=mH(t),m=sH(t),g=rH(i),b=r.createProgram();let y,v,S=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g].filter(Xh).join(`
`),y.length>0&&(y+=`
`),v=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g].filter(Xh).join(`
`),v.length>0&&(v+=`
`)):(y=[PI(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Xh).join(`
`),v=[PI(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",t.envMap?"#define "+d:"",p?"#define CUBEUV_TEXEL_WIDTH "+p.texelWidth:"",p?"#define CUBEUV_TEXEL_HEIGHT "+p.texelHeight:"",p?"#define CUBEUV_MAX_MIP "+p.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==$a?"#define TONE_MAPPING":"",t.toneMapping!==$a?Xt.tonemapping_pars_fragment:"",t.toneMapping!==$a?tH("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Xt.colorspace_pars_fragment,eH("linearToOutputTexel",t.outputColorSpace),nH(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Xh).join(`
`)),o=Q1(o),o=$I(o,t),o=FI(o,t),a=Q1(a),a=$I(a,t),a=FI(a,t),o=LI(o),a=LI(a),t.isRawShaderMaterial!==!0&&(S=`#version 300 es
`,y=[m,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,v=["#define varying in",t.glslVersion===zT?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===zT?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);const C=S+y+o,_=S+v+a,A=kI(r,r.VERTEX_SHADER,C),k=kI(r,r.FRAGMENT_SHADER,_);r.attachShader(b,A),r.attachShader(b,k),t.index0AttributeName!==void 0?r.bindAttribLocation(b,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(b,0,"position"),r.linkProgram(b);function N(I){if(n.debug.checkShaderErrors){const $=r.getProgramInfoLog(b).trim(),O=r.getShaderInfoLog(A).trim(),B=r.getShaderInfoLog(k).trim();let V=!0,H=!0;if(r.getProgramParameter(b,r.LINK_STATUS)===!1)if(V=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(r,b,A,k);else{const q=DI(r,A,"vertex"),P=DI(r,k,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(b,r.VALIDATE_STATUS)+`

Material Name: `+I.name+`
Material Type: `+I.type+`

Program Info Log: `+$+`
`+q+`
`+P)}else $!==""?console.warn("THREE.WebGLProgram: Program Info Log:",$):(O===""||B==="")&&(H=!1);H&&(I.diagnostics={runnable:V,programLog:$,vertexShader:{log:O,prefix:y},fragmentShader:{log:B,prefix:v}})}r.deleteShader(A),r.deleteShader(k),D=new jm(r,b),M=iH(r,b)}let D;this.getUniforms=function(){return D===void 0&&N(this),D};let M;this.getAttributes=function(){return M===void 0&&N(this),M};let T=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return T===!1&&(T=r.getProgramParameter(b,YW)),T},this.destroy=function(){s.releaseStatesOfProgram(this),r.deleteProgram(b),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=ZW++,this.cacheKey=e,this.usedTimes=1,this.program=b,this.vertexShader=A,this.fragmentShader=k,this}let xH=0;class vH{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,s=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(s),o=this._getShaderCacheForMaterial(e);return o.has(r)===!1&&(o.add(r),r.usedTimes++),o.has(i)===!1&&(o.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const s of t)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let s=t.get(e);return s===void 0&&(s=new Set,t.set(e,s)),s}_getShaderStage(e){const t=this.shaderCache;let s=t.get(e);return s===void 0&&(s=new yH(e),t.set(e,s)),s}}class yH{constructor(e){this.id=xH++,this.code=e,this.usedTimes=0}}function bH(n,e,t,s,r,i,o){const a=new PM,l=new vH,c=new Set,h=[],d=r.logarithmicDepthBuffer,p=r.vertexTextures;let m=r.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function b(M){return c.add(M),M===0?"uv":`uv${M}`}function y(M,T,I,$,O){const B=$.fog,V=O.geometry,H=M.isMeshStandardMaterial?$.environment:null,q=(M.isMeshStandardMaterial?t:e).get(M.envMap||H),P=q&&q.mapping===Hg?q.image.height:null,K=g[M.type];M.precision!==null&&(m=r.getMaxPrecision(M.precision),m!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",m,"instead."));const Z=V.morphAttributes.position||V.morphAttributes.normal||V.morphAttributes.color,U=Z!==void 0?Z.length:0;let z=0;V.morphAttributes.position!==void 0&&(z=1),V.morphAttributes.normal!==void 0&&(z=2),V.morphAttributes.color!==void 0&&(z=3);let ne,Y,te,he;if(K){const tn=eo[K];ne=tn.vertexShader,Y=tn.fragmentShader}else ne=M.vertexShader,Y=M.fragmentShader,l.update(M),te=l.getVertexShaderID(M),he=l.getFragmentShaderID(M);const se=n.getRenderTarget(),Q=n.state.buffers.depth.getReversed(),de=O.isInstancedMesh===!0,ce=O.isBatchedMesh===!0,De=!!M.map,He=!!M.matcap,Le=!!q,j=!!M.aoMap,ht=!!M.lightMap,We=!!M.bumpMap,Ke=!!M.normalMap,Oe=!!M.displacementMap,yt=!!M.emissiveMap,Ve=!!M.metalnessMap,X=!!M.roughnessMap,L=M.anisotropy>0,ge=M.clearcoat>0,Re=M.dispersion>0,$e=M.iridescence>0,Ie=M.sheen>0,Xe=M.transmission>0,ze=L&&!!M.anisotropyMap,et=ge&&!!M.clearcoatMap,ut=ge&&!!M.clearcoatNormalMap,Pe=ge&&!!M.clearcoatRoughnessMap,lt=$e&&!!M.iridescenceMap,wt=$e&&!!M.iridescenceThicknessMap,Et=Ie&&!!M.sheenColorMap,ct=Ie&&!!M.sheenRoughnessMap,Ot=!!M.specularMap,$t=!!M.specularColorMap,hn=!!M.specularIntensityMap,ue=Xe&&!!M.transmissionMap,tt=Xe&&!!M.thicknessMap,ke=!!M.gradientMap,Fe=!!M.alphaMap,it=M.alphaTest>0,nt=!!M.alphaHash,Pt=!!M.extensions;let Sn=$a;M.toneMapped&&(se===null||se.isXRRenderTarget===!0)&&(Sn=n.toneMapping);const Jn={shaderID:K,shaderType:M.type,shaderName:M.name,vertexShader:ne,fragmentShader:Y,defines:M.defines,customVertexShaderID:te,customFragmentShaderID:he,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:m,batching:ce,batchingColor:ce&&O._colorsTexture!==null,instancing:de,instancingColor:de&&O.instanceColor!==null,instancingMorph:de&&O.morphTexture!==null,supportsVertexTextures:p,outputColorSpace:se===null?n.outputColorSpace:se.isXRRenderTarget===!0?se.texture.colorSpace:yu,alphaToCoverage:!!M.alphaToCoverage,map:De,matcap:He,envMap:Le,envMapMode:Le&&q.mapping,envMapCubeUVHeight:P,aoMap:j,lightMap:ht,bumpMap:We,normalMap:Ke,displacementMap:p&&Oe,emissiveMap:yt,normalMapObjectSpace:Ke&&M.normalMapType===pB,normalMapTangentSpace:Ke&&M.normalMapType===NM,metalnessMap:Ve,roughnessMap:X,anisotropy:L,anisotropyMap:ze,clearcoat:ge,clearcoatMap:et,clearcoatNormalMap:ut,clearcoatRoughnessMap:Pe,dispersion:Re,iridescence:$e,iridescenceMap:lt,iridescenceThicknessMap:wt,sheen:Ie,sheenColorMap:Et,sheenRoughnessMap:ct,specularMap:Ot,specularColorMap:$t,specularIntensityMap:hn,transmission:Xe,transmissionMap:ue,thicknessMap:tt,gradientMap:ke,opaque:M.transparent===!1&&M.blending===cu&&M.alphaToCoverage===!1,alphaMap:Fe,alphaTest:it,alphaHash:nt,combine:M.combine,mapUv:De&&b(M.map.channel),aoMapUv:j&&b(M.aoMap.channel),lightMapUv:ht&&b(M.lightMap.channel),bumpMapUv:We&&b(M.bumpMap.channel),normalMapUv:Ke&&b(M.normalMap.channel),displacementMapUv:Oe&&b(M.displacementMap.channel),emissiveMapUv:yt&&b(M.emissiveMap.channel),metalnessMapUv:Ve&&b(M.metalnessMap.channel),roughnessMapUv:X&&b(M.roughnessMap.channel),anisotropyMapUv:ze&&b(M.anisotropyMap.channel),clearcoatMapUv:et&&b(M.clearcoatMap.channel),clearcoatNormalMapUv:ut&&b(M.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Pe&&b(M.clearcoatRoughnessMap.channel),iridescenceMapUv:lt&&b(M.iridescenceMap.channel),iridescenceThicknessMapUv:wt&&b(M.iridescenceThicknessMap.channel),sheenColorMapUv:Et&&b(M.sheenColorMap.channel),sheenRoughnessMapUv:ct&&b(M.sheenRoughnessMap.channel),specularMapUv:Ot&&b(M.specularMap.channel),specularColorMapUv:$t&&b(M.specularColorMap.channel),specularIntensityMapUv:hn&&b(M.specularIntensityMap.channel),transmissionMapUv:ue&&b(M.transmissionMap.channel),thicknessMapUv:tt&&b(M.thicknessMap.channel),alphaMapUv:Fe&&b(M.alphaMap.channel),vertexTangents:!!V.attributes.tangent&&(Ke||L),vertexColors:M.vertexColors,vertexAlphas:M.vertexColors===!0&&!!V.attributes.color&&V.attributes.color.itemSize===4,pointsUvs:O.isPoints===!0&&!!V.attributes.uv&&(De||Fe),fog:!!B,useFog:M.fog===!0,fogExp2:!!B&&B.isFogExp2,flatShading:M.flatShading===!0,sizeAttenuation:M.sizeAttenuation===!0,logarithmicDepthBuffer:d,reverseDepthBuffer:Q,skinning:O.isSkinnedMesh===!0,morphTargets:V.morphAttributes.position!==void 0,morphNormals:V.morphAttributes.normal!==void 0,morphColors:V.morphAttributes.color!==void 0,morphTargetsCount:U,morphTextureStride:z,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numSpotLightMaps:T.spotLightMap.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numSpotLightShadowsWithMaps:T.numSpotLightShadowsWithMaps,numLightProbes:T.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:M.dithering,shadowMapEnabled:n.shadowMap.enabled&&I.length>0,shadowMapType:n.shadowMap.type,toneMapping:Sn,decodeVideoTexture:De&&M.map.isVideoTexture===!0&&fn.getTransfer(M.map.colorSpace)===wn,decodeVideoTextureEmissive:yt&&M.emissiveMap.isVideoTexture===!0&&fn.getTransfer(M.emissiveMap.colorSpace)===wn,premultipliedAlpha:M.premultipliedAlpha,doubleSided:M.side===Oo,flipSided:M.side===sr,useDepthPacking:M.depthPacking>=0,depthPacking:M.depthPacking||0,index0AttributeName:M.index0AttributeName,extensionClipCullDistance:Pt&&M.extensions.clipCullDistance===!0&&s.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Pt&&M.extensions.multiDraw===!0||ce)&&s.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:M.customProgramCacheKey()};return Jn.vertexUv1s=c.has(1),Jn.vertexUv2s=c.has(2),Jn.vertexUv3s=c.has(3),c.clear(),Jn}function v(M){const T=[];if(M.shaderID?T.push(M.shaderID):(T.push(M.customVertexShaderID),T.push(M.customFragmentShaderID)),M.defines!==void 0)for(const I in M.defines)T.push(I),T.push(M.defines[I]);return M.isRawShaderMaterial===!1&&(S(T,M),C(T,M),T.push(n.outputColorSpace)),T.push(M.customProgramCacheKey),T.join()}function S(M,T){M.push(T.precision),M.push(T.outputColorSpace),M.push(T.envMapMode),M.push(T.envMapCubeUVHeight),M.push(T.mapUv),M.push(T.alphaMapUv),M.push(T.lightMapUv),M.push(T.aoMapUv),M.push(T.bumpMapUv),M.push(T.normalMapUv),M.push(T.displacementMapUv),M.push(T.emissiveMapUv),M.push(T.metalnessMapUv),M.push(T.roughnessMapUv),M.push(T.anisotropyMapUv),M.push(T.clearcoatMapUv),M.push(T.clearcoatNormalMapUv),M.push(T.clearcoatRoughnessMapUv),M.push(T.iridescenceMapUv),M.push(T.iridescenceThicknessMapUv),M.push(T.sheenColorMapUv),M.push(T.sheenRoughnessMapUv),M.push(T.specularMapUv),M.push(T.specularColorMapUv),M.push(T.specularIntensityMapUv),M.push(T.transmissionMapUv),M.push(T.thicknessMapUv),M.push(T.combine),M.push(T.fogExp2),M.push(T.sizeAttenuation),M.push(T.morphTargetsCount),M.push(T.morphAttributeCount),M.push(T.numDirLights),M.push(T.numPointLights),M.push(T.numSpotLights),M.push(T.numSpotLightMaps),M.push(T.numHemiLights),M.push(T.numRectAreaLights),M.push(T.numDirLightShadows),M.push(T.numPointLightShadows),M.push(T.numSpotLightShadows),M.push(T.numSpotLightShadowsWithMaps),M.push(T.numLightProbes),M.push(T.shadowMapType),M.push(T.toneMapping),M.push(T.numClippingPlanes),M.push(T.numClipIntersection),M.push(T.depthPacking)}function C(M,T){a.disableAll(),T.supportsVertexTextures&&a.enable(0),T.instancing&&a.enable(1),T.instancingColor&&a.enable(2),T.instancingMorph&&a.enable(3),T.matcap&&a.enable(4),T.envMap&&a.enable(5),T.normalMapObjectSpace&&a.enable(6),T.normalMapTangentSpace&&a.enable(7),T.clearcoat&&a.enable(8),T.iridescence&&a.enable(9),T.alphaTest&&a.enable(10),T.vertexColors&&a.enable(11),T.vertexAlphas&&a.enable(12),T.vertexUv1s&&a.enable(13),T.vertexUv2s&&a.enable(14),T.vertexUv3s&&a.enable(15),T.vertexTangents&&a.enable(16),T.anisotropy&&a.enable(17),T.alphaHash&&a.enable(18),T.batching&&a.enable(19),T.dispersion&&a.enable(20),T.batchingColor&&a.enable(21),M.push(a.mask),a.disableAll(),T.fog&&a.enable(0),T.useFog&&a.enable(1),T.flatShading&&a.enable(2),T.logarithmicDepthBuffer&&a.enable(3),T.reverseDepthBuffer&&a.enable(4),T.skinning&&a.enable(5),T.morphTargets&&a.enable(6),T.morphNormals&&a.enable(7),T.morphColors&&a.enable(8),T.premultipliedAlpha&&a.enable(9),T.shadowMapEnabled&&a.enable(10),T.doubleSided&&a.enable(11),T.flipSided&&a.enable(12),T.useDepthPacking&&a.enable(13),T.dithering&&a.enable(14),T.transmission&&a.enable(15),T.sheen&&a.enable(16),T.opaque&&a.enable(17),T.pointsUvs&&a.enable(18),T.decodeVideoTexture&&a.enable(19),T.decodeVideoTextureEmissive&&a.enable(20),T.alphaToCoverage&&a.enable(21),M.push(a.mask)}function _(M){const T=g[M.type];let I;if(T){const $=eo[T];I=HB.clone($.uniforms)}else I=M.uniforms;return I}function A(M,T){let I;for(let $=0,O=h.length;$<O;$++){const B=h[$];if(B.cacheKey===T){I=B,++I.usedTimes;break}}return I===void 0&&(I=new gH(n,T,M,i),h.push(I)),I}function k(M){if(--M.usedTimes===0){const T=h.indexOf(M);h[T]=h[h.length-1],h.pop(),M.destroy()}}function N(M){l.remove(M)}function D(){l.dispose()}return{getParameters:y,getProgramCacheKey:v,getUniforms:_,acquireProgram:A,releaseProgram:k,releaseShaderCache:N,programs:h,dispose:D}}function SH(){let n=new WeakMap;function e(o){return n.has(o)}function t(o){let a=n.get(o);return a===void 0&&(a={},n.set(o,a)),a}function s(o){n.delete(o)}function r(o,a,l){n.get(o)[a]=l}function i(){n=new WeakMap}return{has:e,get:t,remove:s,update:r,dispose:i}}function wH(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function OI(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function UI(){const n=[];let e=0;const t=[],s=[],r=[];function i(){e=0,t.length=0,s.length=0,r.length=0}function o(d,p,m,g,b,y){let v=n[e];return v===void 0?(v={id:d.id,object:d,geometry:p,material:m,groupOrder:g,renderOrder:d.renderOrder,z:b,group:y},n[e]=v):(v.id=d.id,v.object=d,v.geometry=p,v.material=m,v.groupOrder=g,v.renderOrder=d.renderOrder,v.z=b,v.group=y),e++,v}function a(d,p,m,g,b,y){const v=o(d,p,m,g,b,y);m.transmission>0?s.push(v):m.transparent===!0?r.push(v):t.push(v)}function l(d,p,m,g,b,y){const v=o(d,p,m,g,b,y);m.transmission>0?s.unshift(v):m.transparent===!0?r.unshift(v):t.unshift(v)}function c(d,p){t.length>1&&t.sort(d||wH),s.length>1&&s.sort(p||OI),r.length>1&&r.sort(p||OI)}function h(){for(let d=e,p=n.length;d<p;d++){const m=n[d];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.group=null}}return{opaque:t,transmissive:s,transparent:r,init:i,push:a,unshift:l,finish:h,sort:c}}function _H(){let n=new WeakMap;function e(s,r){const i=n.get(s);let o;return i===void 0?(o=new UI,n.set(s,[o])):r>=i.length?(o=new UI,i.push(o)):o=i[r],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function CH(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Ce,color:new Gt};break;case"SpotLight":t={position:new Ce,direction:new Ce,color:new Gt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Ce,color:new Gt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Ce,skyColor:new Gt,groundColor:new Gt};break;case"RectAreaLight":t={color:new Gt,position:new Ce,halfWidth:new Ce,halfHeight:new Ce};break}return n[e.id]=t,t}}}function EH(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new gn};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new gn};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new gn,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let TH=0;function IH(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function AH(n){const e=new CH,t=EH(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)s.probe.push(new Ce);const r=new Ce,i=new An,o=new An;function a(c){let h=0,d=0,p=0;for(let M=0;M<9;M++)s.probe[M].set(0,0,0);let m=0,g=0,b=0,y=0,v=0,S=0,C=0,_=0,A=0,k=0,N=0;c.sort(IH);for(let M=0,T=c.length;M<T;M++){const I=c[M],$=I.color,O=I.intensity,B=I.distance,V=I.shadow&&I.shadow.map?I.shadow.map.texture:null;if(I.isAmbientLight)h+=$.r*O,d+=$.g*O,p+=$.b*O;else if(I.isLightProbe){for(let H=0;H<9;H++)s.probe[H].addScaledVector(I.sh.coefficients[H],O);N++}else if(I.isDirectionalLight){const H=e.get(I);if(H.color.copy(I.color).multiplyScalar(I.intensity),I.castShadow){const q=I.shadow,P=t.get(I);P.shadowIntensity=q.intensity,P.shadowBias=q.bias,P.shadowNormalBias=q.normalBias,P.shadowRadius=q.radius,P.shadowMapSize=q.mapSize,s.directionalShadow[m]=P,s.directionalShadowMap[m]=V,s.directionalShadowMatrix[m]=I.shadow.matrix,S++}s.directional[m]=H,m++}else if(I.isSpotLight){const H=e.get(I);H.position.setFromMatrixPosition(I.matrixWorld),H.color.copy($).multiplyScalar(O),H.distance=B,H.coneCos=Math.cos(I.angle),H.penumbraCos=Math.cos(I.angle*(1-I.penumbra)),H.decay=I.decay,s.spot[b]=H;const q=I.shadow;if(I.map&&(s.spotLightMap[A]=I.map,A++,q.updateMatrices(I),I.castShadow&&k++),s.spotLightMatrix[b]=q.matrix,I.castShadow){const P=t.get(I);P.shadowIntensity=q.intensity,P.shadowBias=q.bias,P.shadowNormalBias=q.normalBias,P.shadowRadius=q.radius,P.shadowMapSize=q.mapSize,s.spotShadow[b]=P,s.spotShadowMap[b]=V,_++}b++}else if(I.isRectAreaLight){const H=e.get(I);H.color.copy($).multiplyScalar(O),H.halfWidth.set(I.width*.5,0,0),H.halfHeight.set(0,I.height*.5,0),s.rectArea[y]=H,y++}else if(I.isPointLight){const H=e.get(I);if(H.color.copy(I.color).multiplyScalar(I.intensity),H.distance=I.distance,H.decay=I.decay,I.castShadow){const q=I.shadow,P=t.get(I);P.shadowIntensity=q.intensity,P.shadowBias=q.bias,P.shadowNormalBias=q.normalBias,P.shadowRadius=q.radius,P.shadowMapSize=q.mapSize,P.shadowCameraNear=q.camera.near,P.shadowCameraFar=q.camera.far,s.pointShadow[g]=P,s.pointShadowMap[g]=V,s.pointShadowMatrix[g]=I.shadow.matrix,C++}s.point[g]=H,g++}else if(I.isHemisphereLight){const H=e.get(I);H.skyColor.copy(I.color).multiplyScalar(O),H.groundColor.copy(I.groundColor).multiplyScalar(O),s.hemi[v]=H,v++}}y>0&&(n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=rt.LTC_FLOAT_1,s.rectAreaLTC2=rt.LTC_FLOAT_2):(s.rectAreaLTC1=rt.LTC_HALF_1,s.rectAreaLTC2=rt.LTC_HALF_2)),s.ambient[0]=h,s.ambient[1]=d,s.ambient[2]=p;const D=s.hash;(D.directionalLength!==m||D.pointLength!==g||D.spotLength!==b||D.rectAreaLength!==y||D.hemiLength!==v||D.numDirectionalShadows!==S||D.numPointShadows!==C||D.numSpotShadows!==_||D.numSpotMaps!==A||D.numLightProbes!==N)&&(s.directional.length=m,s.spot.length=b,s.rectArea.length=y,s.point.length=g,s.hemi.length=v,s.directionalShadow.length=S,s.directionalShadowMap.length=S,s.pointShadow.length=C,s.pointShadowMap.length=C,s.spotShadow.length=_,s.spotShadowMap.length=_,s.directionalShadowMatrix.length=S,s.pointShadowMatrix.length=C,s.spotLightMatrix.length=_+A-k,s.spotLightMap.length=A,s.numSpotLightShadowsWithMaps=k,s.numLightProbes=N,D.directionalLength=m,D.pointLength=g,D.spotLength=b,D.rectAreaLength=y,D.hemiLength=v,D.numDirectionalShadows=S,D.numPointShadows=C,D.numSpotShadows=_,D.numSpotMaps=A,D.numLightProbes=N,s.version=TH++)}function l(c,h){let d=0,p=0,m=0,g=0,b=0;const y=h.matrixWorldInverse;for(let v=0,S=c.length;v<S;v++){const C=c[v];if(C.isDirectionalLight){const _=s.directional[d];_.direction.setFromMatrixPosition(C.matrixWorld),r.setFromMatrixPosition(C.target.matrixWorld),_.direction.sub(r),_.direction.transformDirection(y),d++}else if(C.isSpotLight){const _=s.spot[m];_.position.setFromMatrixPosition(C.matrixWorld),_.position.applyMatrix4(y),_.direction.setFromMatrixPosition(C.matrixWorld),r.setFromMatrixPosition(C.target.matrixWorld),_.direction.sub(r),_.direction.transformDirection(y),m++}else if(C.isRectAreaLight){const _=s.rectArea[g];_.position.setFromMatrixPosition(C.matrixWorld),_.position.applyMatrix4(y),o.identity(),i.copy(C.matrixWorld),i.premultiply(y),o.extractRotation(i),_.halfWidth.set(C.width*.5,0,0),_.halfHeight.set(0,C.height*.5,0),_.halfWidth.applyMatrix4(o),_.halfHeight.applyMatrix4(o),g++}else if(C.isPointLight){const _=s.point[p];_.position.setFromMatrixPosition(C.matrixWorld),_.position.applyMatrix4(y),p++}else if(C.isHemisphereLight){const _=s.hemi[b];_.direction.setFromMatrixPosition(C.matrixWorld),_.direction.transformDirection(y),b++}}}return{setup:a,setupView:l,state:s}}function zI(n){const e=new AH(n),t=[],s=[];function r(h){c.camera=h,t.length=0,s.length=0}function i(h){t.push(h)}function o(h){s.push(h)}function a(){e.setup(t)}function l(h){e.setupView(t,h)}const c={lightsArray:t,shadowsArray:s,camera:null,lights:e,transmissionRenderTarget:{}};return{init:r,state:c,setupLights:a,setupLightsView:l,pushLight:i,pushShadow:o}}function MH(n){let e=new WeakMap;function t(r,i=0){const o=e.get(r);let a;return o===void 0?(a=new zI(n),e.set(r,[a])):i>=o.length?(a=new zI(n),o.push(a)):a=o[i],a}function s(){e=new WeakMap}return{get:t,dispose:s}}const RH=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,kH=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function NH(n,e,t){let s=new uS;const r=new gn,i=new gn,o=new Xn,a=new e4({depthPacking:fB}),l=new t4,c={},h=t.maxTextureSize,d={[Ua]:sr,[sr]:Ua,[Oo]:Oo},p=new Fi({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new gn},radius:{value:4}},vertexShader:RH,fragmentShader:kH}),m=p.clone();m.defines.HORIZONTAL_PASS=1;const g=new fi;g.setAttribute("position",new $i(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new Os(g,p),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=wM;let v=this.type;this.render=function(k,N,D){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||k.length===0)return;const M=n.getRenderTarget(),T=n.getActiveCubeFace(),I=n.getActiveMipmapLevel(),$=n.state;$.setBlending(Da),$.buffers.color.setClear(1,1,1,1),$.buffers.depth.setTest(!0),$.setScissorTest(!1);const O=v!==Lo&&this.type===Lo,B=v===Lo&&this.type!==Lo;for(let V=0,H=k.length;V<H;V++){const q=k[V],P=q.shadow;if(P===void 0){console.warn("THREE.WebGLShadowMap:",q,"has no shadow.");continue}if(P.autoUpdate===!1&&P.needsUpdate===!1)continue;r.copy(P.mapSize);const K=P.getFrameExtents();if(r.multiply(K),i.copy(P.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(i.x=Math.floor(h/K.x),r.x=i.x*K.x,P.mapSize.x=i.x),r.y>h&&(i.y=Math.floor(h/K.y),r.y=i.y*K.y,P.mapSize.y=i.y)),P.map===null||O===!0||B===!0){const U=this.type!==Lo?{minFilter:mr,magFilter:mr}:{};P.map!==null&&P.map.dispose(),P.map=new za(r.x,r.y,U),P.map.texture.name=q.name+".shadowMap",P.camera.updateProjectionMatrix()}n.setRenderTarget(P.map),n.clear();const Z=P.getViewportCount();for(let U=0;U<Z;U++){const z=P.getViewport(U);o.set(i.x*z.x,i.y*z.y,i.x*z.z,i.y*z.w),$.viewport(o),P.updateMatrices(q,U),s=P.getFrustum(),_(N,D,P.camera,q,this.type)}P.isPointLightShadow!==!0&&this.type===Lo&&S(P,D),P.needsUpdate=!1}v=this.type,y.needsUpdate=!1,n.setRenderTarget(M,T,I)};function S(k,N){const D=e.update(b);p.defines.VSM_SAMPLES!==k.blurSamples&&(p.defines.VSM_SAMPLES=k.blurSamples,m.defines.VSM_SAMPLES=k.blurSamples,p.needsUpdate=!0,m.needsUpdate=!0),k.mapPass===null&&(k.mapPass=new za(r.x,r.y)),p.uniforms.shadow_pass.value=k.map.texture,p.uniforms.resolution.value=k.mapSize,p.uniforms.radius.value=k.radius,n.setRenderTarget(k.mapPass),n.clear(),n.renderBufferDirect(N,null,D,p,b,null),m.uniforms.shadow_pass.value=k.mapPass.texture,m.uniforms.resolution.value=k.mapSize,m.uniforms.radius.value=k.radius,n.setRenderTarget(k.map),n.clear(),n.renderBufferDirect(N,null,D,m,b,null)}function C(k,N,D,M){let T=null;const I=D.isPointLight===!0?k.customDistanceMaterial:k.customDepthMaterial;if(I!==void 0)T=I;else if(T=D.isPointLight===!0?l:a,n.localClippingEnabled&&N.clipShadows===!0&&Array.isArray(N.clippingPlanes)&&N.clippingPlanes.length!==0||N.displacementMap&&N.displacementScale!==0||N.alphaMap&&N.alphaTest>0||N.map&&N.alphaTest>0||N.alphaToCoverage===!0){const $=T.uuid,O=N.uuid;let B=c[$];B===void 0&&(B={},c[$]=B);let V=B[O];V===void 0&&(V=T.clone(),B[O]=V,N.addEventListener("dispose",A)),T=V}if(T.visible=N.visible,T.wireframe=N.wireframe,M===Lo?T.side=N.shadowSide!==null?N.shadowSide:N.side:T.side=N.shadowSide!==null?N.shadowSide:d[N.side],T.alphaMap=N.alphaMap,T.alphaTest=N.alphaToCoverage===!0?.5:N.alphaTest,T.map=N.map,T.clipShadows=N.clipShadows,T.clippingPlanes=N.clippingPlanes,T.clipIntersection=N.clipIntersection,T.displacementMap=N.displacementMap,T.displacementScale=N.displacementScale,T.displacementBias=N.displacementBias,T.wireframeLinewidth=N.wireframeLinewidth,T.linewidth=N.linewidth,D.isPointLight===!0&&T.isMeshDistanceMaterial===!0){const $=n.properties.get(T);$.light=D}return T}function _(k,N,D,M,T){if(k.visible===!1)return;if(k.layers.test(N.layers)&&(k.isMesh||k.isLine||k.isPoints)&&(k.castShadow||k.receiveShadow&&T===Lo)&&(!k.frustumCulled||s.intersectsObject(k))){k.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse,k.matrixWorld);const O=e.update(k),B=k.material;if(Array.isArray(B)){const V=O.groups;for(let H=0,q=V.length;H<q;H++){const P=V[H],K=B[P.materialIndex];if(K&&K.visible){const Z=C(k,K,M,T);k.onBeforeShadow(n,k,N,D,O,Z,P),n.renderBufferDirect(D,null,O,Z,k,P),k.onAfterShadow(n,k,N,D,O,Z,P)}}}else if(B.visible){const V=C(k,B,M,T);k.onBeforeShadow(n,k,N,D,O,V,null),n.renderBufferDirect(D,null,O,V,k,null),k.onAfterShadow(n,k,N,D,O,V,null)}}const $=k.children;for(let O=0,B=$.length;O<B;O++)_($[O],N,D,M,T)}function A(k){k.target.removeEventListener("dispose",A);for(const D in c){const M=c[D],T=k.target.uuid;T in M&&(M[T].dispose(),delete M[T])}}}const DH={[f1]:p1,[m1]:v1,[g1]:y1,[gu]:x1,[p1]:f1,[v1]:m1,[y1]:g1,[x1]:gu};function $H(n,e){function t(){let ue=!1;const tt=new Xn;let ke=null;const Fe=new Xn(0,0,0,0);return{setMask:function(it){ke!==it&&!ue&&(n.colorMask(it,it,it,it),ke=it)},setLocked:function(it){ue=it},setClear:function(it,nt,Pt,Sn,Jn){Jn===!0&&(it*=Sn,nt*=Sn,Pt*=Sn),tt.set(it,nt,Pt,Sn),Fe.equals(tt)===!1&&(n.clearColor(it,nt,Pt,Sn),Fe.copy(tt))},reset:function(){ue=!1,ke=null,Fe.set(-1,0,0,0)}}}function s(){let ue=!1,tt=!1,ke=null,Fe=null,it=null;return{setReversed:function(nt){if(tt!==nt){const Pt=e.get("EXT_clip_control");nt?Pt.clipControlEXT(Pt.LOWER_LEFT_EXT,Pt.ZERO_TO_ONE_EXT):Pt.clipControlEXT(Pt.LOWER_LEFT_EXT,Pt.NEGATIVE_ONE_TO_ONE_EXT),tt=nt;const Sn=it;it=null,this.setClear(Sn)}},getReversed:function(){return tt},setTest:function(nt){nt?se(n.DEPTH_TEST):Q(n.DEPTH_TEST)},setMask:function(nt){ke!==nt&&!ue&&(n.depthMask(nt),ke=nt)},setFunc:function(nt){if(tt&&(nt=DH[nt]),Fe!==nt){switch(nt){case f1:n.depthFunc(n.NEVER);break;case p1:n.depthFunc(n.ALWAYS);break;case m1:n.depthFunc(n.LESS);break;case gu:n.depthFunc(n.LEQUAL);break;case g1:n.depthFunc(n.EQUAL);break;case x1:n.depthFunc(n.GEQUAL);break;case v1:n.depthFunc(n.GREATER);break;case y1:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}Fe=nt}},setLocked:function(nt){ue=nt},setClear:function(nt){it!==nt&&(tt&&(nt=1-nt),n.clearDepth(nt),it=nt)},reset:function(){ue=!1,ke=null,Fe=null,it=null,tt=!1}}}function r(){let ue=!1,tt=null,ke=null,Fe=null,it=null,nt=null,Pt=null,Sn=null,Jn=null;return{setTest:function(tn){ue||(tn?se(n.STENCIL_TEST):Q(n.STENCIL_TEST))},setMask:function(tn){tt!==tn&&!ue&&(n.stencilMask(tn),tt=tn)},setFunc:function(tn,Cn,Ye){(ke!==tn||Fe!==Cn||it!==Ye)&&(n.stencilFunc(tn,Cn,Ye),ke=tn,Fe=Cn,it=Ye)},setOp:function(tn,Cn,Ye){(nt!==tn||Pt!==Cn||Sn!==Ye)&&(n.stencilOp(tn,Cn,Ye),nt=tn,Pt=Cn,Sn=Ye)},setLocked:function(tn){ue=tn},setClear:function(tn){Jn!==tn&&(n.clearStencil(tn),Jn=tn)},reset:function(){ue=!1,tt=null,ke=null,Fe=null,it=null,nt=null,Pt=null,Sn=null,Jn=null}}}const i=new t,o=new s,a=new r,l=new WeakMap,c=new WeakMap;let h={},d={},p=new WeakMap,m=[],g=null,b=!1,y=null,v=null,S=null,C=null,_=null,A=null,k=null,N=new Gt(0,0,0),D=0,M=!1,T=null,I=null,$=null,O=null,B=null;const V=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let H=!1,q=0;const P=n.getParameter(n.VERSION);P.indexOf("WebGL")!==-1?(q=parseFloat(/^WebGL (\d)/.exec(P)[1]),H=q>=1):P.indexOf("OpenGL ES")!==-1&&(q=parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),H=q>=2);let K=null,Z={};const U=n.getParameter(n.SCISSOR_BOX),z=n.getParameter(n.VIEWPORT),ne=new Xn().fromArray(U),Y=new Xn().fromArray(z);function te(ue,tt,ke,Fe){const it=new Uint8Array(4),nt=n.createTexture();n.bindTexture(ue,nt),n.texParameteri(ue,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(ue,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let Pt=0;Pt<ke;Pt++)ue===n.TEXTURE_3D||ue===n.TEXTURE_2D_ARRAY?n.texImage3D(tt,0,n.RGBA,1,1,Fe,0,n.RGBA,n.UNSIGNED_BYTE,it):n.texImage2D(tt+Pt,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,it);return nt}const he={};he[n.TEXTURE_2D]=te(n.TEXTURE_2D,n.TEXTURE_2D,1),he[n.TEXTURE_CUBE_MAP]=te(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),he[n.TEXTURE_2D_ARRAY]=te(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),he[n.TEXTURE_3D]=te(n.TEXTURE_3D,n.TEXTURE_3D,1,1),i.setClear(0,0,0,1),o.setClear(1),a.setClear(0),se(n.DEPTH_TEST),o.setFunc(gu),We(!1),Ke($T),se(n.CULL_FACE),j(Da);function se(ue){h[ue]!==!0&&(n.enable(ue),h[ue]=!0)}function Q(ue){h[ue]!==!1&&(n.disable(ue),h[ue]=!1)}function de(ue,tt){return d[ue]!==tt?(n.bindFramebuffer(ue,tt),d[ue]=tt,ue===n.DRAW_FRAMEBUFFER&&(d[n.FRAMEBUFFER]=tt),ue===n.FRAMEBUFFER&&(d[n.DRAW_FRAMEBUFFER]=tt),!0):!1}function ce(ue,tt){let ke=m,Fe=!1;if(ue){ke=p.get(tt),ke===void 0&&(ke=[],p.set(tt,ke));const it=ue.textures;if(ke.length!==it.length||ke[0]!==n.COLOR_ATTACHMENT0){for(let nt=0,Pt=it.length;nt<Pt;nt++)ke[nt]=n.COLOR_ATTACHMENT0+nt;ke.length=it.length,Fe=!0}}else ke[0]!==n.BACK&&(ke[0]=n.BACK,Fe=!0);Fe&&n.drawBuffers(ke)}function De(ue){return g!==ue?(n.useProgram(ue),g=ue,!0):!1}const He={[Rl]:n.FUNC_ADD,[Uz]:n.FUNC_SUBTRACT,[zz]:n.FUNC_REVERSE_SUBTRACT};He[Bz]=n.MIN,He[Vz]=n.MAX;const Le={[Gz]:n.ZERO,[Wz]:n.ONE,[Hz]:n.SRC_COLOR,[h1]:n.SRC_ALPHA,[Zz]:n.SRC_ALPHA_SATURATE,[Kz]:n.DST_COLOR,[jz]:n.DST_ALPHA,[Xz]:n.ONE_MINUS_SRC_COLOR,[d1]:n.ONE_MINUS_SRC_ALPHA,[Yz]:n.ONE_MINUS_DST_COLOR,[qz]:n.ONE_MINUS_DST_ALPHA,[Qz]:n.CONSTANT_COLOR,[Jz]:n.ONE_MINUS_CONSTANT_COLOR,[eB]:n.CONSTANT_ALPHA,[tB]:n.ONE_MINUS_CONSTANT_ALPHA};function j(ue,tt,ke,Fe,it,nt,Pt,Sn,Jn,tn){if(ue===Da){b===!0&&(Q(n.BLEND),b=!1);return}if(b===!1&&(se(n.BLEND),b=!0),ue!==Oz){if(ue!==y||tn!==M){if((v!==Rl||_!==Rl)&&(n.blendEquation(n.FUNC_ADD),v=Rl,_=Rl),tn)switch(ue){case cu:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case FT:n.blendFunc(n.ONE,n.ONE);break;case LT:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case PT:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",ue);break}else switch(ue){case cu:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case FT:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case LT:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case PT:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",ue);break}S=null,C=null,A=null,k=null,N.set(0,0,0),D=0,y=ue,M=tn}return}it=it||tt,nt=nt||ke,Pt=Pt||Fe,(tt!==v||it!==_)&&(n.blendEquationSeparate(He[tt],He[it]),v=tt,_=it),(ke!==S||Fe!==C||nt!==A||Pt!==k)&&(n.blendFuncSeparate(Le[ke],Le[Fe],Le[nt],Le[Pt]),S=ke,C=Fe,A=nt,k=Pt),(Sn.equals(N)===!1||Jn!==D)&&(n.blendColor(Sn.r,Sn.g,Sn.b,Jn),N.copy(Sn),D=Jn),y=ue,M=!1}function ht(ue,tt){ue.side===Oo?Q(n.CULL_FACE):se(n.CULL_FACE);let ke=ue.side===sr;tt&&(ke=!ke),We(ke),ue.blending===cu&&ue.transparent===!1?j(Da):j(ue.blending,ue.blendEquation,ue.blendSrc,ue.blendDst,ue.blendEquationAlpha,ue.blendSrcAlpha,ue.blendDstAlpha,ue.blendColor,ue.blendAlpha,ue.premultipliedAlpha),o.setFunc(ue.depthFunc),o.setTest(ue.depthTest),o.setMask(ue.depthWrite),i.setMask(ue.colorWrite);const Fe=ue.stencilWrite;a.setTest(Fe),Fe&&(a.setMask(ue.stencilWriteMask),a.setFunc(ue.stencilFunc,ue.stencilRef,ue.stencilFuncMask),a.setOp(ue.stencilFail,ue.stencilZFail,ue.stencilZPass)),yt(ue.polygonOffset,ue.polygonOffsetFactor,ue.polygonOffsetUnits),ue.alphaToCoverage===!0?se(n.SAMPLE_ALPHA_TO_COVERAGE):Q(n.SAMPLE_ALPHA_TO_COVERAGE)}function We(ue){T!==ue&&(ue?n.frontFace(n.CW):n.frontFace(n.CCW),T=ue)}function Ke(ue){ue!==Lz?(se(n.CULL_FACE),ue!==I&&(ue===$T?n.cullFace(n.BACK):ue===Pz?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):Q(n.CULL_FACE),I=ue}function Oe(ue){ue!==$&&(H&&n.lineWidth(ue),$=ue)}function yt(ue,tt,ke){ue?(se(n.POLYGON_OFFSET_FILL),(O!==tt||B!==ke)&&(n.polygonOffset(tt,ke),O=tt,B=ke)):Q(n.POLYGON_OFFSET_FILL)}function Ve(ue){ue?se(n.SCISSOR_TEST):Q(n.SCISSOR_TEST)}function X(ue){ue===void 0&&(ue=n.TEXTURE0+V-1),K!==ue&&(n.activeTexture(ue),K=ue)}function L(ue,tt,ke){ke===void 0&&(K===null?ke=n.TEXTURE0+V-1:ke=K);let Fe=Z[ke];Fe===void 0&&(Fe={type:void 0,texture:void 0},Z[ke]=Fe),(Fe.type!==ue||Fe.texture!==tt)&&(K!==ke&&(n.activeTexture(ke),K=ke),n.bindTexture(ue,tt||he[ue]),Fe.type=ue,Fe.texture=tt)}function ge(){const ue=Z[K];ue!==void 0&&ue.type!==void 0&&(n.bindTexture(ue.type,null),ue.type=void 0,ue.texture=void 0)}function Re(){try{n.compressedTexImage2D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function $e(){try{n.compressedTexImage3D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function Ie(){try{n.texSubImage2D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function Xe(){try{n.texSubImage3D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function ze(){try{n.compressedTexSubImage2D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function et(){try{n.compressedTexSubImage3D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function ut(){try{n.texStorage2D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function Pe(){try{n.texStorage3D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function lt(){try{n.texImage2D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function wt(){try{n.texImage3D(...arguments)}catch(ue){console.error("THREE.WebGLState:",ue)}}function Et(ue){ne.equals(ue)===!1&&(n.scissor(ue.x,ue.y,ue.z,ue.w),ne.copy(ue))}function ct(ue){Y.equals(ue)===!1&&(n.viewport(ue.x,ue.y,ue.z,ue.w),Y.copy(ue))}function Ot(ue,tt){let ke=c.get(tt);ke===void 0&&(ke=new WeakMap,c.set(tt,ke));let Fe=ke.get(ue);Fe===void 0&&(Fe=n.getUniformBlockIndex(tt,ue.name),ke.set(ue,Fe))}function $t(ue,tt){const Fe=c.get(tt).get(ue);l.get(tt)!==Fe&&(n.uniformBlockBinding(tt,Fe,ue.__bindingPointIndex),l.set(tt,Fe))}function hn(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),o.setReversed(!1),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},K=null,Z={},d={},p=new WeakMap,m=[],g=null,b=!1,y=null,v=null,S=null,C=null,_=null,A=null,k=null,N=new Gt(0,0,0),D=0,M=!1,T=null,I=null,$=null,O=null,B=null,ne.set(0,0,n.canvas.width,n.canvas.height),Y.set(0,0,n.canvas.width,n.canvas.height),i.reset(),o.reset(),a.reset()}return{buffers:{color:i,depth:o,stencil:a},enable:se,disable:Q,bindFramebuffer:de,drawBuffers:ce,useProgram:De,setBlending:j,setMaterial:ht,setFlipSided:We,setCullFace:Ke,setLineWidth:Oe,setPolygonOffset:yt,setScissorTest:Ve,activeTexture:X,bindTexture:L,unbindTexture:ge,compressedTexImage2D:Re,compressedTexImage3D:$e,texImage2D:lt,texImage3D:wt,updateUBOMapping:Ot,uniformBlockBinding:$t,texStorage2D:ut,texStorage3D:Pe,texSubImage2D:Ie,texSubImage3D:Xe,compressedTexSubImage2D:ze,compressedTexSubImage3D:et,scissor:Et,viewport:ct,reset:hn}}function FH(n,e,t,s,r,i,o){const a=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new gn,h=new WeakMap;let d;const p=new WeakMap;let m=!1;try{m=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(X,L){return m?new OffscreenCanvas(X,L):od("canvas")}function b(X,L,ge){let Re=1;const $e=Ve(X);if(($e.width>ge||$e.height>ge)&&(Re=ge/Math.max($e.width,$e.height)),Re<1)if(typeof HTMLImageElement<"u"&&X instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&X instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&X instanceof ImageBitmap||typeof VideoFrame<"u"&&X instanceof VideoFrame){const Ie=Math.floor(Re*$e.width),Xe=Math.floor(Re*$e.height);d===void 0&&(d=g(Ie,Xe));const ze=L?g(Ie,Xe):d;return ze.width=Ie,ze.height=Xe,ze.getContext("2d").drawImage(X,0,0,Ie,Xe),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+$e.width+"x"+$e.height+") to ("+Ie+"x"+Xe+")."),ze}else return"data"in X&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+$e.width+"x"+$e.height+")."),X;return X}function y(X){return X.generateMipmaps}function v(X){n.generateMipmap(X)}function S(X){return X.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:X.isWebGL3DRenderTarget?n.TEXTURE_3D:X.isWebGLArrayRenderTarget||X.isCompressedArrayTexture?n.TEXTURE_2D_ARRAY:n.TEXTURE_2D}function C(X,L,ge,Re,$e=!1){if(X!==null){if(n[X]!==void 0)return n[X];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+X+"'")}let Ie=L;if(L===n.RED&&(ge===n.FLOAT&&(Ie=n.R32F),ge===n.HALF_FLOAT&&(Ie=n.R16F),ge===n.UNSIGNED_BYTE&&(Ie=n.R8)),L===n.RED_INTEGER&&(ge===n.UNSIGNED_BYTE&&(Ie=n.R8UI),ge===n.UNSIGNED_SHORT&&(Ie=n.R16UI),ge===n.UNSIGNED_INT&&(Ie=n.R32UI),ge===n.BYTE&&(Ie=n.R8I),ge===n.SHORT&&(Ie=n.R16I),ge===n.INT&&(Ie=n.R32I)),L===n.RG&&(ge===n.FLOAT&&(Ie=n.RG32F),ge===n.HALF_FLOAT&&(Ie=n.RG16F),ge===n.UNSIGNED_BYTE&&(Ie=n.RG8)),L===n.RG_INTEGER&&(ge===n.UNSIGNED_BYTE&&(Ie=n.RG8UI),ge===n.UNSIGNED_SHORT&&(Ie=n.RG16UI),ge===n.UNSIGNED_INT&&(Ie=n.RG32UI),ge===n.BYTE&&(Ie=n.RG8I),ge===n.SHORT&&(Ie=n.RG16I),ge===n.INT&&(Ie=n.RG32I)),L===n.RGB_INTEGER&&(ge===n.UNSIGNED_BYTE&&(Ie=n.RGB8UI),ge===n.UNSIGNED_SHORT&&(Ie=n.RGB16UI),ge===n.UNSIGNED_INT&&(Ie=n.RGB32UI),ge===n.BYTE&&(Ie=n.RGB8I),ge===n.SHORT&&(Ie=n.RGB16I),ge===n.INT&&(Ie=n.RGB32I)),L===n.RGBA_INTEGER&&(ge===n.UNSIGNED_BYTE&&(Ie=n.RGBA8UI),ge===n.UNSIGNED_SHORT&&(Ie=n.RGBA16UI),ge===n.UNSIGNED_INT&&(Ie=n.RGBA32UI),ge===n.BYTE&&(Ie=n.RGBA8I),ge===n.SHORT&&(Ie=n.RGBA16I),ge===n.INT&&(Ie=n.RGBA32I)),L===n.RGB&&ge===n.UNSIGNED_INT_5_9_9_9_REV&&(Ie=n.RGB9_E5),L===n.RGBA){const Xe=$e?rg:fn.getTransfer(Re);ge===n.FLOAT&&(Ie=n.RGBA32F),ge===n.HALF_FLOAT&&(Ie=n.RGBA16F),ge===n.UNSIGNED_BYTE&&(Ie=Xe===wn?n.SRGB8_ALPHA8:n.RGBA8),ge===n.UNSIGNED_SHORT_4_4_4_4&&(Ie=n.RGBA4),ge===n.UNSIGNED_SHORT_5_5_5_1&&(Ie=n.RGB5_A1)}return(Ie===n.R16F||Ie===n.R32F||Ie===n.RG16F||Ie===n.RG32F||Ie===n.RGBA16F||Ie===n.RGBA32F)&&e.get("EXT_color_buffer_float"),Ie}function _(X,L){let ge;return X?L===null||L===Wl||L===sd?ge=n.DEPTH24_STENCIL8:L===oo?ge=n.DEPTH32F_STENCIL8:L===nd&&(ge=n.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):L===null||L===Wl||L===sd?ge=n.DEPTH_COMPONENT24:L===oo?ge=n.DEPTH_COMPONENT32F:L===nd&&(ge=n.DEPTH_COMPONENT16),ge}function A(X,L){return y(X)===!0||X.isFramebufferTexture&&X.minFilter!==mr&&X.minFilter!==io?Math.log2(Math.max(L.width,L.height))+1:X.mipmaps!==void 0&&X.mipmaps.length>0?X.mipmaps.length:X.isCompressedTexture&&Array.isArray(X.image)?L.mipmaps.length:1}function k(X){const L=X.target;L.removeEventListener("dispose",k),D(L),L.isVideoTexture&&h.delete(L)}function N(X){const L=X.target;L.removeEventListener("dispose",N),T(L)}function D(X){const L=s.get(X);if(L.__webglInit===void 0)return;const ge=X.source,Re=p.get(ge);if(Re){const $e=Re[L.__cacheKey];$e.usedTimes--,$e.usedTimes===0&&M(X),Object.keys(Re).length===0&&p.delete(ge)}s.remove(X)}function M(X){const L=s.get(X);n.deleteTexture(L.__webglTexture);const ge=X.source,Re=p.get(ge);delete Re[L.__cacheKey],o.memory.textures--}function T(X){const L=s.get(X);if(X.depthTexture&&(X.depthTexture.dispose(),s.remove(X.depthTexture)),X.isWebGLCubeRenderTarget)for(let Re=0;Re<6;Re++){if(Array.isArray(L.__webglFramebuffer[Re]))for(let $e=0;$e<L.__webglFramebuffer[Re].length;$e++)n.deleteFramebuffer(L.__webglFramebuffer[Re][$e]);else n.deleteFramebuffer(L.__webglFramebuffer[Re]);L.__webglDepthbuffer&&n.deleteRenderbuffer(L.__webglDepthbuffer[Re])}else{if(Array.isArray(L.__webglFramebuffer))for(let Re=0;Re<L.__webglFramebuffer.length;Re++)n.deleteFramebuffer(L.__webglFramebuffer[Re]);else n.deleteFramebuffer(L.__webglFramebuffer);if(L.__webglDepthbuffer&&n.deleteRenderbuffer(L.__webglDepthbuffer),L.__webglMultisampledFramebuffer&&n.deleteFramebuffer(L.__webglMultisampledFramebuffer),L.__webglColorRenderbuffer)for(let Re=0;Re<L.__webglColorRenderbuffer.length;Re++)L.__webglColorRenderbuffer[Re]&&n.deleteRenderbuffer(L.__webglColorRenderbuffer[Re]);L.__webglDepthRenderbuffer&&n.deleteRenderbuffer(L.__webglDepthRenderbuffer)}const ge=X.textures;for(let Re=0,$e=ge.length;Re<$e;Re++){const Ie=s.get(ge[Re]);Ie.__webglTexture&&(n.deleteTexture(Ie.__webglTexture),o.memory.textures--),s.remove(ge[Re])}s.remove(X)}let I=0;function $(){I=0}function O(){const X=I;return X>=r.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+X+" texture units while this GPU supports only "+r.maxTextures),I+=1,X}function B(X){const L=[];return L.push(X.wrapS),L.push(X.wrapT),L.push(X.wrapR||0),L.push(X.magFilter),L.push(X.minFilter),L.push(X.anisotropy),L.push(X.internalFormat),L.push(X.format),L.push(X.type),L.push(X.generateMipmaps),L.push(X.premultiplyAlpha),L.push(X.flipY),L.push(X.unpackAlignment),L.push(X.colorSpace),L.join()}function V(X,L){const ge=s.get(X);if(X.isVideoTexture&&Oe(X),X.isRenderTargetTexture===!1&&X.version>0&&ge.__version!==X.version){const Re=X.image;if(Re===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Re.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Y(ge,X,L);return}}t.bindTexture(n.TEXTURE_2D,ge.__webglTexture,n.TEXTURE0+L)}function H(X,L){const ge=s.get(X);if(X.version>0&&ge.__version!==X.version){Y(ge,X,L);return}t.bindTexture(n.TEXTURE_2D_ARRAY,ge.__webglTexture,n.TEXTURE0+L)}function q(X,L){const ge=s.get(X);if(X.version>0&&ge.__version!==X.version){Y(ge,X,L);return}t.bindTexture(n.TEXTURE_3D,ge.__webglTexture,n.TEXTURE0+L)}function P(X,L){const ge=s.get(X);if(X.version>0&&ge.__version!==X.version){te(ge,X,L);return}t.bindTexture(n.TEXTURE_CUBE_MAP,ge.__webglTexture,n.TEXTURE0+L)}const K={[Gl]:n.REPEAT,[Fl]:n.CLAMP_TO_EDGE,[w1]:n.MIRRORED_REPEAT},Z={[mr]:n.NEAREST,[hB]:n.NEAREST_MIPMAP_NEAREST,[Qp]:n.NEAREST_MIPMAP_LINEAR,[io]:n.LINEAR,[ay]:n.LINEAR_MIPMAP_NEAREST,[Ll]:n.LINEAR_MIPMAP_LINEAR},U={[mB]:n.NEVER,[SB]:n.ALWAYS,[gB]:n.LESS,[DM]:n.LEQUAL,[xB]:n.EQUAL,[bB]:n.GEQUAL,[vB]:n.GREATER,[yB]:n.NOTEQUAL};function z(X,L){if(L.type===oo&&e.has("OES_texture_float_linear")===!1&&(L.magFilter===io||L.magFilter===ay||L.magFilter===Qp||L.magFilter===Ll||L.minFilter===io||L.minFilter===ay||L.minFilter===Qp||L.minFilter===Ll)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(X,n.TEXTURE_WRAP_S,K[L.wrapS]),n.texParameteri(X,n.TEXTURE_WRAP_T,K[L.wrapT]),(X===n.TEXTURE_3D||X===n.TEXTURE_2D_ARRAY)&&n.texParameteri(X,n.TEXTURE_WRAP_R,K[L.wrapR]),n.texParameteri(X,n.TEXTURE_MAG_FILTER,Z[L.magFilter]),n.texParameteri(X,n.TEXTURE_MIN_FILTER,Z[L.minFilter]),L.compareFunction&&(n.texParameteri(X,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(X,n.TEXTURE_COMPARE_FUNC,U[L.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(L.magFilter===mr||L.minFilter!==Qp&&L.minFilter!==Ll||L.type===oo&&e.has("OES_texture_float_linear")===!1)return;if(L.anisotropy>1||s.get(L).__currentAnisotropy){const ge=e.get("EXT_texture_filter_anisotropic");n.texParameterf(X,ge.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(L.anisotropy,r.getMaxAnisotropy())),s.get(L).__currentAnisotropy=L.anisotropy}}}function ne(X,L){let ge=!1;X.__webglInit===void 0&&(X.__webglInit=!0,L.addEventListener("dispose",k));const Re=L.source;let $e=p.get(Re);$e===void 0&&($e={},p.set(Re,$e));const Ie=B(L);if(Ie!==X.__cacheKey){$e[Ie]===void 0&&($e[Ie]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,ge=!0),$e[Ie].usedTimes++;const Xe=$e[X.__cacheKey];Xe!==void 0&&($e[X.__cacheKey].usedTimes--,Xe.usedTimes===0&&M(L)),X.__cacheKey=Ie,X.__webglTexture=$e[Ie].texture}return ge}function Y(X,L,ge){let Re=n.TEXTURE_2D;(L.isDataArrayTexture||L.isCompressedArrayTexture)&&(Re=n.TEXTURE_2D_ARRAY),L.isData3DTexture&&(Re=n.TEXTURE_3D);const $e=ne(X,L),Ie=L.source;t.bindTexture(Re,X.__webglTexture,n.TEXTURE0+ge);const Xe=s.get(Ie);if(Ie.version!==Xe.__version||$e===!0){t.activeTexture(n.TEXTURE0+ge);const ze=fn.getPrimaries(fn.workingColorSpace),et=L.colorSpace===Aa?null:fn.getPrimaries(L.colorSpace),ut=L.colorSpace===Aa||ze===et?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,L.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,L.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,L.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,ut);let Pe=b(L.image,!1,r.maxTextureSize);Pe=yt(L,Pe);const lt=i.convert(L.format,L.colorSpace),wt=i.convert(L.type);let Et=C(L.internalFormat,lt,wt,L.colorSpace,L.isVideoTexture);z(Re,L);let ct;const Ot=L.mipmaps,$t=L.isVideoTexture!==!0,hn=Xe.__version===void 0||$e===!0,ue=Ie.dataReady,tt=A(L,Pe);if(L.isDepthTexture)Et=_(L.format===id,L.type),hn&&($t?t.texStorage2D(n.TEXTURE_2D,1,Et,Pe.width,Pe.height):t.texImage2D(n.TEXTURE_2D,0,Et,Pe.width,Pe.height,0,lt,wt,null));else if(L.isDataTexture)if(Ot.length>0){$t&&hn&&t.texStorage2D(n.TEXTURE_2D,tt,Et,Ot[0].width,Ot[0].height);for(let ke=0,Fe=Ot.length;ke<Fe;ke++)ct=Ot[ke],$t?ue&&t.texSubImage2D(n.TEXTURE_2D,ke,0,0,ct.width,ct.height,lt,wt,ct.data):t.texImage2D(n.TEXTURE_2D,ke,Et,ct.width,ct.height,0,lt,wt,ct.data);L.generateMipmaps=!1}else $t?(hn&&t.texStorage2D(n.TEXTURE_2D,tt,Et,Pe.width,Pe.height),ue&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,Pe.width,Pe.height,lt,wt,Pe.data)):t.texImage2D(n.TEXTURE_2D,0,Et,Pe.width,Pe.height,0,lt,wt,Pe.data);else if(L.isCompressedTexture)if(L.isCompressedArrayTexture){$t&&hn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,tt,Et,Ot[0].width,Ot[0].height,Pe.depth);for(let ke=0,Fe=Ot.length;ke<Fe;ke++)if(ct=Ot[ke],L.format!==Hr)if(lt!==null)if($t){if(ue)if(L.layerUpdates.size>0){const it=xI(ct.width,ct.height,L.format,L.type);for(const nt of L.layerUpdates){const Pt=ct.data.subarray(nt*it/ct.data.BYTES_PER_ELEMENT,(nt+1)*it/ct.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ke,0,0,nt,ct.width,ct.height,1,lt,Pt)}L.clearLayerUpdates()}else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ke,0,0,0,ct.width,ct.height,Pe.depth,lt,ct.data)}else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,ke,Et,ct.width,ct.height,Pe.depth,0,ct.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else $t?ue&&t.texSubImage3D(n.TEXTURE_2D_ARRAY,ke,0,0,0,ct.width,ct.height,Pe.depth,lt,wt,ct.data):t.texImage3D(n.TEXTURE_2D_ARRAY,ke,Et,ct.width,ct.height,Pe.depth,0,lt,wt,ct.data)}else{$t&&hn&&t.texStorage2D(n.TEXTURE_2D,tt,Et,Ot[0].width,Ot[0].height);for(let ke=0,Fe=Ot.length;ke<Fe;ke++)ct=Ot[ke],L.format!==Hr?lt!==null?$t?ue&&t.compressedTexSubImage2D(n.TEXTURE_2D,ke,0,0,ct.width,ct.height,lt,ct.data):t.compressedTexImage2D(n.TEXTURE_2D,ke,Et,ct.width,ct.height,0,ct.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):$t?ue&&t.texSubImage2D(n.TEXTURE_2D,ke,0,0,ct.width,ct.height,lt,wt,ct.data):t.texImage2D(n.TEXTURE_2D,ke,Et,ct.width,ct.height,0,lt,wt,ct.data)}else if(L.isDataArrayTexture)if($t){if(hn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,tt,Et,Pe.width,Pe.height,Pe.depth),ue)if(L.layerUpdates.size>0){const ke=xI(Pe.width,Pe.height,L.format,L.type);for(const Fe of L.layerUpdates){const it=Pe.data.subarray(Fe*ke/Pe.data.BYTES_PER_ELEMENT,(Fe+1)*ke/Pe.data.BYTES_PER_ELEMENT);t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,Fe,Pe.width,Pe.height,1,lt,wt,it)}L.clearLayerUpdates()}else t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,Pe.width,Pe.height,Pe.depth,lt,wt,Pe.data)}else t.texImage3D(n.TEXTURE_2D_ARRAY,0,Et,Pe.width,Pe.height,Pe.depth,0,lt,wt,Pe.data);else if(L.isData3DTexture)$t?(hn&&t.texStorage3D(n.TEXTURE_3D,tt,Et,Pe.width,Pe.height,Pe.depth),ue&&t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,Pe.width,Pe.height,Pe.depth,lt,wt,Pe.data)):t.texImage3D(n.TEXTURE_3D,0,Et,Pe.width,Pe.height,Pe.depth,0,lt,wt,Pe.data);else if(L.isFramebufferTexture){if(hn)if($t)t.texStorage2D(n.TEXTURE_2D,tt,Et,Pe.width,Pe.height);else{let ke=Pe.width,Fe=Pe.height;for(let it=0;it<tt;it++)t.texImage2D(n.TEXTURE_2D,it,Et,ke,Fe,0,lt,wt,null),ke>>=1,Fe>>=1}}else if(Ot.length>0){if($t&&hn){const ke=Ve(Ot[0]);t.texStorage2D(n.TEXTURE_2D,tt,Et,ke.width,ke.height)}for(let ke=0,Fe=Ot.length;ke<Fe;ke++)ct=Ot[ke],$t?ue&&t.texSubImage2D(n.TEXTURE_2D,ke,0,0,lt,wt,ct):t.texImage2D(n.TEXTURE_2D,ke,Et,lt,wt,ct);L.generateMipmaps=!1}else if($t){if(hn){const ke=Ve(Pe);t.texStorage2D(n.TEXTURE_2D,tt,Et,ke.width,ke.height)}ue&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,lt,wt,Pe)}else t.texImage2D(n.TEXTURE_2D,0,Et,lt,wt,Pe);y(L)&&v(Re),Xe.__version=Ie.version,L.onUpdate&&L.onUpdate(L)}X.__version=L.version}function te(X,L,ge){if(L.image.length!==6)return;const Re=ne(X,L),$e=L.source;t.bindTexture(n.TEXTURE_CUBE_MAP,X.__webglTexture,n.TEXTURE0+ge);const Ie=s.get($e);if($e.version!==Ie.__version||Re===!0){t.activeTexture(n.TEXTURE0+ge);const Xe=fn.getPrimaries(fn.workingColorSpace),ze=L.colorSpace===Aa?null:fn.getPrimaries(L.colorSpace),et=L.colorSpace===Aa||Xe===ze?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,L.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,L.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,L.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,et);const ut=L.isCompressedTexture||L.image[0].isCompressedTexture,Pe=L.image[0]&&L.image[0].isDataTexture,lt=[];for(let Fe=0;Fe<6;Fe++)!ut&&!Pe?lt[Fe]=b(L.image[Fe],!0,r.maxCubemapSize):lt[Fe]=Pe?L.image[Fe].image:L.image[Fe],lt[Fe]=yt(L,lt[Fe]);const wt=lt[0],Et=i.convert(L.format,L.colorSpace),ct=i.convert(L.type),Ot=C(L.internalFormat,Et,ct,L.colorSpace),$t=L.isVideoTexture!==!0,hn=Ie.__version===void 0||Re===!0,ue=$e.dataReady;let tt=A(L,wt);z(n.TEXTURE_CUBE_MAP,L);let ke;if(ut){$t&&hn&&t.texStorage2D(n.TEXTURE_CUBE_MAP,tt,Ot,wt.width,wt.height);for(let Fe=0;Fe<6;Fe++){ke=lt[Fe].mipmaps;for(let it=0;it<ke.length;it++){const nt=ke[it];L.format!==Hr?Et!==null?$t?ue&&t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it,0,0,nt.width,nt.height,Et,nt.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it,Ot,nt.width,nt.height,0,nt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):$t?ue&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it,0,0,nt.width,nt.height,Et,ct,nt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it,Ot,nt.width,nt.height,0,Et,ct,nt.data)}}}else{if(ke=L.mipmaps,$t&&hn){ke.length>0&&tt++;const Fe=Ve(lt[0]);t.texStorage2D(n.TEXTURE_CUBE_MAP,tt,Ot,Fe.width,Fe.height)}for(let Fe=0;Fe<6;Fe++)if(Pe){$t?ue&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,0,0,0,lt[Fe].width,lt[Fe].height,Et,ct,lt[Fe].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,0,Ot,lt[Fe].width,lt[Fe].height,0,Et,ct,lt[Fe].data);for(let it=0;it<ke.length;it++){const Pt=ke[it].image[Fe].image;$t?ue&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it+1,0,0,Pt.width,Pt.height,Et,ct,Pt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it+1,Ot,Pt.width,Pt.height,0,Et,ct,Pt.data)}}else{$t?ue&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,0,0,0,Et,ct,lt[Fe]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,0,Ot,Et,ct,lt[Fe]);for(let it=0;it<ke.length;it++){const nt=ke[it];$t?ue&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it+1,0,0,Et,ct,nt.image[Fe]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Fe,it+1,Ot,Et,ct,nt.image[Fe])}}}y(L)&&v(n.TEXTURE_CUBE_MAP),Ie.__version=$e.version,L.onUpdate&&L.onUpdate(L)}X.__version=L.version}function he(X,L,ge,Re,$e,Ie){const Xe=i.convert(ge.format,ge.colorSpace),ze=i.convert(ge.type),et=C(ge.internalFormat,Xe,ze,ge.colorSpace),ut=s.get(L),Pe=s.get(ge);if(Pe.__renderTarget=L,!ut.__hasExternalTextures){const lt=Math.max(1,L.width>>Ie),wt=Math.max(1,L.height>>Ie);$e===n.TEXTURE_3D||$e===n.TEXTURE_2D_ARRAY?t.texImage3D($e,Ie,et,lt,wt,L.depth,0,Xe,ze,null):t.texImage2D($e,Ie,et,lt,wt,0,Xe,ze,null)}t.bindFramebuffer(n.FRAMEBUFFER,X),Ke(L)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,Re,$e,Pe.__webglTexture,0,We(L)):($e===n.TEXTURE_2D||$e>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&$e<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,Re,$e,Pe.__webglTexture,Ie),t.bindFramebuffer(n.FRAMEBUFFER,null)}function se(X,L,ge){if(n.bindRenderbuffer(n.RENDERBUFFER,X),L.depthBuffer){const Re=L.depthTexture,$e=Re&&Re.isDepthTexture?Re.type:null,Ie=_(L.stencilBuffer,$e),Xe=L.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,ze=We(L);Ke(L)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,ze,Ie,L.width,L.height):ge?n.renderbufferStorageMultisample(n.RENDERBUFFER,ze,Ie,L.width,L.height):n.renderbufferStorage(n.RENDERBUFFER,Ie,L.width,L.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,Xe,n.RENDERBUFFER,X)}else{const Re=L.textures;for(let $e=0;$e<Re.length;$e++){const Ie=Re[$e],Xe=i.convert(Ie.format,Ie.colorSpace),ze=i.convert(Ie.type),et=C(Ie.internalFormat,Xe,ze,Ie.colorSpace),ut=We(L);ge&&Ke(L)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,ut,et,L.width,L.height):Ke(L)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,ut,et,L.width,L.height):n.renderbufferStorage(n.RENDERBUFFER,et,L.width,L.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function Q(X,L){if(L&&L.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,X),!(L.depthTexture&&L.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const Re=s.get(L.depthTexture);Re.__renderTarget=L,(!Re.__webglTexture||L.depthTexture.image.width!==L.width||L.depthTexture.image.height!==L.height)&&(L.depthTexture.image.width=L.width,L.depthTexture.image.height=L.height,L.depthTexture.needsUpdate=!0),V(L.depthTexture,0);const $e=Re.__webglTexture,Ie=We(L);if(L.depthTexture.format===rd)Ke(L)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,$e,0,Ie):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,$e,0);else if(L.depthTexture.format===id)Ke(L)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,$e,0,Ie):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,$e,0);else throw new Error("Unknown depthTexture format")}function de(X){const L=s.get(X),ge=X.isWebGLCubeRenderTarget===!0;if(L.__boundDepthTexture!==X.depthTexture){const Re=X.depthTexture;if(L.__depthDisposeCallback&&L.__depthDisposeCallback(),Re){const $e=()=>{delete L.__boundDepthTexture,delete L.__depthDisposeCallback,Re.removeEventListener("dispose",$e)};Re.addEventListener("dispose",$e),L.__depthDisposeCallback=$e}L.__boundDepthTexture=Re}if(X.depthTexture&&!L.__autoAllocateDepthBuffer){if(ge)throw new Error("target.depthTexture not supported in Cube render targets");const Re=X.texture.mipmaps;Re&&Re.length>0?Q(L.__webglFramebuffer[0],X):Q(L.__webglFramebuffer,X)}else if(ge){L.__webglDepthbuffer=[];for(let Re=0;Re<6;Re++)if(t.bindFramebuffer(n.FRAMEBUFFER,L.__webglFramebuffer[Re]),L.__webglDepthbuffer[Re]===void 0)L.__webglDepthbuffer[Re]=n.createRenderbuffer(),se(L.__webglDepthbuffer[Re],X,!1);else{const $e=X.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Ie=L.__webglDepthbuffer[Re];n.bindRenderbuffer(n.RENDERBUFFER,Ie),n.framebufferRenderbuffer(n.FRAMEBUFFER,$e,n.RENDERBUFFER,Ie)}}else{const Re=X.texture.mipmaps;if(Re&&Re.length>0?t.bindFramebuffer(n.FRAMEBUFFER,L.__webglFramebuffer[0]):t.bindFramebuffer(n.FRAMEBUFFER,L.__webglFramebuffer),L.__webglDepthbuffer===void 0)L.__webglDepthbuffer=n.createRenderbuffer(),se(L.__webglDepthbuffer,X,!1);else{const $e=X.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Ie=L.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,Ie),n.framebufferRenderbuffer(n.FRAMEBUFFER,$e,n.RENDERBUFFER,Ie)}}t.bindFramebuffer(n.FRAMEBUFFER,null)}function ce(X,L,ge){const Re=s.get(X);L!==void 0&&he(Re.__webglFramebuffer,X,X.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),ge!==void 0&&de(X)}function De(X){const L=X.texture,ge=s.get(X),Re=s.get(L);X.addEventListener("dispose",N);const $e=X.textures,Ie=X.isWebGLCubeRenderTarget===!0,Xe=$e.length>1;if(Xe||(Re.__webglTexture===void 0&&(Re.__webglTexture=n.createTexture()),Re.__version=L.version,o.memory.textures++),Ie){ge.__webglFramebuffer=[];for(let ze=0;ze<6;ze++)if(L.mipmaps&&L.mipmaps.length>0){ge.__webglFramebuffer[ze]=[];for(let et=0;et<L.mipmaps.length;et++)ge.__webglFramebuffer[ze][et]=n.createFramebuffer()}else ge.__webglFramebuffer[ze]=n.createFramebuffer()}else{if(L.mipmaps&&L.mipmaps.length>0){ge.__webglFramebuffer=[];for(let ze=0;ze<L.mipmaps.length;ze++)ge.__webglFramebuffer[ze]=n.createFramebuffer()}else ge.__webglFramebuffer=n.createFramebuffer();if(Xe)for(let ze=0,et=$e.length;ze<et;ze++){const ut=s.get($e[ze]);ut.__webglTexture===void 0&&(ut.__webglTexture=n.createTexture(),o.memory.textures++)}if(X.samples>0&&Ke(X)===!1){ge.__webglMultisampledFramebuffer=n.createFramebuffer(),ge.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,ge.__webglMultisampledFramebuffer);for(let ze=0;ze<$e.length;ze++){const et=$e[ze];ge.__webglColorRenderbuffer[ze]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,ge.__webglColorRenderbuffer[ze]);const ut=i.convert(et.format,et.colorSpace),Pe=i.convert(et.type),lt=C(et.internalFormat,ut,Pe,et.colorSpace,X.isXRRenderTarget===!0),wt=We(X);n.renderbufferStorageMultisample(n.RENDERBUFFER,wt,lt,X.width,X.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+ze,n.RENDERBUFFER,ge.__webglColorRenderbuffer[ze])}n.bindRenderbuffer(n.RENDERBUFFER,null),X.depthBuffer&&(ge.__webglDepthRenderbuffer=n.createRenderbuffer(),se(ge.__webglDepthRenderbuffer,X,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(Ie){t.bindTexture(n.TEXTURE_CUBE_MAP,Re.__webglTexture),z(n.TEXTURE_CUBE_MAP,L);for(let ze=0;ze<6;ze++)if(L.mipmaps&&L.mipmaps.length>0)for(let et=0;et<L.mipmaps.length;et++)he(ge.__webglFramebuffer[ze][et],X,L,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+ze,et);else he(ge.__webglFramebuffer[ze],X,L,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+ze,0);y(L)&&v(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(Xe){for(let ze=0,et=$e.length;ze<et;ze++){const ut=$e[ze],Pe=s.get(ut);t.bindTexture(n.TEXTURE_2D,Pe.__webglTexture),z(n.TEXTURE_2D,ut),he(ge.__webglFramebuffer,X,ut,n.COLOR_ATTACHMENT0+ze,n.TEXTURE_2D,0),y(ut)&&v(n.TEXTURE_2D)}t.unbindTexture()}else{let ze=n.TEXTURE_2D;if((X.isWebGL3DRenderTarget||X.isWebGLArrayRenderTarget)&&(ze=X.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(ze,Re.__webglTexture),z(ze,L),L.mipmaps&&L.mipmaps.length>0)for(let et=0;et<L.mipmaps.length;et++)he(ge.__webglFramebuffer[et],X,L,n.COLOR_ATTACHMENT0,ze,et);else he(ge.__webglFramebuffer,X,L,n.COLOR_ATTACHMENT0,ze,0);y(L)&&v(ze),t.unbindTexture()}X.depthBuffer&&de(X)}function He(X){const L=X.textures;for(let ge=0,Re=L.length;ge<Re;ge++){const $e=L[ge];if(y($e)){const Ie=S(X),Xe=s.get($e).__webglTexture;t.bindTexture(Ie,Xe),v(Ie),t.unbindTexture()}}}const Le=[],j=[];function ht(X){if(X.samples>0){if(Ke(X)===!1){const L=X.textures,ge=X.width,Re=X.height;let $e=n.COLOR_BUFFER_BIT;const Ie=X.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Xe=s.get(X),ze=L.length>1;if(ze)for(let ut=0;ut<L.length;ut++)t.bindFramebuffer(n.FRAMEBUFFER,Xe.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+ut,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,Xe.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+ut,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,Xe.__webglMultisampledFramebuffer);const et=X.texture.mipmaps;et&&et.length>0?t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Xe.__webglFramebuffer[0]):t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Xe.__webglFramebuffer);for(let ut=0;ut<L.length;ut++){if(X.resolveDepthBuffer&&(X.depthBuffer&&($e|=n.DEPTH_BUFFER_BIT),X.stencilBuffer&&X.resolveStencilBuffer&&($e|=n.STENCIL_BUFFER_BIT)),ze){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,Xe.__webglColorRenderbuffer[ut]);const Pe=s.get(L[ut]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,Pe,0)}n.blitFramebuffer(0,0,ge,Re,0,0,ge,Re,$e,n.NEAREST),l===!0&&(Le.length=0,j.length=0,Le.push(n.COLOR_ATTACHMENT0+ut),X.depthBuffer&&X.resolveDepthBuffer===!1&&(Le.push(Ie),j.push(Ie),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,j)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,Le))}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),ze)for(let ut=0;ut<L.length;ut++){t.bindFramebuffer(n.FRAMEBUFFER,Xe.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+ut,n.RENDERBUFFER,Xe.__webglColorRenderbuffer[ut]);const Pe=s.get(L[ut]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,Xe.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+ut,n.TEXTURE_2D,Pe,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Xe.__webglMultisampledFramebuffer)}else if(X.depthBuffer&&X.resolveDepthBuffer===!1&&l){const L=X.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[L])}}}function We(X){return Math.min(r.maxSamples,X.samples)}function Ke(X){const L=s.get(X);return X.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&L.__useRenderToTexture!==!1}function Oe(X){const L=o.render.frame;h.get(X)!==L&&(h.set(X,L),X.update())}function yt(X,L){const ge=X.colorSpace,Re=X.format,$e=X.type;return X.isCompressedTexture===!0||X.isVideoTexture===!0||ge!==yu&&ge!==Aa&&(fn.getTransfer(ge)===wn?(Re!==Hr||$e!==Ui)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",ge)),L}function Ve(X){return typeof HTMLImageElement<"u"&&X instanceof HTMLImageElement?(c.width=X.naturalWidth||X.width,c.height=X.naturalHeight||X.height):typeof VideoFrame<"u"&&X instanceof VideoFrame?(c.width=X.displayWidth,c.height=X.displayHeight):(c.width=X.width,c.height=X.height),c}this.allocateTextureUnit=O,this.resetTextureUnits=$,this.setTexture2D=V,this.setTexture2DArray=H,this.setTexture3D=q,this.setTextureCube=P,this.rebindTextures=ce,this.setupRenderTarget=De,this.updateRenderTargetMipmap=He,this.updateMultisampleRenderTarget=ht,this.setupDepthRenderbuffer=de,this.setupFrameBufferTexture=he,this.useMultisampledRTT=Ke}function LH(n,e){function t(s,r=Aa){let i;const o=fn.getTransfer(r);if(s===Ui)return n.UNSIGNED_BYTE;if(s===sS)return n.UNSIGNED_SHORT_4_4_4_4;if(s===rS)return n.UNSIGNED_SHORT_5_5_5_1;if(s===IM)return n.UNSIGNED_INT_5_9_9_9_REV;if(s===EM)return n.BYTE;if(s===TM)return n.SHORT;if(s===nd)return n.UNSIGNED_SHORT;if(s===nS)return n.INT;if(s===Wl)return n.UNSIGNED_INT;if(s===oo)return n.FLOAT;if(s===wd)return n.HALF_FLOAT;if(s===AM)return n.ALPHA;if(s===MM)return n.RGB;if(s===Hr)return n.RGBA;if(s===rd)return n.DEPTH_COMPONENT;if(s===id)return n.DEPTH_STENCIL;if(s===iS)return n.RED;if(s===oS)return n.RED_INTEGER;if(s===RM)return n.RG;if(s===aS)return n.RG_INTEGER;if(s===lS)return n.RGBA_INTEGER;if(s===Bm||s===Vm||s===Gm||s===Wm)if(o===wn)if(i=e.get("WEBGL_compressed_texture_s3tc_srgb"),i!==null){if(s===Bm)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===Vm)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===Gm)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===Wm)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(i=e.get("WEBGL_compressed_texture_s3tc"),i!==null){if(s===Bm)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Vm)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Gm)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Wm)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===_1||s===C1||s===E1||s===T1)if(i=e.get("WEBGL_compressed_texture_pvrtc"),i!==null){if(s===_1)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===C1)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===E1)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===T1)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===I1||s===A1||s===M1)if(i=e.get("WEBGL_compressed_texture_etc"),i!==null){if(s===I1||s===A1)return o===wn?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(s===M1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===R1||s===k1||s===N1||s===D1||s===$1||s===F1||s===L1||s===P1||s===O1||s===U1||s===z1||s===B1||s===V1||s===G1)if(i=e.get("WEBGL_compressed_texture_astc"),i!==null){if(s===R1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===k1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===N1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===D1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===$1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===F1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===L1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===P1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===O1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===U1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===z1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===B1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===V1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===G1)return o===wn?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===Hm||s===W1||s===H1)if(i=e.get("EXT_texture_compression_bptc"),i!==null){if(s===Hm)return o===wn?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===W1)return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===H1)return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===kM||s===X1||s===j1||s===q1)if(i=e.get("EXT_texture_compression_rgtc"),i!==null){if(s===Hm)return i.COMPRESSED_RED_RGTC1_EXT;if(s===X1)return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===j1)return i.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===q1)return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===sd?n.UNSIGNED_INT_24_8:n[s]!==void 0?n[s]:null}return{convert:t}}const PH=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,OH=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class UH{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t,s){if(this.texture===null){const r=new rr,i=e.properties.get(r);i.__webglTexture=t.texture,(t.depthNear!==s.depthNear||t.depthFar!==s.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=r}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,s=new Fi({vertexShader:PH,fragmentShader:OH,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new Os(new oc(20,20),s)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class zH extends Nu{constructor(e,t){super();const s=this;let r=null,i=1,o=null,a="local-floor",l=1,c=null,h=null,d=null,p=null,m=null,g=null;const b=new UH,y=t.getContextAttributes();let v=null,S=null;const C=[],_=[],A=new gn;let k=null;const N=new Gr;N.viewport=new Xn;const D=new Gr;D.viewport=new Xn;const M=[N,D],T=new a4;let I=null,$=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(Y){let te=C[Y];return te===void 0&&(te=new My,C[Y]=te),te.getTargetRaySpace()},this.getControllerGrip=function(Y){let te=C[Y];return te===void 0&&(te=new My,C[Y]=te),te.getGripSpace()},this.getHand=function(Y){let te=C[Y];return te===void 0&&(te=new My,C[Y]=te),te.getHandSpace()};function O(Y){const te=_.indexOf(Y.inputSource);if(te===-1)return;const he=C[te];he!==void 0&&(he.update(Y.inputSource,Y.frame,c||o),he.dispatchEvent({type:Y.type,data:Y.inputSource}))}function B(){r.removeEventListener("select",O),r.removeEventListener("selectstart",O),r.removeEventListener("selectend",O),r.removeEventListener("squeeze",O),r.removeEventListener("squeezestart",O),r.removeEventListener("squeezeend",O),r.removeEventListener("end",B),r.removeEventListener("inputsourceschange",V);for(let Y=0;Y<C.length;Y++){const te=_[Y];te!==null&&(_[Y]=null,C[Y].disconnect(te))}I=null,$=null,b.reset(),e.setRenderTarget(v),m=null,p=null,d=null,r=null,S=null,ne.stop(),s.isPresenting=!1,e.setPixelRatio(k),e.setSize(A.width,A.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(Y){i=Y,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(Y){a=Y,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(Y){c=Y},this.getBaseLayer=function(){return p!==null?p:m},this.getBinding=function(){return d},this.getFrame=function(){return g},this.getSession=function(){return r},this.setSession=async function(Y){if(r=Y,r!==null){if(v=e.getRenderTarget(),r.addEventListener("select",O),r.addEventListener("selectstart",O),r.addEventListener("selectend",O),r.addEventListener("squeeze",O),r.addEventListener("squeezestart",O),r.addEventListener("squeezeend",O),r.addEventListener("end",B),r.addEventListener("inputsourceschange",V),y.xrCompatible!==!0&&await t.makeXRCompatible(),k=e.getPixelRatio(),e.getSize(A),typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype){let he=null,se=null,Q=null;y.depth&&(Q=y.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,he=y.stencil?id:rd,se=y.stencil?sd:Wl);const de={colorFormat:t.RGBA8,depthFormat:Q,scaleFactor:i};d=new XRWebGLBinding(r,t),p=d.createProjectionLayer(de),r.updateRenderState({layers:[p]}),e.setPixelRatio(1),e.setSize(p.textureWidth,p.textureHeight,!1),S=new za(p.textureWidth,p.textureHeight,{format:Hr,type:Ui,depthTexture:new jM(p.textureWidth,p.textureHeight,se,void 0,void 0,void 0,void 0,void 0,void 0,he),stencilBuffer:y.stencil,colorSpace:e.outputColorSpace,samples:y.antialias?4:0,resolveDepthBuffer:p.ignoreDepthValues===!1,resolveStencilBuffer:p.ignoreDepthValues===!1})}else{const he={antialias:y.antialias,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:i};m=new XRWebGLLayer(r,t,he),r.updateRenderState({baseLayer:m}),e.setPixelRatio(1),e.setSize(m.framebufferWidth,m.framebufferHeight,!1),S=new za(m.framebufferWidth,m.framebufferHeight,{format:Hr,type:Ui,colorSpace:e.outputColorSpace,stencilBuffer:y.stencil,resolveDepthBuffer:m.ignoreDepthValues===!1,resolveStencilBuffer:m.ignoreDepthValues===!1})}S.isXRRenderTarget=!0,this.setFoveation(l),c=null,o=await r.requestReferenceSpace(a),ne.setContext(r),ne.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(r!==null)return r.environmentBlendMode},this.getDepthTexture=function(){return b.getDepthTexture()};function V(Y){for(let te=0;te<Y.removed.length;te++){const he=Y.removed[te],se=_.indexOf(he);se>=0&&(_[se]=null,C[se].disconnect(he))}for(let te=0;te<Y.added.length;te++){const he=Y.added[te];let se=_.indexOf(he);if(se===-1){for(let de=0;de<C.length;de++)if(de>=_.length){_.push(he),se=de;break}else if(_[de]===null){_[de]=he,se=de;break}if(se===-1)break}const Q=C[se];Q&&Q.connect(he)}}const H=new Ce,q=new Ce;function P(Y,te,he){H.setFromMatrixPosition(te.matrixWorld),q.setFromMatrixPosition(he.matrixWorld);const se=H.distanceTo(q),Q=te.projectionMatrix.elements,de=he.projectionMatrix.elements,ce=Q[14]/(Q[10]-1),De=Q[14]/(Q[10]+1),He=(Q[9]+1)/Q[5],Le=(Q[9]-1)/Q[5],j=(Q[8]-1)/Q[0],ht=(de[8]+1)/de[0],We=ce*j,Ke=ce*ht,Oe=se/(-j+ht),yt=Oe*-j;if(te.matrixWorld.decompose(Y.position,Y.quaternion,Y.scale),Y.translateX(yt),Y.translateZ(Oe),Y.matrixWorld.compose(Y.position,Y.quaternion,Y.scale),Y.matrixWorldInverse.copy(Y.matrixWorld).invert(),Q[10]===-1)Y.projectionMatrix.copy(te.projectionMatrix),Y.projectionMatrixInverse.copy(te.projectionMatrixInverse);else{const Ve=ce+Oe,X=De+Oe,L=We-yt,ge=Ke+(se-yt),Re=He*De/X*Ve,$e=Le*De/X*Ve;Y.projectionMatrix.makePerspective(L,ge,Re,$e,Ve,X),Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert()}}function K(Y,te){te===null?Y.matrixWorld.copy(Y.matrix):Y.matrixWorld.multiplyMatrices(te.matrixWorld,Y.matrix),Y.matrixWorldInverse.copy(Y.matrixWorld).invert()}this.updateCamera=function(Y){if(r===null)return;let te=Y.near,he=Y.far;b.texture!==null&&(b.depthNear>0&&(te=b.depthNear),b.depthFar>0&&(he=b.depthFar)),T.near=D.near=N.near=te,T.far=D.far=N.far=he,(I!==T.near||$!==T.far)&&(r.updateRenderState({depthNear:T.near,depthFar:T.far}),I=T.near,$=T.far),N.layers.mask=Y.layers.mask|2,D.layers.mask=Y.layers.mask|4,T.layers.mask=N.layers.mask|D.layers.mask;const se=Y.parent,Q=T.cameras;K(T,se);for(let de=0;de<Q.length;de++)K(Q[de],se);Q.length===2?P(T,N,D):T.projectionMatrix.copy(N.projectionMatrix),Z(Y,T,se)};function Z(Y,te,he){he===null?Y.matrix.copy(te.matrixWorld):(Y.matrix.copy(he.matrixWorld),Y.matrix.invert(),Y.matrix.multiply(te.matrixWorld)),Y.matrix.decompose(Y.position,Y.quaternion,Y.scale),Y.updateMatrixWorld(!0),Y.projectionMatrix.copy(te.projectionMatrix),Y.projectionMatrixInverse.copy(te.projectionMatrixInverse),Y.isPerspectiveCamera&&(Y.fov=K1*2*Math.atan(1/Y.projectionMatrix.elements[5]),Y.zoom=1)}this.getCamera=function(){return T},this.getFoveation=function(){if(!(p===null&&m===null))return l},this.setFoveation=function(Y){l=Y,p!==null&&(p.fixedFoveation=Y),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=Y)},this.hasDepthSensing=function(){return b.texture!==null},this.getDepthSensingMesh=function(){return b.getMesh(T)};let U=null;function z(Y,te){if(h=te.getViewerPose(c||o),g=te,h!==null){const he=h.views;m!==null&&(e.setRenderTargetFramebuffer(S,m.framebuffer),e.setRenderTarget(S));let se=!1;he.length!==T.cameras.length&&(T.cameras.length=0,se=!0);for(let ce=0;ce<he.length;ce++){const De=he[ce];let He=null;if(m!==null)He=m.getViewport(De);else{const j=d.getViewSubImage(p,De);He=j.viewport,ce===0&&(e.setRenderTargetTextures(S,j.colorTexture,j.depthStencilTexture),e.setRenderTarget(S))}let Le=M[ce];Le===void 0&&(Le=new Gr,Le.layers.enable(ce),Le.viewport=new Xn,M[ce]=Le),Le.matrix.fromArray(De.transform.matrix),Le.matrix.decompose(Le.position,Le.quaternion,Le.scale),Le.projectionMatrix.fromArray(De.projectionMatrix),Le.projectionMatrixInverse.copy(Le.projectionMatrix).invert(),Le.viewport.set(He.x,He.y,He.width,He.height),ce===0&&(T.matrix.copy(Le.matrix),T.matrix.decompose(T.position,T.quaternion,T.scale)),se===!0&&T.cameras.push(Le)}const Q=r.enabledFeatures;if(Q&&Q.includes("depth-sensing")&&r.depthUsage=="gpu-optimized"&&d){const ce=d.getDepthInformation(he[0]);ce&&ce.isValid&&ce.texture&&b.init(e,ce,r.renderState)}}for(let he=0;he<C.length;he++){const se=_[he],Q=C[he];se!==null&&Q!==void 0&&Q.update(se,te,c||o)}U&&U(Y,te),te.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:te}),g=null}const ne=new JM;ne.setAnimationLoop(z),this.setAnimationLoop=function(Y){U=Y},this.dispose=function(){}}}const Cl=new po,BH=new An;function VH(n,e){function t(y,v){y.matrixAutoUpdate===!0&&y.updateMatrix(),v.value.copy(y.matrix)}function s(y,v){v.color.getRGB(y.fogColor.value,VM(n)),v.isFog?(y.fogNear.value=v.near,y.fogFar.value=v.far):v.isFogExp2&&(y.fogDensity.value=v.density)}function r(y,v,S,C,_){v.isMeshBasicMaterial||v.isMeshLambertMaterial?i(y,v):v.isMeshToonMaterial?(i(y,v),d(y,v)):v.isMeshPhongMaterial?(i(y,v),h(y,v)):v.isMeshStandardMaterial?(i(y,v),p(y,v),v.isMeshPhysicalMaterial&&m(y,v,_)):v.isMeshMatcapMaterial?(i(y,v),g(y,v)):v.isMeshDepthMaterial?i(y,v):v.isMeshDistanceMaterial?(i(y,v),b(y,v)):v.isMeshNormalMaterial?i(y,v):v.isLineBasicMaterial?(o(y,v),v.isLineDashedMaterial&&a(y,v)):v.isPointsMaterial?l(y,v,S,C):v.isSpriteMaterial?c(y,v):v.isShadowMaterial?(y.color.value.copy(v.color),y.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}function i(y,v){y.opacity.value=v.opacity,v.color&&y.diffuse.value.copy(v.color),v.emissive&&y.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(y.map.value=v.map,t(v.map,y.mapTransform)),v.alphaMap&&(y.alphaMap.value=v.alphaMap,t(v.alphaMap,y.alphaMapTransform)),v.bumpMap&&(y.bumpMap.value=v.bumpMap,t(v.bumpMap,y.bumpMapTransform),y.bumpScale.value=v.bumpScale,v.side===sr&&(y.bumpScale.value*=-1)),v.normalMap&&(y.normalMap.value=v.normalMap,t(v.normalMap,y.normalMapTransform),y.normalScale.value.copy(v.normalScale),v.side===sr&&y.normalScale.value.negate()),v.displacementMap&&(y.displacementMap.value=v.displacementMap,t(v.displacementMap,y.displacementMapTransform),y.displacementScale.value=v.displacementScale,y.displacementBias.value=v.displacementBias),v.emissiveMap&&(y.emissiveMap.value=v.emissiveMap,t(v.emissiveMap,y.emissiveMapTransform)),v.specularMap&&(y.specularMap.value=v.specularMap,t(v.specularMap,y.specularMapTransform)),v.alphaTest>0&&(y.alphaTest.value=v.alphaTest);const S=e.get(v),C=S.envMap,_=S.envMapRotation;C&&(y.envMap.value=C,Cl.copy(_),Cl.x*=-1,Cl.y*=-1,Cl.z*=-1,C.isCubeTexture&&C.isRenderTargetTexture===!1&&(Cl.y*=-1,Cl.z*=-1),y.envMapRotation.value.setFromMatrix4(BH.makeRotationFromEuler(Cl)),y.flipEnvMap.value=C.isCubeTexture&&C.isRenderTargetTexture===!1?-1:1,y.reflectivity.value=v.reflectivity,y.ior.value=v.ior,y.refractionRatio.value=v.refractionRatio),v.lightMap&&(y.lightMap.value=v.lightMap,y.lightMapIntensity.value=v.lightMapIntensity,t(v.lightMap,y.lightMapTransform)),v.aoMap&&(y.aoMap.value=v.aoMap,y.aoMapIntensity.value=v.aoMapIntensity,t(v.aoMap,y.aoMapTransform))}function o(y,v){y.diffuse.value.copy(v.color),y.opacity.value=v.opacity,v.map&&(y.map.value=v.map,t(v.map,y.mapTransform))}function a(y,v){y.dashSize.value=v.dashSize,y.totalSize.value=v.dashSize+v.gapSize,y.scale.value=v.scale}function l(y,v,S,C){y.diffuse.value.copy(v.color),y.opacity.value=v.opacity,y.size.value=v.size*S,y.scale.value=C*.5,v.map&&(y.map.value=v.map,t(v.map,y.uvTransform)),v.alphaMap&&(y.alphaMap.value=v.alphaMap,t(v.alphaMap,y.alphaMapTransform)),v.alphaTest>0&&(y.alphaTest.value=v.alphaTest)}function c(y,v){y.diffuse.value.copy(v.color),y.opacity.value=v.opacity,y.rotation.value=v.rotation,v.map&&(y.map.value=v.map,t(v.map,y.mapTransform)),v.alphaMap&&(y.alphaMap.value=v.alphaMap,t(v.alphaMap,y.alphaMapTransform)),v.alphaTest>0&&(y.alphaTest.value=v.alphaTest)}function h(y,v){y.specular.value.copy(v.specular),y.shininess.value=Math.max(v.shininess,1e-4)}function d(y,v){v.gradientMap&&(y.gradientMap.value=v.gradientMap)}function p(y,v){y.metalness.value=v.metalness,v.metalnessMap&&(y.metalnessMap.value=v.metalnessMap,t(v.metalnessMap,y.metalnessMapTransform)),y.roughness.value=v.roughness,v.roughnessMap&&(y.roughnessMap.value=v.roughnessMap,t(v.roughnessMap,y.roughnessMapTransform)),v.envMap&&(y.envMapIntensity.value=v.envMapIntensity)}function m(y,v,S){y.ior.value=v.ior,v.sheen>0&&(y.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),y.sheenRoughness.value=v.sheenRoughness,v.sheenColorMap&&(y.sheenColorMap.value=v.sheenColorMap,t(v.sheenColorMap,y.sheenColorMapTransform)),v.sheenRoughnessMap&&(y.sheenRoughnessMap.value=v.sheenRoughnessMap,t(v.sheenRoughnessMap,y.sheenRoughnessMapTransform))),v.clearcoat>0&&(y.clearcoat.value=v.clearcoat,y.clearcoatRoughness.value=v.clearcoatRoughness,v.clearcoatMap&&(y.clearcoatMap.value=v.clearcoatMap,t(v.clearcoatMap,y.clearcoatMapTransform)),v.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap,t(v.clearcoatRoughnessMap,y.clearcoatRoughnessMapTransform)),v.clearcoatNormalMap&&(y.clearcoatNormalMap.value=v.clearcoatNormalMap,t(v.clearcoatNormalMap,y.clearcoatNormalMapTransform),y.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),v.side===sr&&y.clearcoatNormalScale.value.negate())),v.dispersion>0&&(y.dispersion.value=v.dispersion),v.iridescence>0&&(y.iridescence.value=v.iridescence,y.iridescenceIOR.value=v.iridescenceIOR,y.iridescenceThicknessMinimum.value=v.iridescenceThicknessRange[0],y.iridescenceThicknessMaximum.value=v.iridescenceThicknessRange[1],v.iridescenceMap&&(y.iridescenceMap.value=v.iridescenceMap,t(v.iridescenceMap,y.iridescenceMapTransform)),v.iridescenceThicknessMap&&(y.iridescenceThicknessMap.value=v.iridescenceThicknessMap,t(v.iridescenceThicknessMap,y.iridescenceThicknessMapTransform))),v.transmission>0&&(y.transmission.value=v.transmission,y.transmissionSamplerMap.value=S.texture,y.transmissionSamplerSize.value.set(S.width,S.height),v.transmissionMap&&(y.transmissionMap.value=v.transmissionMap,t(v.transmissionMap,y.transmissionMapTransform)),y.thickness.value=v.thickness,v.thicknessMap&&(y.thicknessMap.value=v.thicknessMap,t(v.thicknessMap,y.thicknessMapTransform)),y.attenuationDistance.value=v.attenuationDistance,y.attenuationColor.value.copy(v.attenuationColor)),v.anisotropy>0&&(y.anisotropyVector.value.set(v.anisotropy*Math.cos(v.anisotropyRotation),v.anisotropy*Math.sin(v.anisotropyRotation)),v.anisotropyMap&&(y.anisotropyMap.value=v.anisotropyMap,t(v.anisotropyMap,y.anisotropyMapTransform))),y.specularIntensity.value=v.specularIntensity,y.specularColor.value.copy(v.specularColor),v.specularColorMap&&(y.specularColorMap.value=v.specularColorMap,t(v.specularColorMap,y.specularColorMapTransform)),v.specularIntensityMap&&(y.specularIntensityMap.value=v.specularIntensityMap,t(v.specularIntensityMap,y.specularIntensityMapTransform))}function g(y,v){v.matcap&&(y.matcap.value=v.matcap)}function b(y,v){const S=e.get(v).light;y.referencePosition.value.setFromMatrixPosition(S.matrixWorld),y.nearDistance.value=S.shadow.camera.near,y.farDistance.value=S.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:r}}function GH(n,e,t,s){let r={},i={},o=[];const a=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function l(S,C){const _=C.program;s.uniformBlockBinding(S,_)}function c(S,C){let _=r[S.id];_===void 0&&(g(S),_=h(S),r[S.id]=_,S.addEventListener("dispose",y));const A=C.program;s.updateUBOMapping(S,A);const k=e.render.frame;i[S.id]!==k&&(p(S),i[S.id]=k)}function h(S){const C=d();S.__bindingPointIndex=C;const _=n.createBuffer(),A=S.__size,k=S.usage;return n.bindBuffer(n.UNIFORM_BUFFER,_),n.bufferData(n.UNIFORM_BUFFER,A,k),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,C,_),_}function d(){for(let S=0;S<a;S++)if(o.indexOf(S)===-1)return o.push(S),S;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function p(S){const C=r[S.id],_=S.uniforms,A=S.__cache;n.bindBuffer(n.UNIFORM_BUFFER,C);for(let k=0,N=_.length;k<N;k++){const D=Array.isArray(_[k])?_[k]:[_[k]];for(let M=0,T=D.length;M<T;M++){const I=D[M];if(m(I,k,M,A)===!0){const $=I.__offset,O=Array.isArray(I.value)?I.value:[I.value];let B=0;for(let V=0;V<O.length;V++){const H=O[V],q=b(H);typeof H=="number"||typeof H=="boolean"?(I.__data[0]=H,n.bufferSubData(n.UNIFORM_BUFFER,$+B,I.__data)):H.isMatrix3?(I.__data[0]=H.elements[0],I.__data[1]=H.elements[1],I.__data[2]=H.elements[2],I.__data[3]=0,I.__data[4]=H.elements[3],I.__data[5]=H.elements[4],I.__data[6]=H.elements[5],I.__data[7]=0,I.__data[8]=H.elements[6],I.__data[9]=H.elements[7],I.__data[10]=H.elements[8],I.__data[11]=0):(H.toArray(I.__data,B),B+=q.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,$,I.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function m(S,C,_,A){const k=S.value,N=C+"_"+_;if(A[N]===void 0)return typeof k=="number"||typeof k=="boolean"?A[N]=k:A[N]=k.clone(),!0;{const D=A[N];if(typeof k=="number"||typeof k=="boolean"){if(D!==k)return A[N]=k,!0}else if(D.equals(k)===!1)return D.copy(k),!0}return!1}function g(S){const C=S.uniforms;let _=0;const A=16;for(let N=0,D=C.length;N<D;N++){const M=Array.isArray(C[N])?C[N]:[C[N]];for(let T=0,I=M.length;T<I;T++){const $=M[T],O=Array.isArray($.value)?$.value:[$.value];for(let B=0,V=O.length;B<V;B++){const H=O[B],q=b(H),P=_%A,K=P%q.boundary,Z=P+K;_+=K,Z!==0&&A-Z<q.storage&&(_+=A-Z),$.__data=new Float32Array(q.storage/Float32Array.BYTES_PER_ELEMENT),$.__offset=_,_+=q.storage}}}const k=_%A;return k>0&&(_+=A-k),S.__size=_,S.__cache={},this}function b(S){const C={boundary:0,storage:0};return typeof S=="number"||typeof S=="boolean"?(C.boundary=4,C.storage=4):S.isVector2?(C.boundary=8,C.storage=8):S.isVector3||S.isColor?(C.boundary=16,C.storage=12):S.isVector4?(C.boundary=16,C.storage=16):S.isMatrix3?(C.boundary=48,C.storage=48):S.isMatrix4?(C.boundary=64,C.storage=64):S.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",S),C}function y(S){const C=S.target;C.removeEventListener("dispose",y);const _=o.indexOf(C.__bindingPointIndex);o.splice(_,1),n.deleteBuffer(r[C.id]),delete r[C.id],delete i[C.id]}function v(){for(const S in r)n.deleteBuffer(r[S]);o=[],r={},i={}}return{bind:l,update:c,dispose:v}}class pS{constructor(e={}){const{canvas:t=_B(),context:s=null,depth:r=!0,stencil:i=!1,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:d=!1,reverseDepthBuffer:p=!1}=e;this.isWebGLRenderer=!0;let m;if(s!==null){if(typeof WebGLRenderingContext<"u"&&s instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");m=s.getContextAttributes().alpha}else m=o;const g=new Uint32Array(4),b=new Int32Array(4);let y=null,v=null;const S=[],C=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=$a,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const _=this;let A=!1;this._outputColorSpace=ci;let k=0,N=0,D=null,M=-1,T=null;const I=new Xn,$=new Xn;let O=null;const B=new Gt(0);let V=0,H=t.width,q=t.height,P=1,K=null,Z=null;const U=new Xn(0,0,H,q),z=new Xn(0,0,H,q);let ne=!1;const Y=new uS;let te=!1,he=!1;const se=new An,Q=new An,de=new Ce,ce=new Xn,De={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let He=!1;function Le(){return D===null?P:1}let j=s;function ht(G,xe){return t.getContext(G,xe)}try{const G={alpha:!0,depth:r,stencil:i,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:d};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${eS}`),t.addEventListener("webglcontextlost",Fe,!1),t.addEventListener("webglcontextrestored",it,!1),t.addEventListener("webglcontextcreationerror",nt,!1),j===null){const xe="webgl2";if(j=ht(xe,G),j===null)throw ht(xe)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(G){throw console.error("THREE.WebGLRenderer: "+G.message),G}let We,Ke,Oe,yt,Ve,X,L,ge,Re,$e,Ie,Xe,ze,et,ut,Pe,lt,wt,Et,ct,Ot,$t,hn,ue;function tt(){We=new eW(j),We.init(),$t=new LH(j,We),Ke=new jG(j,We,e,$t),Oe=new $H(j,We),Ke.reverseDepthBuffer&&p&&Oe.buffers.depth.setReversed(!0),yt=new sW(j),Ve=new SH,X=new FH(j,We,Oe,Ve,Ke,$t,yt),L=new KG(_),ge=new JG(_),Re=new c4(j),hn=new HG(j,Re),$e=new tW(j,Re,yt,hn),Ie=new iW(j,$e,Re,yt),Et=new rW(j,Ke,X),Pe=new qG(Ve),Xe=new bH(_,L,ge,We,Ke,hn,Pe),ze=new VH(_,Ve),et=new _H,ut=new MH(We),wt=new WG(_,L,ge,Oe,Ie,m,l),lt=new NH(_,Ie,Ke),ue=new GH(j,yt,Ke,Oe),ct=new XG(j,We,yt),Ot=new nW(j,We,yt),yt.programs=Xe.programs,_.capabilities=Ke,_.extensions=We,_.properties=Ve,_.renderLists=et,_.shadowMap=lt,_.state=Oe,_.info=yt}tt();const ke=new zH(_,j);this.xr=ke,this.getContext=function(){return j},this.getContextAttributes=function(){return j.getContextAttributes()},this.forceContextLoss=function(){const G=We.get("WEBGL_lose_context");G&&G.loseContext()},this.forceContextRestore=function(){const G=We.get("WEBGL_lose_context");G&&G.restoreContext()},this.getPixelRatio=function(){return P},this.setPixelRatio=function(G){G!==void 0&&(P=G,this.setSize(H,q,!1))},this.getSize=function(G){return G.set(H,q)},this.setSize=function(G,xe,Te=!0){if(ke.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}H=G,q=xe,t.width=Math.floor(G*P),t.height=Math.floor(xe*P),Te===!0&&(t.style.width=G+"px",t.style.height=xe+"px"),this.setViewport(0,0,G,xe)},this.getDrawingBufferSize=function(G){return G.set(H*P,q*P).floor()},this.setDrawingBufferSize=function(G,xe,Te){H=G,q=xe,P=Te,t.width=Math.floor(G*Te),t.height=Math.floor(xe*Te),this.setViewport(0,0,G,xe)},this.getCurrentViewport=function(G){return G.copy(I)},this.getViewport=function(G){return G.copy(U)},this.setViewport=function(G,xe,Te,Se){G.isVector4?U.set(G.x,G.y,G.z,G.w):U.set(G,xe,Te,Se),Oe.viewport(I.copy(U).multiplyScalar(P).round())},this.getScissor=function(G){return G.copy(z)},this.setScissor=function(G,xe,Te,Se){G.isVector4?z.set(G.x,G.y,G.z,G.w):z.set(G,xe,Te,Se),Oe.scissor($.copy(z).multiplyScalar(P).round())},this.getScissorTest=function(){return ne},this.setScissorTest=function(G){Oe.setScissorTest(ne=G)},this.setOpaqueSort=function(G){K=G},this.setTransparentSort=function(G){Z=G},this.getClearColor=function(G){return G.copy(wt.getClearColor())},this.setClearColor=function(){wt.setClearColor(...arguments)},this.getClearAlpha=function(){return wt.getClearAlpha()},this.setClearAlpha=function(){wt.setClearAlpha(...arguments)},this.clear=function(G=!0,xe=!0,Te=!0){let Se=0;if(G){let ve=!1;if(D!==null){const Ze=D.texture.format;ve=Ze===lS||Ze===aS||Ze===oS}if(ve){const Ze=D.texture.type,st=Ze===Ui||Ze===Wl||Ze===nd||Ze===sd||Ze===sS||Ze===rS,dt=wt.getClearColor(),mt=wt.getClearAlpha(),Ft=dt.r,kt=dt.g,bt=dt.b;st?(g[0]=Ft,g[1]=kt,g[2]=bt,g[3]=mt,j.clearBufferuiv(j.COLOR,0,g)):(b[0]=Ft,b[1]=kt,b[2]=bt,b[3]=mt,j.clearBufferiv(j.COLOR,0,b))}else Se|=j.COLOR_BUFFER_BIT}xe&&(Se|=j.DEPTH_BUFFER_BIT),Te&&(Se|=j.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),j.clear(Se)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Fe,!1),t.removeEventListener("webglcontextrestored",it,!1),t.removeEventListener("webglcontextcreationerror",nt,!1),wt.dispose(),et.dispose(),ut.dispose(),Ve.dispose(),L.dispose(),ge.dispose(),Ie.dispose(),hn.dispose(),ue.dispose(),Xe.dispose(),ke.dispose(),ke.removeEventListener("sessionstart",Bt),ke.removeEventListener("sessionend",es),xn.stop()};function Fe(G){G.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),A=!0}function it(){console.log("THREE.WebGLRenderer: Context Restored."),A=!1;const G=yt.autoReset,xe=lt.enabled,Te=lt.autoUpdate,Se=lt.needsUpdate,ve=lt.type;tt(),yt.autoReset=G,lt.enabled=xe,lt.autoUpdate=Te,lt.needsUpdate=Se,lt.type=ve}function nt(G){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",G.statusMessage)}function Pt(G){const xe=G.target;xe.removeEventListener("dispose",Pt),Sn(xe)}function Sn(G){Jn(G),Ve.remove(G)}function Jn(G){const xe=Ve.get(G).programs;xe!==void 0&&(xe.forEach(function(Te){Xe.releaseProgram(Te)}),G.isShaderMaterial&&Xe.releaseShaderCache(G))}this.renderBufferDirect=function(G,xe,Te,Se,ve,Ze){xe===null&&(xe=De);const st=ve.isMesh&&ve.matrixWorld.determinant()<0,dt=Xf(G,xe,Te,Se,ve);Oe.setMaterial(Se,st);let mt=Te.index,Ft=1;if(Se.wireframe===!0){if(mt=$e.getWireframeAttribute(Te),mt===void 0)return;Ft=2}const kt=Te.drawRange,bt=Te.attributes.position;let nn=kt.start*Ft,Vt=(kt.start+kt.count)*Ft;Ze!==null&&(nn=Math.max(nn,Ze.start*Ft),Vt=Math.min(Vt,(Ze.start+Ze.count)*Ft)),mt!==null?(nn=Math.max(nn,0),Vt=Math.min(Vt,mt.count)):bt!=null&&(nn=Math.max(nn,0),Vt=Math.min(Vt,bt.count));const Gn=Vt-nn;if(Gn<0||Gn===1/0)return;hn.setup(ve,Se,dt,Te,mt);let Pn,an=ct;if(mt!==null&&(Pn=Re.get(mt),an=Ot,an.setIndex(Pn)),ve.isMesh)Se.wireframe===!0?(Oe.setLineWidth(Se.wireframeLinewidth*Le()),an.setMode(j.LINES)):an.setMode(j.TRIANGLES);else if(ve.isLine){let Tt=Se.linewidth;Tt===void 0&&(Tt=1),Oe.setLineWidth(Tt*Le()),ve.isLineSegments?an.setMode(j.LINES):ve.isLineLoop?an.setMode(j.LINE_LOOP):an.setMode(j.LINE_STRIP)}else ve.isPoints?an.setMode(j.POINTS):ve.isSprite&&an.setMode(j.TRIANGLES);if(ve.isBatchedMesh)if(ve._multiDrawInstances!==null)Xm("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),an.renderMultiDrawInstances(ve._multiDrawStarts,ve._multiDrawCounts,ve._multiDrawCount,ve._multiDrawInstances);else if(We.get("WEBGL_multi_draw"))an.renderMultiDraw(ve._multiDrawStarts,ve._multiDrawCounts,ve._multiDrawCount);else{const Tt=ve._multiDrawStarts,Wn=ve._multiDrawCounts,Qt=ve._multiDrawCount,Hs=mt?Re.get(mt).bytesPerElement:1,ea=Ve.get(Se).currentProgram.getUniforms();for(let lr=0;lr<Qt;lr++)ea.setValue(j,"_gl_DrawID",lr),an.render(Tt[lr]/Hs,Wn[lr])}else if(ve.isInstancedMesh)an.renderInstances(nn,Gn,ve.count);else if(Te.isInstancedBufferGeometry){const Tt=Te._maxInstanceCount!==void 0?Te._maxInstanceCount:1/0,Wn=Math.min(Te.instanceCount,Tt);an.renderInstances(nn,Gn,Wn)}else an.render(nn,Gn)};function tn(G,xe,Te){G.transparent===!0&&G.side===Oo&&G.forceSinglePass===!1?(G.side=sr,G.needsUpdate=!0,xc(G,xe,Te),G.side=Ua,G.needsUpdate=!0,xc(G,xe,Te),G.side=Oo):xc(G,xe,Te)}this.compile=function(G,xe,Te=null){Te===null&&(Te=G),v=ut.get(Te),v.init(xe),C.push(v),Te.traverseVisible(function(ve){ve.isLight&&ve.layers.test(xe.layers)&&(v.pushLight(ve),ve.castShadow&&v.pushShadow(ve))}),G!==Te&&G.traverseVisible(function(ve){ve.isLight&&ve.layers.test(xe.layers)&&(v.pushLight(ve),ve.castShadow&&v.pushShadow(ve))}),v.setupLights();const Se=new Set;return G.traverse(function(ve){if(!(ve.isMesh||ve.isPoints||ve.isLine||ve.isSprite))return;const Ze=ve.material;if(Ze)if(Array.isArray(Ze))for(let st=0;st<Ze.length;st++){const dt=Ze[st];tn(dt,Te,ve),Se.add(dt)}else tn(Ze,Te,ve),Se.add(Ze)}),v=C.pop(),Se},this.compileAsync=function(G,xe,Te=null){const Se=this.compile(G,xe,Te);return new Promise(ve=>{function Ze(){if(Se.forEach(function(st){Ve.get(st).currentProgram.isReady()&&Se.delete(st)}),Se.size===0){ve(G);return}setTimeout(Ze,10)}We.get("KHR_parallel_shader_compile")!==null?Ze():setTimeout(Ze,10)})};let Cn=null;function Ye(G){Cn&&Cn(G)}function Bt(){xn.stop()}function es(){xn.start()}const xn=new JM;xn.setAnimationLoop(Ye),typeof self<"u"&&xn.setContext(self),this.setAnimationLoop=function(G){Cn=G,ke.setAnimationLoop(G),G===null?xn.stop():xn.start()},ke.addEventListener("sessionstart",Bt),ke.addEventListener("sessionend",es),this.render=function(G,xe){if(xe!==void 0&&xe.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(A===!0)return;if(G.matrixWorldAutoUpdate===!0&&G.updateMatrixWorld(),xe.parent===null&&xe.matrixWorldAutoUpdate===!0&&xe.updateMatrixWorld(),ke.enabled===!0&&ke.isPresenting===!0&&(ke.cameraAutoUpdate===!0&&ke.updateCamera(xe),xe=ke.getCamera()),G.isScene===!0&&G.onBeforeRender(_,G,xe,D),v=ut.get(G,C.length),v.init(xe),C.push(v),Q.multiplyMatrices(xe.projectionMatrix,xe.matrixWorldInverse),Y.setFromProjectionMatrix(Q),he=this.localClippingEnabled,te=Pe.init(this.clippingPlanes,he),y=et.get(G,S.length),y.init(),S.push(y),ke.enabled===!0&&ke.isPresenting===!0){const Ze=_.xr.getDepthSensingMesh();Ze!==null&&ts(Ze,xe,-1/0,_.sortObjects)}ts(G,xe,0,_.sortObjects),y.finish(),_.sortObjects===!0&&y.sort(K,Z),He=ke.enabled===!1||ke.isPresenting===!1||ke.hasDepthSensing()===!1,He&&wt.addToRenderList(y,G),this.info.render.frame++,te===!0&&Pe.beginShadows();const Te=v.state.shadowsArray;lt.render(Te,G,xe),te===!0&&Pe.endShadows(),this.info.autoReset===!0&&this.info.reset();const Se=y.opaque,ve=y.transmissive;if(v.setupLights(),xe.isArrayCamera){const Ze=xe.cameras;if(ve.length>0)for(let st=0,dt=Ze.length;st<dt;st++){const mt=Ze[st];il(Se,ve,G,mt)}He&&wt.render(G);for(let st=0,dt=Ze.length;st<dt;st++){const mt=Ze[st];rl(y,G,mt,mt.viewport)}}else ve.length>0&&il(Se,ve,G,xe),He&&wt.render(G),rl(y,G,xe);D!==null&&N===0&&(X.updateMultisampleRenderTarget(D),X.updateRenderTargetMipmap(D)),G.isScene===!0&&G.onAfterRender(_,G,xe),hn.resetDefaultState(),M=-1,T=null,C.pop(),C.length>0?(v=C[C.length-1],te===!0&&Pe.setGlobalState(_.clippingPlanes,v.state.camera)):v=null,S.pop(),S.length>0?y=S[S.length-1]:y=null};function ts(G,xe,Te,Se){if(G.visible===!1)return;if(G.layers.test(xe.layers)){if(G.isGroup)Te=G.renderOrder;else if(G.isLOD)G.autoUpdate===!0&&G.update(xe);else if(G.isLight)v.pushLight(G),G.castShadow&&v.pushShadow(G);else if(G.isSprite){if(!G.frustumCulled||Y.intersectsSprite(G)){Se&&ce.setFromMatrixPosition(G.matrixWorld).applyMatrix4(Q);const st=Ie.update(G),dt=G.material;dt.visible&&y.push(G,st,dt,Te,ce.z,null)}}else if((G.isMesh||G.isLine||G.isPoints)&&(!G.frustumCulled||Y.intersectsObject(G))){const st=Ie.update(G),dt=G.material;if(Se&&(G.boundingSphere!==void 0?(G.boundingSphere===null&&G.computeBoundingSphere(),ce.copy(G.boundingSphere.center)):(st.boundingSphere===null&&st.computeBoundingSphere(),ce.copy(st.boundingSphere.center)),ce.applyMatrix4(G.matrixWorld).applyMatrix4(Q)),Array.isArray(dt)){const mt=st.groups;for(let Ft=0,kt=mt.length;Ft<kt;Ft++){const bt=mt[Ft],nn=dt[bt.materialIndex];nn&&nn.visible&&y.push(G,st,nn,Te,ce.z,bt)}}else dt.visible&&y.push(G,st,dt,Te,ce.z,null)}}const Ze=G.children;for(let st=0,dt=Ze.length;st<dt;st++)ts(Ze[st],xe,Te,Se)}function rl(G,xe,Te,Se){const ve=G.opaque,Ze=G.transmissive,st=G.transparent;v.setupLightsView(Te),te===!0&&Pe.setGlobalState(_.clippingPlanes,Te),Se&&Oe.viewport(I.copy(Se)),ve.length>0&&Jo(ve,xe,Te),Ze.length>0&&Jo(Ze,xe,Te),st.length>0&&Jo(st,xe,Te),Oe.buffers.depth.setTest(!0),Oe.buffers.depth.setMask(!0),Oe.buffers.color.setMask(!0),Oe.setPolygonOffset(!1)}function il(G,xe,Te,Se){if((Te.isScene===!0?Te.overrideMaterial:null)!==null)return;v.state.transmissionRenderTarget[Se.id]===void 0&&(v.state.transmissionRenderTarget[Se.id]=new za(1,1,{generateMipmaps:!0,type:We.has("EXT_color_buffer_half_float")||We.has("EXT_color_buffer_float")?wd:Ui,minFilter:Ll,samples:4,stencilBuffer:i,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:fn.workingColorSpace}));const Ze=v.state.transmissionRenderTarget[Se.id],st=Se.viewport||I;Ze.setSize(st.z*_.transmissionResolutionScale,st.w*_.transmissionResolutionScale);const dt=_.getRenderTarget();_.setRenderTarget(Ze),_.getClearColor(B),V=_.getClearAlpha(),V<1&&_.setClearColor(16777215,.5),_.clear(),He&&wt.render(Te);const mt=_.toneMapping;_.toneMapping=$a;const Ft=Se.viewport;if(Se.viewport!==void 0&&(Se.viewport=void 0),v.setupLightsView(Se),te===!0&&Pe.setGlobalState(_.clippingPlanes,Se),Jo(G,Te,Se),X.updateMultisampleRenderTarget(Ze),X.updateRenderTargetMipmap(Ze),We.has("WEBGL_multisampled_render_to_texture")===!1){let kt=!1;for(let bt=0,nn=xe.length;bt<nn;bt++){const Vt=xe[bt],Gn=Vt.object,Pn=Vt.geometry,an=Vt.material,Tt=Vt.group;if(an.side===Oo&&Gn.layers.test(Se.layers)){const Wn=an.side;an.side=sr,an.needsUpdate=!0,Wf(Gn,Te,Se,Pn,an,Tt),an.side=Wn,an.needsUpdate=!0,kt=!0}}kt===!0&&(X.updateMultisampleRenderTarget(Ze),X.updateRenderTargetMipmap(Ze))}_.setRenderTarget(dt),_.setClearColor(B,V),Ft!==void 0&&(Se.viewport=Ft),_.toneMapping=mt}function Jo(G,xe,Te){const Se=xe.isScene===!0?xe.overrideMaterial:null;for(let ve=0,Ze=G.length;ve<Ze;ve++){const st=G[ve],dt=st.object,mt=st.geometry,Ft=st.group;let kt=st.material;kt.allowOverride===!0&&Se!==null&&(kt=Se),dt.layers.test(Te.layers)&&Wf(dt,xe,Te,mt,kt,Ft)}}function Wf(G,xe,Te,Se,ve,Ze){G.onBeforeRender(_,xe,Te,Se,ve,Ze),G.modelViewMatrix.multiplyMatrices(Te.matrixWorldInverse,G.matrixWorld),G.normalMatrix.getNormalMatrix(G.modelViewMatrix),ve.onBeforeRender(_,xe,Te,Se,G,Ze),ve.transparent===!0&&ve.side===Oo&&ve.forceSinglePass===!1?(ve.side=sr,ve.needsUpdate=!0,_.renderBufferDirect(Te,xe,Se,ve,G,Ze),ve.side=Ua,ve.needsUpdate=!0,_.renderBufferDirect(Te,xe,Se,ve,G,Ze),ve.side=Oo):_.renderBufferDirect(Te,xe,Se,ve,G,Ze),G.onAfterRender(_,xe,Te,Se,ve,Ze)}function xc(G,xe,Te){xe.isScene!==!0&&(xe=De);const Se=Ve.get(G),ve=v.state.lights,Ze=v.state.shadowsArray,st=ve.state.version,dt=Xe.getParameters(G,ve.state,Ze,xe,Te),mt=Xe.getProgramCacheKey(dt);let Ft=Se.programs;Se.environment=G.isMeshStandardMaterial?xe.environment:null,Se.fog=xe.fog,Se.envMap=(G.isMeshStandardMaterial?ge:L).get(G.envMap||Se.environment),Se.envMapRotation=Se.environment!==null&&G.envMap===null?xe.environmentRotation:G.envMapRotation,Ft===void 0&&(G.addEventListener("dispose",Pt),Ft=new Map,Se.programs=Ft);let kt=Ft.get(mt);if(kt!==void 0){if(Se.currentProgram===kt&&Se.lightsStateVersion===st)return Wi(G,dt),kt}else dt.uniforms=Xe.getUniforms(G),G.onBeforeCompile(dt,_),kt=Xe.acquireProgram(dt,mt),Ft.set(mt,kt),Se.uniforms=dt.uniforms;const bt=Se.uniforms;return(!G.isShaderMaterial&&!G.isRawShaderMaterial||G.clipping===!0)&&(bt.clippingPlanes=Pe.uniform),Wi(G,dt),Se.needsLights=_x(G),Se.lightsStateVersion=st,Se.needsLights&&(bt.ambientLightColor.value=ve.state.ambient,bt.lightProbe.value=ve.state.probe,bt.directionalLights.value=ve.state.directional,bt.directionalLightShadows.value=ve.state.directionalShadow,bt.spotLights.value=ve.state.spot,bt.spotLightShadows.value=ve.state.spotShadow,bt.rectAreaLights.value=ve.state.rectArea,bt.ltc_1.value=ve.state.rectAreaLTC1,bt.ltc_2.value=ve.state.rectAreaLTC2,bt.pointLights.value=ve.state.point,bt.pointLightShadows.value=ve.state.pointShadow,bt.hemisphereLights.value=ve.state.hemi,bt.directionalShadowMap.value=ve.state.directionalShadowMap,bt.directionalShadowMatrix.value=ve.state.directionalShadowMatrix,bt.spotShadowMap.value=ve.state.spotShadowMap,bt.spotLightMatrix.value=ve.state.spotLightMatrix,bt.spotLightMap.value=ve.state.spotLightMap,bt.pointShadowMap.value=ve.state.pointShadowMap,bt.pointShadowMatrix.value=ve.state.pointShadowMatrix),Se.currentProgram=kt,Se.uniformsList=null,kt}function Hf(G){if(G.uniformsList===null){const xe=G.currentProgram.getUniforms();G.uniformsList=jm.seqWithValue(xe.seq,G.uniforms)}return G.uniformsList}function Wi(G,xe){const Te=Ve.get(G);Te.outputColorSpace=xe.outputColorSpace,Te.batching=xe.batching,Te.batchingColor=xe.batchingColor,Te.instancing=xe.instancing,Te.instancingColor=xe.instancingColor,Te.instancingMorph=xe.instancingMorph,Te.skinning=xe.skinning,Te.morphTargets=xe.morphTargets,Te.morphNormals=xe.morphNormals,Te.morphColors=xe.morphColors,Te.morphTargetsCount=xe.morphTargetsCount,Te.numClippingPlanes=xe.numClippingPlanes,Te.numIntersection=xe.numClipIntersection,Te.vertexAlphas=xe.vertexAlphas,Te.vertexTangents=xe.vertexTangents,Te.toneMapping=xe.toneMapping}function Xf(G,xe,Te,Se,ve){xe.isScene!==!0&&(xe=De),X.resetTextureUnits();const Ze=xe.fog,st=Se.isMeshStandardMaterial?xe.environment:null,dt=D===null?_.outputColorSpace:D.isXRRenderTarget===!0?D.texture.colorSpace:yu,mt=(Se.isMeshStandardMaterial?ge:L).get(Se.envMap||st),Ft=Se.vertexColors===!0&&!!Te.attributes.color&&Te.attributes.color.itemSize===4,kt=!!Te.attributes.tangent&&(!!Se.normalMap||Se.anisotropy>0),bt=!!Te.morphAttributes.position,nn=!!Te.morphAttributes.normal,Vt=!!Te.morphAttributes.color;let Gn=$a;Se.toneMapped&&(D===null||D.isXRRenderTarget===!0)&&(Gn=_.toneMapping);const Pn=Te.morphAttributes.position||Te.morphAttributes.normal||Te.morphAttributes.color,an=Pn!==void 0?Pn.length:0,Tt=Ve.get(Se),Wn=v.state.lights;if(te===!0&&(he===!0||G!==T)){const Fs=G===T&&Se.id===M;Pe.setState(Se,G,Fs)}let Qt=!1;Se.version===Tt.__version?(Tt.needsLights&&Tt.lightsStateVersion!==Wn.state.version||Tt.outputColorSpace!==dt||ve.isBatchedMesh&&Tt.batching===!1||!ve.isBatchedMesh&&Tt.batching===!0||ve.isBatchedMesh&&Tt.batchingColor===!0&&ve.colorTexture===null||ve.isBatchedMesh&&Tt.batchingColor===!1&&ve.colorTexture!==null||ve.isInstancedMesh&&Tt.instancing===!1||!ve.isInstancedMesh&&Tt.instancing===!0||ve.isSkinnedMesh&&Tt.skinning===!1||!ve.isSkinnedMesh&&Tt.skinning===!0||ve.isInstancedMesh&&Tt.instancingColor===!0&&ve.instanceColor===null||ve.isInstancedMesh&&Tt.instancingColor===!1&&ve.instanceColor!==null||ve.isInstancedMesh&&Tt.instancingMorph===!0&&ve.morphTexture===null||ve.isInstancedMesh&&Tt.instancingMorph===!1&&ve.morphTexture!==null||Tt.envMap!==mt||Se.fog===!0&&Tt.fog!==Ze||Tt.numClippingPlanes!==void 0&&(Tt.numClippingPlanes!==Pe.numPlanes||Tt.numIntersection!==Pe.numIntersection)||Tt.vertexAlphas!==Ft||Tt.vertexTangents!==kt||Tt.morphTargets!==bt||Tt.morphNormals!==nn||Tt.morphColors!==Vt||Tt.toneMapping!==Gn||Tt.morphTargetsCount!==an)&&(Qt=!0):(Qt=!0,Tt.__version=Se.version);let Hs=Tt.currentProgram;Qt===!0&&(Hs=xc(Se,xe,ve));let ea=!1,lr=!1,So=!1;const En=Hs.getUniforms(),Xs=Tt.uniforms;if(Oe.useProgram(Hs.program)&&(ea=!0,lr=!0,So=!0),Se.id!==M&&(M=Se.id,lr=!0),ea||T!==G){Oe.buffers.depth.getReversed()?(se.copy(G.projectionMatrix),EB(se),TB(se),En.setValue(j,"projectionMatrix",se)):En.setValue(j,"projectionMatrix",G.projectionMatrix),En.setValue(j,"viewMatrix",G.matrixWorldInverse);const Cs=En.map.cameraPosition;Cs!==void 0&&Cs.setValue(j,de.setFromMatrixPosition(G.matrixWorld)),Ke.logarithmicDepthBuffer&&En.setValue(j,"logDepthBufFC",2/(Math.log(G.far+1)/Math.LN2)),(Se.isMeshPhongMaterial||Se.isMeshToonMaterial||Se.isMeshLambertMaterial||Se.isMeshBasicMaterial||Se.isMeshStandardMaterial||Se.isShaderMaterial)&&En.setValue(j,"isOrthographic",G.isOrthographicCamera===!0),T!==G&&(T=G,lr=!0,So=!0)}if(ve.isSkinnedMesh){En.setOptional(j,ve,"bindMatrix"),En.setOptional(j,ve,"bindMatrixInverse");const Fs=ve.skeleton;Fs&&(Fs.boneTexture===null&&Fs.computeBoneTexture(),En.setValue(j,"boneTexture",Fs.boneTexture,X))}ve.isBatchedMesh&&(En.setOptional(j,ve,"batchingTexture"),En.setValue(j,"batchingTexture",ve._matricesTexture,X),En.setOptional(j,ve,"batchingIdTexture"),En.setValue(j,"batchingIdTexture",ve._indirectTexture,X),En.setOptional(j,ve,"batchingColorTexture"),ve._colorsTexture!==null&&En.setValue(j,"batchingColorTexture",ve._colorsTexture,X));const _s=Te.morphAttributes;if((_s.position!==void 0||_s.normal!==void 0||_s.color!==void 0)&&Et.update(ve,Te,Hs),(lr||Tt.receiveShadow!==ve.receiveShadow)&&(Tt.receiveShadow=ve.receiveShadow,En.setValue(j,"receiveShadow",ve.receiveShadow)),Se.isMeshGouraudMaterial&&Se.envMap!==null&&(Xs.envMap.value=mt,Xs.flipEnvMap.value=mt.isCubeTexture&&mt.isRenderTargetTexture===!1?-1:1),Se.isMeshStandardMaterial&&Se.envMap===null&&xe.environment!==null&&(Xs.envMapIntensity.value=xe.environmentIntensity),lr&&(En.setValue(j,"toneMappingExposure",_.toneMappingExposure),Tt.needsLights&&jf(Xs,So),Ze&&Se.fog===!0&&ze.refreshFogUniforms(Xs,Ze),ze.refreshMaterialUniforms(Xs,Se,P,q,v.state.transmissionRenderTarget[G.id]),jm.upload(j,Hf(Tt),Xs,X)),Se.isShaderMaterial&&Se.uniformsNeedUpdate===!0&&(jm.upload(j,Hf(Tt),Xs,X),Se.uniformsNeedUpdate=!1),Se.isSpriteMaterial&&En.setValue(j,"center",ve.center),En.setValue(j,"modelViewMatrix",ve.modelViewMatrix),En.setValue(j,"normalMatrix",ve.normalMatrix),En.setValue(j,"modelMatrix",ve.matrixWorld),Se.isShaderMaterial||Se.isRawShaderMaterial){const Fs=Se.uniformsGroups;for(let Cs=0,cn=Fs.length;Cs<cn;Cs++){const Hi=Fs[Cs];ue.update(Hi,Hs),ue.bind(Hi,Hs)}}return Hs}function jf(G,xe){G.ambientLightColor.needsUpdate=xe,G.lightProbe.needsUpdate=xe,G.directionalLights.needsUpdate=xe,G.directionalLightShadows.needsUpdate=xe,G.pointLights.needsUpdate=xe,G.pointLightShadows.needsUpdate=xe,G.spotLights.needsUpdate=xe,G.spotLightShadows.needsUpdate=xe,G.rectAreaLights.needsUpdate=xe,G.hemisphereLights.needsUpdate=xe}function _x(G){return G.isMeshLambertMaterial||G.isMeshToonMaterial||G.isMeshPhongMaterial||G.isMeshStandardMaterial||G.isShadowMaterial||G.isShaderMaterial&&G.lights===!0}this.getActiveCubeFace=function(){return k},this.getActiveMipmapLevel=function(){return N},this.getRenderTarget=function(){return D},this.setRenderTargetTextures=function(G,xe,Te){const Se=Ve.get(G);Se.__autoAllocateDepthBuffer=G.resolveDepthBuffer===!1,Se.__autoAllocateDepthBuffer===!1&&(Se.__useRenderToTexture=!1),Ve.get(G.texture).__webglTexture=xe,Ve.get(G.depthTexture).__webglTexture=Se.__autoAllocateDepthBuffer?void 0:Te,Se.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(G,xe){const Te=Ve.get(G);Te.__webglFramebuffer=xe,Te.__useDefaultFramebuffer=xe===void 0};const qf=j.createFramebuffer();this.setRenderTarget=function(G,xe=0,Te=0){D=G,k=xe,N=Te;let Se=!0,ve=null,Ze=!1,st=!1;if(G){const mt=Ve.get(G);if(mt.__useDefaultFramebuffer!==void 0)Oe.bindFramebuffer(j.FRAMEBUFFER,null),Se=!1;else if(mt.__webglFramebuffer===void 0)X.setupRenderTarget(G);else if(mt.__hasExternalTextures)X.rebindTextures(G,Ve.get(G.texture).__webglTexture,Ve.get(G.depthTexture).__webglTexture);else if(G.depthBuffer){const bt=G.depthTexture;if(mt.__boundDepthTexture!==bt){if(bt!==null&&Ve.has(bt)&&(G.width!==bt.image.width||G.height!==bt.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");X.setupDepthRenderbuffer(G)}}const Ft=G.texture;(Ft.isData3DTexture||Ft.isDataArrayTexture||Ft.isCompressedArrayTexture)&&(st=!0);const kt=Ve.get(G).__webglFramebuffer;G.isWebGLCubeRenderTarget?(Array.isArray(kt[xe])?ve=kt[xe][Te]:ve=kt[xe],Ze=!0):G.samples>0&&X.useMultisampledRTT(G)===!1?ve=Ve.get(G).__webglMultisampledFramebuffer:Array.isArray(kt)?ve=kt[Te]:ve=kt,I.copy(G.viewport),$.copy(G.scissor),O=G.scissorTest}else I.copy(U).multiplyScalar(P).floor(),$.copy(z).multiplyScalar(P).floor(),O=ne;if(Te!==0&&(ve=qf),Oe.bindFramebuffer(j.FRAMEBUFFER,ve)&&Se&&Oe.drawBuffers(G,ve),Oe.viewport(I),Oe.scissor($),Oe.setScissorTest(O),Ze){const mt=Ve.get(G.texture);j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_CUBE_MAP_POSITIVE_X+xe,mt.__webglTexture,Te)}else if(st){const mt=Ve.get(G.texture),Ft=xe;j.framebufferTextureLayer(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,mt.__webglTexture,Te,Ft)}else if(G!==null&&Te!==0){const mt=Ve.get(G.texture);j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,mt.__webglTexture,Te)}M=-1},this.readRenderTargetPixels=function(G,xe,Te,Se,ve,Ze,st){if(!(G&&G.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let dt=Ve.get(G).__webglFramebuffer;if(G.isWebGLCubeRenderTarget&&st!==void 0&&(dt=dt[st]),dt){Oe.bindFramebuffer(j.FRAMEBUFFER,dt);try{const mt=G.texture,Ft=mt.format,kt=mt.type;if(!Ke.textureFormatReadable(Ft)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Ke.textureTypeReadable(kt)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}xe>=0&&xe<=G.width-Se&&Te>=0&&Te<=G.height-ve&&j.readPixels(xe,Te,Se,ve,$t.convert(Ft),$t.convert(kt),Ze)}finally{const mt=D!==null?Ve.get(D).__webglFramebuffer:null;Oe.bindFramebuffer(j.FRAMEBUFFER,mt)}}},this.readRenderTargetPixelsAsync=async function(G,xe,Te,Se,ve,Ze,st){if(!(G&&G.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let dt=Ve.get(G).__webglFramebuffer;if(G.isWebGLCubeRenderTarget&&st!==void 0&&(dt=dt[st]),dt)if(xe>=0&&xe<=G.width-Se&&Te>=0&&Te<=G.height-ve){Oe.bindFramebuffer(j.FRAMEBUFFER,dt);const mt=G.texture,Ft=mt.format,kt=mt.type;if(!Ke.textureFormatReadable(Ft))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Ke.textureTypeReadable(kt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const bt=j.createBuffer();j.bindBuffer(j.PIXEL_PACK_BUFFER,bt),j.bufferData(j.PIXEL_PACK_BUFFER,Ze.byteLength,j.STREAM_READ),j.readPixels(xe,Te,Se,ve,$t.convert(Ft),$t.convert(kt),0);const nn=D!==null?Ve.get(D).__webglFramebuffer:null;Oe.bindFramebuffer(j.FRAMEBUFFER,nn);const Vt=j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE,0);return j.flush(),await CB(j,Vt,4),j.bindBuffer(j.PIXEL_PACK_BUFFER,bt),j.getBufferSubData(j.PIXEL_PACK_BUFFER,0,Ze),j.deleteBuffer(bt),j.deleteSync(Vt),Ze}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(G,xe=null,Te=0){const Se=Math.pow(2,-Te),ve=Math.floor(G.image.width*Se),Ze=Math.floor(G.image.height*Se),st=xe!==null?xe.x:0,dt=xe!==null?xe.y:0;X.setTexture2D(G,0),j.copyTexSubImage2D(j.TEXTURE_2D,Te,0,0,st,dt,ve,Ze),Oe.unbindTexture()};const Kf=j.createFramebuffer(),Yf=j.createFramebuffer();this.copyTextureToTexture=function(G,xe,Te=null,Se=null,ve=0,Ze=null){Ze===null&&(ve!==0?(Xm("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Ze=ve,ve=0):Ze=0);let st,dt,mt,Ft,kt,bt,nn,Vt,Gn;const Pn=G.isCompressedTexture?G.mipmaps[Ze]:G.image;if(Te!==null)st=Te.max.x-Te.min.x,dt=Te.max.y-Te.min.y,mt=Te.isBox3?Te.max.z-Te.min.z:1,Ft=Te.min.x,kt=Te.min.y,bt=Te.isBox3?Te.min.z:0;else{const _s=Math.pow(2,-ve);st=Math.floor(Pn.width*_s),dt=Math.floor(Pn.height*_s),G.isDataArrayTexture?mt=Pn.depth:G.isData3DTexture?mt=Math.floor(Pn.depth*_s):mt=1,Ft=0,kt=0,bt=0}Se!==null?(nn=Se.x,Vt=Se.y,Gn=Se.z):(nn=0,Vt=0,Gn=0);const an=$t.convert(xe.format),Tt=$t.convert(xe.type);let Wn;xe.isData3DTexture?(X.setTexture3D(xe,0),Wn=j.TEXTURE_3D):xe.isDataArrayTexture||xe.isCompressedArrayTexture?(X.setTexture2DArray(xe,0),Wn=j.TEXTURE_2D_ARRAY):(X.setTexture2D(xe,0),Wn=j.TEXTURE_2D),j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,xe.flipY),j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL,xe.premultiplyAlpha),j.pixelStorei(j.UNPACK_ALIGNMENT,xe.unpackAlignment);const Qt=j.getParameter(j.UNPACK_ROW_LENGTH),Hs=j.getParameter(j.UNPACK_IMAGE_HEIGHT),ea=j.getParameter(j.UNPACK_SKIP_PIXELS),lr=j.getParameter(j.UNPACK_SKIP_ROWS),So=j.getParameter(j.UNPACK_SKIP_IMAGES);j.pixelStorei(j.UNPACK_ROW_LENGTH,Pn.width),j.pixelStorei(j.UNPACK_IMAGE_HEIGHT,Pn.height),j.pixelStorei(j.UNPACK_SKIP_PIXELS,Ft),j.pixelStorei(j.UNPACK_SKIP_ROWS,kt),j.pixelStorei(j.UNPACK_SKIP_IMAGES,bt);const En=G.isDataArrayTexture||G.isData3DTexture,Xs=xe.isDataArrayTexture||xe.isData3DTexture;if(G.isDepthTexture){const _s=Ve.get(G),Fs=Ve.get(xe),Cs=Ve.get(_s.__renderTarget),cn=Ve.get(Fs.__renderTarget);Oe.bindFramebuffer(j.READ_FRAMEBUFFER,Cs.__webglFramebuffer),Oe.bindFramebuffer(j.DRAW_FRAMEBUFFER,cn.__webglFramebuffer);for(let Hi=0;Hi<mt;Hi++)En&&(j.framebufferTextureLayer(j.READ_FRAMEBUFFER,j.COLOR_ATTACHMENT0,Ve.get(G).__webglTexture,ve,bt+Hi),j.framebufferTextureLayer(j.DRAW_FRAMEBUFFER,j.COLOR_ATTACHMENT0,Ve.get(xe).__webglTexture,Ze,Gn+Hi)),j.blitFramebuffer(Ft,kt,st,dt,nn,Vt,st,dt,j.DEPTH_BUFFER_BIT,j.NEAREST);Oe.bindFramebuffer(j.READ_FRAMEBUFFER,null),Oe.bindFramebuffer(j.DRAW_FRAMEBUFFER,null)}else if(ve!==0||G.isRenderTargetTexture||Ve.has(G)){const _s=Ve.get(G),Fs=Ve.get(xe);Oe.bindFramebuffer(j.READ_FRAMEBUFFER,Kf),Oe.bindFramebuffer(j.DRAW_FRAMEBUFFER,Yf);for(let Cs=0;Cs<mt;Cs++)En?j.framebufferTextureLayer(j.READ_FRAMEBUFFER,j.COLOR_ATTACHMENT0,_s.__webglTexture,ve,bt+Cs):j.framebufferTexture2D(j.READ_FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,_s.__webglTexture,ve),Xs?j.framebufferTextureLayer(j.DRAW_FRAMEBUFFER,j.COLOR_ATTACHMENT0,Fs.__webglTexture,Ze,Gn+Cs):j.framebufferTexture2D(j.DRAW_FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,Fs.__webglTexture,Ze),ve!==0?j.blitFramebuffer(Ft,kt,st,dt,nn,Vt,st,dt,j.COLOR_BUFFER_BIT,j.NEAREST):Xs?j.copyTexSubImage3D(Wn,Ze,nn,Vt,Gn+Cs,Ft,kt,st,dt):j.copyTexSubImage2D(Wn,Ze,nn,Vt,Ft,kt,st,dt);Oe.bindFramebuffer(j.READ_FRAMEBUFFER,null),Oe.bindFramebuffer(j.DRAW_FRAMEBUFFER,null)}else Xs?G.isDataTexture||G.isData3DTexture?j.texSubImage3D(Wn,Ze,nn,Vt,Gn,st,dt,mt,an,Tt,Pn.data):xe.isCompressedArrayTexture?j.compressedTexSubImage3D(Wn,Ze,nn,Vt,Gn,st,dt,mt,an,Pn.data):j.texSubImage3D(Wn,Ze,nn,Vt,Gn,st,dt,mt,an,Tt,Pn):G.isDataTexture?j.texSubImage2D(j.TEXTURE_2D,Ze,nn,Vt,st,dt,an,Tt,Pn.data):G.isCompressedTexture?j.compressedTexSubImage2D(j.TEXTURE_2D,Ze,nn,Vt,Pn.width,Pn.height,an,Pn.data):j.texSubImage2D(j.TEXTURE_2D,Ze,nn,Vt,st,dt,an,Tt,Pn);j.pixelStorei(j.UNPACK_ROW_LENGTH,Qt),j.pixelStorei(j.UNPACK_IMAGE_HEIGHT,Hs),j.pixelStorei(j.UNPACK_SKIP_PIXELS,ea),j.pixelStorei(j.UNPACK_SKIP_ROWS,lr),j.pixelStorei(j.UNPACK_SKIP_IMAGES,So),Ze===0&&xe.generateMipmaps&&j.generateMipmap(Wn),Oe.unbindTexture()},this.copyTextureToTexture3D=function(G,xe,Te=null,Se=null,ve=0){return Xm('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(G,xe,Te,Se,ve)},this.initRenderTarget=function(G){Ve.get(G).__webglFramebuffer===void 0&&X.setupRenderTarget(G)},this.initTexture=function(G){G.isCubeTexture?X.setTextureCube(G,0):G.isData3DTexture?X.setTexture3D(G,0):G.isDataArrayTexture||G.isCompressedArrayTexture?X.setTexture2DArray(G,0):X.setTexture2D(G,0),Oe.unbindTexture()},this.resetState=function(){k=0,N=0,D=null,Oe.reset(),hn.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return zo}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=fn._getDrawingBufferColorSpace(e),t.unpackColorSpace=fn._getUnpackColorSpace()}}const BI=16007990,Cm={standard:{roughness:.2,metalness:.1,clearcoat:.5,clearcoatRoughness:.3,reflectivity:.5,envMapIntensity:.8},metal:{roughness:.1,metalness:.9,clearcoat:.8,clearcoatRoughness:.1,reflectivity:.9,envMapIntensity:1},glass:{roughness:0,metalness:0,clearcoat:1,clearcoatRoughness:.1,reflectivity:1,envMapIntensity:1,transmission:.9,ior:1.5},plastic:{roughness:.4,metalness:0,clearcoat:.8,clearcoatRoughness:.4,reflectivity:.3,envMapIntensity:.5},ceramic:{roughness:.3,metalness:0,clearcoat:.9,clearcoatRoughness:.2,reflectivity:.6,envMapIntensity:.7},glow:{roughness:.4,metalness:0,clearcoat:0,emissive:!0,emissiveIntensity:.5,reflectivity:.3,envMapIntensity:0},pearl:{roughness:.1,metalness:.2,clearcoat:1,clearcoatRoughness:.1,reflectivity:.8,envMapIntensity:.9,iridescence:1,iridescenceIOR:1.3},chrome:{roughness:0,metalness:1,clearcoat:1,clearcoatRoughness:0,reflectivity:1,envMapIntensity:1}},WH=({width:n=600,height:e=500,gridData:t,cameraDistance:s=20,rotationSpeed:r=0,cubeOpacity:i=1,cubeColor:o="#4CAF50",materialType:a="standard",showHelpers:l=!0,onCameraDistanceChange:c,onToggleHelpers:h,initialRotation:d={x:0,y:0},onRotationChange:p})=>{const m=Ae.useRef(null),g=Ae.useRef(null),b=Ae.useRef(null),y=Ae.useRef(null),v=Ae.useRef([]),S=Ae.useRef({axis:null,xLight:null,yLight:null,zLight:null,topLight1:null,topLight2:null,grid:null}),[C,_]=Ae.useState(""),[A,k]=Ae.useState(!1),[N,D]=Ae.useState({x:0,y:0}),[M,T]=Ae.useState(!1),[I,$]=Ae.useState(null),O=Ae.useRef(null);Ae.useEffect(()=>{if(console.log("[3DView] Setting up Three.js scene"),!!m.current){try{const z=new ad;z.background=new Gt(16777215),d&&(z.rotation.x=d.x,z.rotation.y=d.y,console.log(`[3DView] Applied initial rotation: x=${d.x}, y=${d.y}`)),b.current=z;const ne=n/e,Y=new Gr(60,ne,.1,1e3);Y.position.set(0,s*.3,s),Y.lookAt(0,0,0),y.current=Y;const te=new pS({antialias:!0,alpha:!0,powerPreference:"high-performance"});te.setSize(n,e),te.setPixelRatio(window.devicePixelRatio),te.shadowMap.enabled=!0,te.shadowMap.type=tS,te.outputEncoding=void 0,te.info.autoReset=!1,m.current.appendChild(te.domElement),g.current=te;const he=new YM(16777215,.4);z.add(he);const se=new kr(16772846,.8);se.position.set(15,5,0),se.castShadow=!0,se.shadow.mapSize.width=1024,se.shadow.mapSize.height=1024,se.shadow.camera.near=.5,se.shadow.camera.far=50,se.shadow.bias=-.001,z.add(se);const Q=new kr(15663086,.8);Q.position.set(0,15,5),Q.castShadow=!0,Q.shadow.mapSize.width=1024,Q.shadow.mapSize.height=1024,Q.shadow.camera.near=.5,Q.shadow.camera.far=50,Q.shadow.bias=-.001,z.add(Q);const de=new kr(15658751,.8);de.position.set(5,5,15),de.castShadow=!0,de.shadow.mapSize.width=1024,de.shadow.mapSize.height=1024,de.shadow.camera.near=.5,de.shadow.camera.far=50,de.shadow.bias=-.001,z.add(de);const ce=new kr(16777215,.7);ce.position.set(-10,20,-10),ce.castShadow=!0,ce.shadow.mapSize.width=1024,ce.shadow.mapSize.height=1024,ce.shadow.camera.near=.5,ce.shadow.camera.far=50,ce.shadow.bias=-.001,z.add(ce);const De=new kr(16777215,.7);De.position.set(10,20,10),De.castShadow=!0,De.shadow.mapSize.width=1024,De.shadow.mapSize.height=1024,De.shadow.camera.near=.5,De.shadow.camera.far=50,De.shadow.bias=-.001,z.add(De);const He=new kr(16777198,.3);He.position.set(-10,5,-10),z.add(He);const Le=new kr(16777215,.2);Le.position.set(0,-10,0),z.add(Le);const j=40,ht=new ld({color:16777215,side:sr,roughness:.9,metalness:.1}),We=new Os(new Wo(j,j,j),ht);We.receiveShadow=!0,z.add(We);const Ke=j-1,Oe=new oc(Ke,Ke),yt=new ld({color:16777215,roughness:.8,metalness:.2}),Ve=new Os(Oe,yt);Ve.rotation.x=-Math.PI/2,Ve.position.y=-j/2,Ve.receiveShadow=!0,z.add(Ve);const X=new ZM(Ke,20,15658734,15658734);X.position.y=-j/2+.01,z.add(X),S.current.grid=X;const L=new QM(3);z.add(L),S.current.axis=L;const ge=new ro(se,2,16711680);z.add(ge),S.current.xLight=ge;const Re=new ro(Q,2,65280);z.add(Re),S.current.yLight=Re;const $e=new ro(de,2,255);z.add($e),S.current.zLight=$e;const Ie=new ro(ce,2,16776960);z.add(Ie),S.current.topLight1=Ie;const Xe=new ro(De,2,16776960);z.add(Xe),S.current.topLight2=Xe,Object.values(S.current).forEach(Pe=>{Pe&&(Pe.visible=l)});const ze=new lg(te);ze.compileEquirectangularShader();const et=ze.fromScene(new ad),ut=et.texture;z.environment=ut,et.dispose(),ze.dispose()}catch(z){console.error("[3DView] Error setting up Three.js:",z),_(`Three.js setup error: ${z.message}`)}return()=>{console.log("[3DView] Cleaning up Three.js resources"),cancelAnimationFrame(O.current),I&&I.dispose(),g.current&&(m.current&&m.current.removeChild(g.current.domElement),g.current.dispose()),b.current&&(b.current.traverse(z=>{z.geometry&&z.geometry.dispose(),z.material&&(Array.isArray(z.material)?z.material.forEach(ne=>{ne.map&&ne.map.dispose(),ne.dispose()}):(z.material.map&&z.material.map.dispose(),z.material.dispose()))}),b.current.clear()),v.current=[]}}},[]),Ae.useEffect(()=>{var De,He,Le;if(!b.current||!t)return;console.log("[3DView] Updating cell grid display");const z=b.current;v.current.forEach(j=>{z.remove(j),j.geometry&&j.geometry.dispose(),j.material&&j.material.dispose()}),v.current=[];const ne=new Wo(.9,.9,.9,2,2,2),Y=t.length,te=((De=t[0])==null?void 0:De.length)||0,he=((Le=(He=t[0])==null?void 0:He[0])==null?void 0:Le.length)||0;if(!Y||!te||!he){console.warn("[3DView] Invalid grid dimensions:",Y,te,he);return}console.log("[3DView] Grid dimensions:",Y,te,he);const se=Y/2,Q=te/2,de=he/2;let ce=0;for(let j=0;j<Y;j++)for(let ht=0;ht<te;ht++)for(let We=0;We<he;We++){const Ke=t[j][ht][We];if(Ke===0)continue;ce++;const Oe=Ke===1?new Gt(o).getHex():BI,yt=Cm[a]||Cm.standard,Ve=new Z1({color:Oe,...yt,transparent:i<1||a==="glass",opacity:i,emissive:yt.emissive?Oe:0,emissiveIntensity:yt.emissiveIntensity||0,map:I}),X=new Os(ne,Ve);X.castShadow=!0,X.receiveShadow=!0,X.position.set(j-se,ht-Q,We-de),z.add(X),v.current.push(X)}console.log(`[3DView] Added ${ce} active cells to scene`)},[t,I]),Ae.useEffect(()=>{if(!y.current)return;const z=y.current,ne=z.position.clone().normalize();z.position.copy(ne.multiplyScalar(s))},[s]),Ae.useEffect(()=>{b.current&&(console.log("[3DView] Updating helper visibility:",l),Object.values(S.current).forEach(z=>{z&&(z.visible=l)}),g.current&&b.current&&y.current&&g.current.render(b.current,y.current))},[l]),Ae.useEffect(()=>{if(v.current.length>0){console.log("[3DView] Updating materials with:",{opacity:i,color:o,materialType:a,hasTexture:!!I});const z=Cm[a]||Cm.standard;v.current.forEach(ne=>{ne.material&&(ne.material.color&&ne.material.color.getHex()!==BI&&(ne.material.color.set(o),z.emissive?(ne.material.emissive.set(o),ne.material.emissiveIntensity=z.emissiveIntensity||0):(ne.material.emissive.set(0),ne.material.emissiveIntensity=0)),Object.entries(z).forEach(([Y,te])=>{Y!=="emissive"&&Y!=="emissiveIntensity"&&(ne.material[Y]=te)}),ne.material.transparent=i<1||a==="glass",ne.material.opacity=i,ne.material.map=I,ne.material.needsUpdate=!0)}),g.current&&b.current&&y.current&&g.current.render(b.current,y.current)}},[i,o,a,I]);const B=Ae.useCallback(z=>{k(!0),D({x:z.clientX,y:z.clientY})},[]),V=Ae.useCallback(z=>{if(!A||!b.current)return;const{x:ne,y:Y}=N,te=z.clientX-ne,he=z.clientY-Y;D({x:z.clientX,y:z.clientY});const se=b.current;se.rotation.y+=te*.01,se.rotation.x+=he*.01,p&&p({x:se.rotation.x,y:se.rotation.y})},[A,N]),H=Ae.useCallback(()=>{k(!1)},[]),q=Ae.useCallback(z=>{z.preventDefault();const Y=s+z.deltaY*.1,te=Math.max(10,Math.min(100,Y));te!==s&&c&&c(te)},[s,c]),P=Ae.useCallback(z=>{z.preventDefault(),z.stopPropagation(),T(!0)},[]),K=Ae.useCallback(z=>{z.preventDefault(),z.stopPropagation()},[]),Z=Ae.useCallback(z=>{z.preventDefault(),z.stopPropagation(),T(!1)},[]),U=Ae.useCallback(z=>{z.preventDefault(),z.stopPropagation(),T(!1);const ne=z.dataTransfer.files;if(ne&&ne.length>0){const Y=ne[0];if(Y.type.match(/image.*/)){const te=new FileReader;te.onload=he=>{const se=new Image;se.onload=()=>{if(g.current&&b.current){const Q=new qM().load(se.src);Q.wrapS=Gl,Q.wrapT=Gl,Q.repeat.set(1,1),$(Q),console.log("[3DView] Texture loaded from dropped image:",Y.name)}},se.src=he.target.result},te.readAsDataURL(Y)}else console.warn("[3DView] Dropped file is not an image:",Y.type)}},[]);return Ae.useEffect(()=>{if(!b.current||!g.current||!y.current)return;let z=0;const ne=Y=>{const te=z?Y-z:0;z=Y,b.current&&r>0&&(b.current.rotation.y+=r*5e-4*te,p&&p({x:b.current.rotation.x,y:b.current.rotation.y})),g.current&&b.current&&y.current&&g.current.render(b.current,y.current),O.current=requestAnimationFrame(ne)};return O.current=requestAnimationFrame(ne),()=>{O.current&&(cancelAnimationFrame(O.current),O.current=null)}},[r]),Ae.useEffect(()=>{const z=()=>{if(!g.current||!y.current)return;const ne=g.current,Y=y.current;Y.aspect=n/e,Y.updateProjectionMatrix(),ne.setSize(n,e)};return window.addEventListener("resize",z),()=>window.removeEventListener("resize",z)},[n,e]),C?pe.jsx("div",{style:{width:n,height:e,border:"1px solid red",padding:"10px",color:"red"},children:pe.jsxs("p",{children:["Error: ",C]})}):pe.jsxs("div",{children:[pe.jsx("div",{ref:m,style:{width:`${n}px`,height:`${e}px`,border:M?"3px dashed #4CAF50":"1px solid #444",cursor:A?"grabbing":"grab",position:"relative",transition:"border 0.2s ease-in-out"},onMouseDown:B,onMouseMove:V,onMouseUp:H,onMouseLeave:H,onWheel:q,onDragEnter:P,onDragOver:K,onDragLeave:Z,onDrop:U,children:M&&pe.jsx("div",{style:{position:"absolute",top:0,left:0,right:0,bottom:0,display:"flex",alignItems:"center",justifyContent:"center",backgroundColor:"rgba(76, 175, 80, 0.2)",zIndex:10,pointerEvents:"none"},children:pe.jsx("div",{style:{padding:"20px",backgroundColor:"rgba(255, 255, 255, 0.8)",borderRadius:"8px",boxShadow:"0 4px 8px rgba(0, 0, 0, 0.1)",textAlign:"center"},children:pe.jsx("p",{style:{margin:0,fontSize:"16px",fontWeight:"bold",color:"#4CAF50"},children:"Drop image to use as cube texture"})})})}),pe.jsxs("div",{style:{fontSize:"0.8em",color:"#333",textAlign:"center",marginTop:"5px",background:"#f0f0f0",padding:"3px",borderRadius:"4px",border:"1px solid #ddd",display:"flex",justifyContent:"space-between"},children:[pe.jsx("span",{children:"Drag to rotate | Use mouse wheel to zoom in/out"}),pe.jsx("span",{style:{fontWeight:I?"bold":"normal",color:I?"#4CAF50":"#777"},children:I?"✓ Texture applied":"Drag & drop image for texture"})]}),I&&pe.jsx("div",{style:{marginTop:"5px",textAlign:"center"},children:pe.jsx("button",{onClick:()=>$(null),style:{padding:"3px 8px",fontSize:"0.8em",backgroundColor:"#f44336",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Remove Texture"})})]})},HH=16007990,Em={standard:{roughness:.2,metalness:.1,clearcoat:.5,clearcoatRoughness:.3,reflectivity:.5,envMapIntensity:.8},metal:{roughness:.1,metalness:.9,clearcoat:.8,clearcoatRoughness:.1,reflectivity:.9,envMapIntensity:1},glass:{roughness:0,metalness:0,clearcoat:1,clearcoatRoughness:.1,reflectivity:1,envMapIntensity:1,transmission:.9,ior:1.5},plastic:{roughness:.4,metalness:0,clearcoat:.8,clearcoatRoughness:.4,reflectivity:.3,envMapIntensity:.5},ceramic:{roughness:.3,metalness:0,clearcoat:.9,clearcoatRoughness:.2,reflectivity:.6,envMapIntensity:.7},glow:{roughness:.4,metalness:0,clearcoat:0,emissive:!0,emissiveIntensity:.5,reflectivity:.3,envMapIntensity:0},pearl:{roughness:.1,metalness:.2,clearcoat:1,clearcoatRoughness:.1,reflectivity:.8,envMapIntensity:.9,iridescence:1,iridescenceIOR:1.3},chrome:{roughness:0,metalness:1,clearcoat:1,clearcoatRoughness:0,reflectivity:1,envMapIntensity:1}},XH=({width:n=600,height:e=500,gridData:t,cameraDistance:s=20,rotationSpeed:r=0,cubeOpacity:i=1,cubeColor:o="#4CAF50",materialType:a="standard",showHelpers:l=!0,onCameraDistanceChange:c,showStats:h=!1,initialRotation:d={x:0,y:0},onRotationChange:p})=>{const m=Ae.useRef(null),g=Ae.useRef(null),b=Ae.useRef(null),y=Ae.useRef(null),v=Ae.useRef(null),S=Ae.useRef(null),C=Ae.useRef({axis:null,xLight:null,yLight:null,zLight:null,topLight1:null,topLight2:null,grid:null}),[_,A]=Ae.useState(""),[k,N]=Ae.useState(!1),[D,M]=Ae.useState({x:0,y:0}),[T,I]=Ae.useState(!1),[$,O]=Ae.useState(null),B=Ae.useRef(null),[V,H]=Ae.useState({fps:0,drawCalls:0,triangles:0,activeCells:0,lastUpdated:Date.now()}),q=Ae.useRef({lastTime:0,frames:0,fps:0}),P=Ae.useMemo(()=>{var De,He,Le;if(!t)return{sizeX:0,sizeY:0,sizeZ:0,centerX:0,centerY:0,centerZ:0};const Q=t.length,de=((De=t[0])==null?void 0:De.length)||0,ce=((Le=(He=t[0])==null?void 0:He[0])==null?void 0:Le.length)||0;return{sizeX:Q,sizeY:de,sizeZ:ce,centerX:Q/2,centerY:de/2,centerZ:ce/2,totalCells:Q*de*ce}},[t]);Ae.useEffect(()=>{if(console.log("[3DViewInstanced] Setting up Three.js scene"),!!m.current){try{const Q=new ad;Q.background=new Gt(16777215),d&&(Q.rotation.x=d.x,Q.rotation.y=d.y,console.log(`[3DViewInstanced] Applied initial rotation: x=${d.x}, y=${d.y}`)),b.current=Q;const de=n/e,ce=new Gr(60,de,.1,1e3);ce.position.set(0,s*.3,s),ce.lookAt(0,0,0),y.current=ce;const De=new pS({antialias:!0,alpha:!0,powerPreference:"high-performance"});De.setSize(n,e),De.setPixelRatio(window.devicePixelRatio),De.shadowMap.enabled=!0,De.shadowMap.type=tS,De.outputEncoding=void 0,De.info.autoReset=!1,De.info.reset(),console.log("[3DViewInstanced] Renderer info initialized:",De.info),m.current.appendChild(De.domElement),g.current=De;const He=new YM(16777215,.4);Q.add(He);const Le=new kr(16772846,.8);Le.position.set(15,5,0),Le.castShadow=!0,Le.shadow.mapSize.width=1024,Le.shadow.mapSize.height=1024,Le.shadow.camera.near=.5,Le.shadow.camera.far=50,Le.shadow.bias=-.001,Q.add(Le);const j=new kr(15663086,.8);j.position.set(0,15,5),j.castShadow=!0,j.shadow.mapSize.width=1024,j.shadow.mapSize.height=1024,j.shadow.camera.near=.5,j.shadow.camera.far=50,j.shadow.bias=-.001,Q.add(j);const ht=new kr(15658751,.8);ht.position.set(5,5,15),ht.castShadow=!0,ht.shadow.mapSize.width=1024,ht.shadow.mapSize.height=1024,ht.shadow.camera.near=.5,ht.shadow.camera.far=50,ht.shadow.bias=-.001,Q.add(ht);const We=new kr(16777215,.7);We.position.set(-10,20,-10),We.castShadow=!0,We.shadow.mapSize.width=1024,We.shadow.mapSize.height=1024,We.shadow.camera.near=.5,We.shadow.camera.far=50,We.shadow.bias=-.001,Q.add(We);const Ke=new kr(16777215,.7);Ke.position.set(10,20,10),Ke.castShadow=!0,Ke.shadow.mapSize.width=1024,Ke.shadow.mapSize.height=1024,Ke.shadow.camera.near=.5,Ke.shadow.camera.far=50,Ke.shadow.bias=-.001,Q.add(Ke);const Oe=new kr(16777198,.3);Oe.position.set(-10,5,-10),Q.add(Oe);const yt=new kr(16777215,.2);yt.position.set(0,-10,0),Q.add(yt);const Ve=40,X=new ld({color:16777215,side:sr,roughness:.9,metalness:.1}),L=new Os(new Wo(Ve,Ve,Ve),X);L.receiveShadow=!0,Q.add(L);const ge=Ve-1,Re=new oc(ge,ge),$e=new ld({color:16777215,roughness:.8,metalness:.2}),Ie=new Os(Re,$e);Ie.rotation.x=-Math.PI/2,Ie.position.y=-Ve/2,Ie.receiveShadow=!0,Q.add(Ie);const Xe=new ZM(ge,20,15658734,15658734);Xe.position.y=-Ve/2+.01,Q.add(Xe),C.current.grid=Xe;const ze=new QM(3);Q.add(ze),C.current.axis=ze;const et=new ro(Le,2,16711680);Q.add(et),C.current.xLight=et;const ut=new ro(j,2,65280);Q.add(ut),C.current.yLight=ut;const Pe=new ro(ht,2,255);Q.add(Pe),C.current.zLight=Pe;const lt=new ro(We,2,16776960);Q.add(lt),C.current.topLight1=lt;const wt=new ro(Ke,2,16776960);Q.add(wt),C.current.topLight2=wt,Object.values(C.current).forEach($t=>{$t&&($t.visible=l)});const Et=new lg(De);Et.compileEquirectangularShader();const ct=Et.fromScene(new ad),Ot=ct.texture;Q.environment=Ot,ct.dispose(),Et.dispose()}catch(Q){console.error("[3DViewInstanced] Error setting up Three.js:",Q),A(`Three.js setup error: ${Q.message}`)}return()=>{console.log("[3DViewInstanced] Cleaning up Three.js resources"),cancelAnimationFrame(B.current),$&&$.dispose(),g.current&&(m.current&&m.current.removeChild(g.current.domElement),g.current.dispose()),b.current&&(b.current.traverse(Q=>{Q.geometry&&Q.geometry.dispose(),Q.material&&(Array.isArray(Q.material)?Q.material.forEach(de=>{de.map&&de.map.dispose(),de.dispose()}):(Q.material.map&&Q.material.map.dispose(),Q.material.dispose()))}),b.current.clear())}}},[n,e,s]);const K=Ae.useRef(null);Ae.useEffect(()=>{if(!b.current)return;if(t)K.current=t;else if(!K.current)return;const Q=t||K.current;console.log("[3DViewInstanced] Updating cell grid display with instanced rendering");const de=b.current;v.current&&(de.remove(v.current),v.current.geometry.dispose(),v.current.material.dispose(),v.current=null),S.current&&(de.remove(S.current),S.current.geometry.dispose(),S.current.material.dispose(),S.current=null);const{sizeX:ce,sizeY:De,sizeZ:He,centerX:Le,centerY:j,centerZ:ht}=P;if(ce===0||De===0||He===0){console.warn("[3DViewInstanced] Invalid grid dimensions:",ce,De,He);return}console.log("[3DViewInstanced] Grid dimensions:",ce,De,He);const We=new Wo(.9,.9,.9,2,2,2),Ke=Em[a]||Em.standard,Oe=new Gt(o).getHex(),yt=new Z1({color:Oe,...Ke,transparent:i<1||a==="glass",opacity:i,emissive:Ke.emissive?Oe:0,emissiveIntensity:Ke.emissiveIntensity||0,map:$}),Ve=new Z1({color:HH,...Ke,transparent:i<1||a==="glass",opacity:i,map:$});let X=0,L=0;for(let Xe=0;Xe<ce;Xe++)for(let ze=0;ze<De;ze++)for(let et=0;et<He;et++){const ut=Q[Xe][ze][et];ut===1?X++:ut===2&&L++}console.log(`[3DViewInstanced] Cell counts - Alive: ${X}, Dying: ${L}`),X===0&&(console.log("[3DViewInstanced] No alive cells found, creating test cube"),X=1);const ge=new aI(We,yt,Math.max(1,X));if(ge.castShadow=!0,ge.receiveShadow=!0,v.current=ge,de.add(ge),L>0){const Xe=new aI(We,Ve,L);Xe.castShadow=!0,Xe.receiveShadow=!0,S.current=Xe,de.add(Xe)}let Re=0,$e=0;const Ie=new An;if(X===1&&!Q.some(Xe=>Xe.some(ze=>ze.some(et=>et===1))))Ie.identity(),v.current.setMatrixAt(0,Ie),v.current.instanceMatrix.needsUpdate=!0;else{for(let Xe=0;Xe<ce;Xe++)for(let ze=0;ze<De;ze++)for(let et=0;et<He;et++){const ut=Q[Xe][ze][et];ut!==0&&(Ie.makeTranslation(Xe-Le,ze-j,et-ht),ut===1&&v.current?(v.current.setMatrixAt(Re,Ie),Re++):ut===2&&S.current&&(S.current.setMatrixAt($e,Ie),$e++))}v.current&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere()),S.current&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere())}H(Xe=>({...Xe,activeCells:X+L})),console.log(`[3DViewInstanced] Instanced rendering setup complete with ${X+L} total cells`),g.current&&y.current&&g.current.render(de,y.current)},[t,P,o,a,i,$]),Ae.useEffect(()=>{b.current&&(console.log("[3DViewInstanced] Updating helper visibility:",l),Object.values(C.current).forEach(Q=>{Q&&(Q.visible=l)}),g.current&&b.current&&y.current&&g.current.render(b.current,y.current))},[l]),Ae.useEffect(()=>{if(v.current||S.current){console.log("[3DViewInstanced] Updating materials with:",{opacity:i,color:o,materialType:a,hasTexture:!!$});const Q=Em[a]||Em.standard;if(v.current&&v.current.material){const de=v.current.material;de.color.set(o),Q.emissive?(de.emissive.set(o),de.emissiveIntensity=Q.emissiveIntensity||0):(de.emissive.set(0),de.emissiveIntensity=0),Object.entries(Q).forEach(([ce,De])=>{ce!=="emissive"&&ce!=="emissiveIntensity"&&(de[ce]=De)}),de.transparent=i<1||a==="glass",de.opacity=i,de.map=$,de.needsUpdate=!0}if(S.current&&S.current.material){const de=S.current.material;Object.entries(Q).forEach(([ce,De])=>{ce!=="emissive"&&ce!=="emissiveIntensity"&&(de[ce]=De)}),de.transparent=i<1||a==="glass",de.opacity=i,de.map=$,de.needsUpdate=!0}g.current&&b.current&&y.current&&g.current.render(b.current,y.current)}},[i,o,a,$]),Ae.useEffect(()=>{if(!y.current)return;console.log(`[3DViewInstanced] Updating camera distance to ${s}`);const Q=y.current,de=Q.position.clone().normalize();if(Q.position.copy(de.multiplyScalar(s)),Q.lookAt(0,0,0),b.current){const ce=b.current;let De=!1;v.current&&!ce.children.includes(v.current)&&(console.log("[3DViewInstanced] Re-adding missing instanced mesh during camera update"),ce.add(v.current),De=!0),S.current&&!ce.children.includes(S.current)&&(console.log("[3DViewInstanced] Re-adding missing dying instanced mesh during camera update"),ce.add(S.current),De=!0),De&&(v.current&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere()),S.current&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere()))}g.current&&b.current&&(console.log("[3DViewInstanced] Forcing render after camera position update"),g.current.render(b.current,Q),requestAnimationFrame(()=>{if(g.current&&b.current&&y.current){const ce=b.current;v.current&&!ce.children.includes(v.current)&&ce.add(v.current),S.current&&!ce.children.includes(S.current)&&ce.add(S.current),g.current.render(ce,Q)}}))},[s]);const Z=Ae.useCallback(Q=>{N(!0),M({x:Q.clientX,y:Q.clientY})},[]),U=Ae.useCallback(Q=>{if(!k||!b.current||!g.current||!y.current)return;const{x:de,y:ce}=D,De=Q.clientX-de,He=Q.clientY-ce;M({x:Q.clientX,y:Q.clientY});const Le=b.current;Le.rotation.y+=De*.01,Le.rotation.x+=He*.01,p&&p({x:Le.rotation.x,y:Le.rotation.y});let j=!1;v.current&&!Le.children.includes(v.current)&&(console.log("[3DViewInstanced] Re-adding missing instanced mesh during rotation"),Le.add(v.current),j=!0),S.current&&!Le.children.includes(S.current)&&(console.log("[3DViewInstanced] Re-adding missing dying instanced mesh during rotation"),Le.add(S.current),j=!0),j&&(v.current&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere()),S.current&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere())),g.current.render(Le,y.current),requestAnimationFrame(()=>{g.current&&b.current&&y.current&&g.current.render(b.current,y.current)})},[k,D]),z=Ae.useCallback(()=>{if(N(!1),g.current&&b.current&&y.current){const Q=b.current;let de=!1;v.current&&!Q.children.includes(v.current)&&(console.log("[3DViewInstanced] Re-adding missing instanced mesh after drag"),Q.add(v.current),de=!0),S.current&&!Q.children.includes(S.current)&&(console.log("[3DViewInstanced] Re-adding missing dying instanced mesh after drag"),Q.add(S.current),de=!0),de&&(v.current&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere()),S.current&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere())),g.current.render(Q,y.current),requestAnimationFrame(()=>{g.current&&b.current&&y.current&&g.current.render(b.current,y.current)})}},[g,b,y,v,S]),ne=Ae.useCallback(Q=>{if(Q.preventDefault(),Q.stopPropagation(),!y.current||!g.current||!b.current){console.warn("[3DViewInstanced] Wheel event: Missing refs");return}const ce=s+Q.deltaY*.1,De=Math.max(10,Math.min(100,ce));console.log(`[3DViewInstanced] Wheel event - deltaY: ${Q.deltaY}, newDistance: ${ce}, clampedDistance: ${De}`);const He=y.current,Le=He.position.clone().normalize();He.position.copy(Le.multiplyScalar(De)),He.lookAt(0,0,0);const j=b.current,ht=g.current;let We=!1;v.current&&!j.children.includes(v.current)&&(console.log("[3DViewInstanced] Re-adding missing instanced mesh during zoom"),j.add(v.current),We=!0),S.current&&!j.children.includes(S.current)&&(console.log("[3DViewInstanced] Re-adding missing dying instanced mesh during zoom"),j.add(S.current),We=!0),We&&K.current&&(console.log("[3DViewInstanced] Meshes were reinstated, rebuilding with saved grid data"),v.current&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere()),S.current&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere())),ht.render(j,He);let Ke=0;const Oe=()=>{if(Ke<5&&g.current&&b.current&&y.current){const yt=b.current;v.current&&!yt.children.includes(v.current)&&(console.log(`[3DViewInstanced] Re-adding mesh in frame ${Ke}`),yt.add(v.current),v.current.instanceMatrix&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere())),S.current&&!yt.children.includes(S.current)&&(console.log(`[3DViewInstanced] Re-adding dying mesh in frame ${Ke}`),yt.add(S.current),S.current.instanceMatrix&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere())),g.current.render(yt,y.current),Ke++,requestAnimationFrame(Oe)}};requestAnimationFrame(Oe),c&&De!==s&&c(De)},[s,c,K]),Y=Ae.useCallback(Q=>{Q.preventDefault(),Q.stopPropagation(),I(!0)},[]),te=Ae.useCallback(Q=>{Q.preventDefault(),Q.stopPropagation()},[]),he=Ae.useCallback(Q=>{Q.preventDefault(),Q.stopPropagation(),I(!1)},[]),se=Ae.useCallback(Q=>{Q.preventDefault(),Q.stopPropagation(),I(!1);const de=Q.dataTransfer.files;if(de&&de.length>0){const ce=de[0];if(ce.type.match(/image.*/)){const De=new FileReader;De.onload=He=>{const Le=new Image;Le.onload=()=>{if(g.current&&b.current){const j=new qM().load(Le.src);j.wrapS=Gl,j.wrapT=Gl,j.repeat.set(1,1),O(j),console.log("[3DViewInstanced] Texture loaded from dropped image:",ce.name)}},Le.src=He.target.result},De.readAsDataURL(ce)}else console.warn("[3DViewInstanced] Dropped file is not an image:",ce.type)}},[]);return Ae.useEffect(()=>{if(!b.current||!g.current||!y.current)return;console.log("[3DViewInstanced] Setting up animation loop");let Q=0;q.current.lastTime=performance.now(),q.current.frames=0,B.current&&cancelAnimationFrame(B.current);let de=!1;const ce=De=>{const He=b.current,Le=g.current,j=y.current;if(!He||!Le||!j){console.warn("[3DViewInstanced] Refs not available in animation frame, stopping loop");return}const ht=Q?De-Q:0;Q=De,He&&r>0&&(He.rotation.y+=r*5e-4*ht,p&&p({x:He.rotation.x,y:He.rotation.y}));try{de=!1,v.current&&!He.children.includes(v.current)&&(console.log("[3DViewInstanced] Re-adding missing instanced mesh to scene"),He.add(v.current),v.current.instanceMatrix&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere()),de=!0),S.current&&!He.children.includes(S.current)&&(console.log("[3DViewInstanced] Re-adding missing dying instanced mesh to scene"),He.add(S.current),S.current.instanceMatrix&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere()),de=!0),de&&K.current&&P.sizeX>0&&(console.log("[3DViewInstanced] Mesh reinstated during animation, ensuring instances are set up"),v.current&&(v.current.instanceMatrix.needsUpdate=!0,v.current.computeBoundingSphere()),S.current&&(S.current.instanceMatrix.needsUpdate=!0,S.current.computeBoundingSphere()));const We=Le.info.render,Ke=We.calls||0,Oe=We.triangles||0;Le.render(He,j),q.current.frames++;const yt=performance.now(),Ve=yt-q.current.lastTime;if(Ve>=1e3){const X=Math.round(q.current.frames*1e3/Ve);q.current.fps=X,q.current.frames=0,q.current.lastTime=yt,console.log("[3DViewInstanced] Render stats:",{calls:Ke,triangles:Oe,frame:We.frame}),Le.info.reset(),H(L=>({...L,fps:X,drawCalls:Ke,triangles:Oe,lastUpdated:yt}))}}catch(We){console.error("[3DViewInstanced] Error in animation frame:",We)}B.current=requestAnimationFrame(ce)};return B.current=requestAnimationFrame(ce),console.log("[3DViewInstanced] Animation loop started"),g.current&&b.current&&y.current&&(g.current.render(b.current,y.current),requestAnimationFrame(()=>{g.current&&b.current&&y.current&&g.current.render(b.current,y.current)})),()=>{if(console.log("[3DViewInstanced] Cleaning up animation loop"),B.current&&(cancelAnimationFrame(B.current),B.current=null),g.current&&b.current&&y.current){const De=b.current;v.current&&!De.children.includes(v.current)&&De.add(v.current),S.current&&!De.children.includes(S.current)&&De.add(S.current),g.current.render(De,y.current)}}},[r]),Ae.useEffect(()=>{const Q=()=>{if(!g.current||!y.current)return;const de=g.current,ce=y.current;ce.aspect=n/e,ce.updateProjectionMatrix(),de.setSize(n,e)};return window.addEventListener("resize",Q),()=>window.removeEventListener("resize",Q)},[n,e]),_?pe.jsx("div",{style:{width:n,height:e,border:"1px solid red",padding:"10px",color:"red"},children:pe.jsxs("p",{children:["Error: ",_]})}):pe.jsxs("div",{children:[pe.jsxs("div",{ref:m,style:{width:`${n}px`,height:`${e}px`,border:T?"3px dashed #4CAF50":"1px solid #444",cursor:k?"grabbing":"grab",position:"relative",transition:"border 0.2s ease-in-out"},onMouseDown:Z,onMouseMove:U,onMouseUp:z,onMouseLeave:z,onWheel:ne,onDragEnter:Y,onDragOver:te,onDragLeave:he,onDrop:se,children:[T&&pe.jsx("div",{style:{position:"absolute",top:0,left:0,right:0,bottom:0,display:"flex",alignItems:"center",justifyContent:"center",backgroundColor:"rgba(76, 175, 80, 0.2)",zIndex:10,pointerEvents:"none"},children:pe.jsx("div",{style:{padding:"20px",backgroundColor:"rgba(255, 255, 255, 0.8)",borderRadius:"8px",boxShadow:"0 4px 8px rgba(0, 0, 0, 0.1)",textAlign:"center"},children:pe.jsx("p",{style:{margin:0,fontSize:"16px",fontWeight:"bold",color:"#4CAF50"},children:"Drop image to use as cube texture"})})}),h&&pe.jsxs("div",{style:{position:"absolute",top:5,right:5,padding:"8px 10px",backgroundColor:"rgba(0, 0, 0, 0.7)",color:"white",borderRadius:"6px",fontSize:"12px",fontFamily:"monospace",zIndex:100,pointerEvents:"none",minWidth:"220px",boxShadow:"0 2px 4px rgba(0,0,0,0.3)"},children:[pe.jsxs("div",{style:{fontSize:"14px",fontWeight:"bold",marginBottom:"5px",borderBottom:"1px solid rgba(255,255,255,0.4)",paddingBottom:"3px",display:"flex",justifyContent:"space-between",alignItems:"center"},children:[pe.jsx("span",{children:"GPU Stats"}),pe.jsx("span",{style:{backgroundColor:"#8e44ad",color:"white",fontSize:"10px",padding:"2px 5px",borderRadius:"3px",textTransform:"uppercase",letterSpacing:"0.5px"},children:"Instanced"})]}),pe.jsxs("div",{style:{marginBottom:"8px"},children:[pe.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"3px"},children:[pe.jsx("span",{children:"FPS:"}),pe.jsx("span",{style:{backgroundColor:V.fps>30?"rgba(76,175,80,0.2)":V.fps>15?"rgba(255,193,7,0.2)":"rgba(244,67,54,0.2)",color:V.fps>30?"#4CAF50":V.fps>15?"#FFC107":"#F44336",padding:"1px 5px",borderRadius:"2px",fontWeight:"bold"},children:V.fps})]}),pe.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"3px"},children:[pe.jsx("span",{children:"Draw Calls:"}),pe.jsx("span",{style:{color:V.drawCalls<=5?"#4CAF50":V.drawCalls<=20?"#FFC107":"#F44336",fontWeight:"bold"},children:V.drawCalls})]}),pe.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"3px"},children:[pe.jsx("span",{children:"Triangles:"}),pe.jsx("span",{children:V.triangles.toLocaleString()})]}),pe.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center"},children:[pe.jsx("span",{children:"Active Cells:"}),pe.jsx("span",{children:V.activeCells.toLocaleString()})]})]}),pe.jsx("div",{style:{marginTop:"5px",borderTop:"1px solid rgba(255,255,255,0.3)",paddingTop:"5px"},children:pe.jsxs("div",{style:{backgroundColor:"rgba(142,68,173,0.2)",color:"#9b59b6",padding:"4px 6px",borderRadius:"3px",textAlign:"center",fontWeight:"bold",fontSize:"11px",display:"flex",flexDirection:"column",gap:"2px"},children:[pe.jsx("span",{children:"Instancing Efficiency"}),pe.jsx("span",{style:{color:"white",fontSize:"14px"},children:`${Math.round(V.activeCells/Math.max(1,V.drawCalls))} cells/draw call`}),pe.jsx("span",{style:{fontSize:"9px",color:"#aaa",fontStyle:"italic"},children:"(Standard rendering: 1 cell/draw call)"})]})}),pe.jsxs("div",{style:{fontSize:"9px",marginTop:"5px",color:"#bbb",textAlign:"right",fontStyle:"italic"},children:["Last updated: ",new Date(V.lastUpdated).toLocaleTimeString()]})]})]}),pe.jsxs("div",{style:{fontSize:"0.8em",color:"#333",textAlign:"center",marginTop:"5px",background:"#f0f0f0",padding:"3px",borderRadius:"4px",border:"1px solid #ddd",display:"flex",justifyContent:"space-between"},children:[pe.jsx("span",{children:"Drag to rotate | Use mouse wheel to zoom in/out"}),pe.jsx("span",{style:{fontWeight:$?"bold":"normal",color:$?"#4CAF50":"#777"},children:$?"✓ Texture applied":"Drag & drop image for texture"})]}),$&&pe.jsx("div",{style:{marginTop:"5px",textAlign:"center"},children:pe.jsx("button",{onClick:()=>O(null),style:{padding:"3px 8px",fontSize:"0.8em",backgroundColor:"#f44336",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},children:"Remove Texture"})})]})},jH={conway3d:"3D Conway (B5678/S45678)",life3d:"3D Life (B45/S567)",stability:"Stability (B4567/S3456)",crystal:"Crystal Growth (B5678/S5678)",pyroclastic:"Pyroclastic (B4567/S678)",diamoeba3d:"3D Diamoeba (B5678/S5678910)",hyper:"Hyperactive (B567/S5678910)",briansbrain3d:"3D Brian's Brain (3-state)",checkerboard:"3D Checkerboard (static test pattern)"},Uy={low:10,medium:20,high:35,ultra:50},qH={standard:"Standard",metal:"Metal",glass:"Glass",plastic:"Plastic",ceramic:"Ceramic",glow:"Glow",pearl:"Pearl",chrome:"Chrome"},KH=n=>{const e=parseInt(n.slice(1,3),16)/255,t=parseInt(n.slice(3,5),16)/255,s=parseInt(n.slice(5,7),16)/255;return .2126*e+.7152*t+.0722*s},YH=({onStart:n,onPause:e,onReset:t,isRunning:s,currentRule:r="conway3d",onRuleChange:i,cameraDistance:o=100,onCameraDistanceChange:a,rotationSpeed:l=0,onRotationSpeedChange:c,gridSize:h=10,onGridSizeChange:d,cubeOpacity:p=1,onCubeOpacityChange:m,cubeColor:g="#4CAF50",onCubeColorChange:b,materialType:y="standard",onMaterialTypeChange:v,showHelpers:S=!0,onToggleHelpers:C,simulationSpeed:_=200,onSpeedChange:A,useInstancedRendering:k=!1,onInstancedRenderingToggle:N,showStats:D=!1,onToggleStats:M,gpuBackend:T="webgl",onGpuBackendChange:I})=>{var he;const $={controlsContainer:{display:"flex",alignItems:"center",gap:"10px",padding:"10px",marginBottom:"20px",flexWrap:"wrap",justifyContent:"center"},button:{padding:"8px 15px",border:"none",borderRadius:"4px",cursor:"pointer",backgroundColor:"#8e44ad",color:"white"},buttonDisabled:{backgroundColor:"#6c757d"},ruleText:{fontSize:"1em",color:"#333",fontWeight:"bold"},select:{padding:"8px 15px",borderRadius:"4px",marginLeft:"10px"},controlGroup:{display:"flex",alignItems:"center",gap:"10px",marginLeft:"10px"},slider:{width:"100px"},sliderLabel:{fontSize:"0.9em",color:"#333",minWidth:"100px",textAlign:"right"}},O=se=>{i&&i(se.target.value)},B=se=>{a&&a(parseFloat(se.target.value))},V=se=>{c&&c(parseFloat(se.target.value))},H=se=>{d&&d(parseInt(se.target.value,10))},q=se=>{const Q=se.target.value;Q&&Uy[Q]&&d&&d(Uy[Q])},P=se=>{m&&m(parseFloat(se.target.value))},K=se=>{b&&b(se.target.value)},Z=se=>{v&&v(se.target.value)},U=se=>{C&&C(se.target.checked)},z=se=>{const Q=parseInt(se.target.value,10);A&&A(Q)},ne=se=>{N&&N(se.target.checked)},Y=se=>{M&&M(se.target.checked)},te=se=>{I&&I(se.target.value)};return pe.jsxs("div",{style:$.controlsContainer,children:[pe.jsx("button",{onClick:n,disabled:s,style:{...$.button,...s&&$.buttonDisabled},children:"Start"}),pe.jsx("button",{onClick:e,disabled:!s,style:{...$.button,...!s&&$.buttonDisabled},children:"Pause"}),pe.jsx("button",{onClick:t,style:$.button,children:"Reset"}),pe.jsxs("div",{children:[pe.jsx("label",{style:$.ruleText,children:"Rule:"}),pe.jsx("select",{value:r,onChange:O,style:$.select,disabled:s,children:Object.entries(jH).map(([se,Q])=>pe.jsx("option",{value:se,children:Q},se))})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Camera Distance:"}),pe.jsx("input",{type:"range",min:"10",max:"100",value:o,onChange:B,style:$.slider}),pe.jsx("span",{style:{marginLeft:"5px",fontSize:"0.9em"},children:Math.round(o)})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Auto-Rotation:"}),pe.jsx("input",{type:"range",min:"0",max:"5",step:"0.1",value:l,onChange:V,style:$.slider}),pe.jsx("span",{style:{marginLeft:"5px",fontSize:"0.9em"},children:l.toFixed(1)})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Grid Resolution:"}),pe.jsx("input",{type:"range",min:"5",max:"50",step:"1",value:h,onChange:H,disabled:s,style:$.slider}),pe.jsxs("span",{style:{marginLeft:"5px",fontSize:"0.9em"},children:[h,"³"]}),pe.jsx("span",{style:{marginLeft:"10px",fontSize:"0.75em",color:h>30?"#ff9800":"#555"},children:h>30?"GPU-powered high resolution":""})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Resolution Preset:"}),pe.jsxs("select",{value:((he=Object.entries(Uy).find(([se,Q])=>Q===h))==null?void 0:he[0])||"",onChange:q,disabled:s,style:$.select,children:[pe.jsx("option",{value:"",children:"Custom"}),pe.jsx("option",{value:"low",children:"Low (10³)"}),pe.jsx("option",{value:"medium",children:"Medium (20³)"}),pe.jsx("option",{value:"high",children:"High - GPU (35³)"}),pe.jsx("option",{value:"ultra",children:"Ultra - GPU (50³)"})]})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Cube Opacity:"}),pe.jsx("input",{type:"range",min:"0.1",max:"1.0",step:"0.05",value:p,onChange:P,style:$.slider}),pe.jsxs("span",{style:{marginLeft:"5px",fontSize:"0.9em"},children:[Math.round(p*100),"%"]})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Cube Color:"}),pe.jsx("input",{type:"color",value:g,onChange:K,style:{width:"40px",height:"25px",cursor:"pointer",border:"none",borderRadius:"4px",boxShadow:"0 0 3px rgba(0,0,0,0.3)"}}),pe.jsx("span",{style:{marginLeft:"5px",fontSize:"0.9em",display:"inline-block",width:"60px",textAlign:"center",backgroundColor:g,color:KH(g)>.5?"#000":"#fff",borderRadius:"3px",padding:"2px 5px"},children:g})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Material Type:"}),pe.jsx("select",{value:y,onChange:Z,style:$.select,children:Object.entries(qH).map(([se,Q])=>pe.jsx("option",{value:se,children:Q},se))})]}),pe.jsx("div",{style:$.controlGroup,children:pe.jsxs("label",{style:{...$.sliderLabel,textAlign:"left",minWidth:"auto"},children:[pe.jsx("input",{type:"checkbox",checked:S,onChange:U,style:{marginRight:"5px"}}),"Show Axis Helpers"]})}),pe.jsx("div",{style:$.controlGroup,children:pe.jsxs("label",{style:{...$.sliderLabel,textAlign:"left",minWidth:"auto",display:"flex",alignItems:"center"},children:[pe.jsx("input",{type:"checkbox",checked:k,onChange:ne,style:{marginRight:"5px"}}),pe.jsxs("span",{style:{display:"flex",alignItems:"center"},children:["Use Instanced Rendering",pe.jsx("span",{style:{marginLeft:"5px",fontSize:"0.7em",padding:"2px 5px",backgroundColor:"#8e44ad",color:"white",borderRadius:"4px",fontWeight:"bold"},children:"GPU"})]})]})}),k&&pe.jsx("div",{style:$.controlGroup,children:pe.jsxs("label",{style:{...$.sliderLabel,textAlign:"left",minWidth:"auto",display:"flex",alignItems:"center"},children:[pe.jsx("input",{type:"checkbox",checked:D,onChange:Y,style:{marginRight:"5px"}}),pe.jsxs("span",{style:{display:"flex",alignItems:"center"},children:["Show GPU Stats",pe.jsx("span",{style:{marginLeft:"5px",fontSize:"0.7em",padding:"2px 5px",backgroundColor:"#ff9800",color:"white",borderRadius:"4px",fontWeight:"bold"},children:"FPS"})]})]})}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"GPU Backend:"}),pe.jsxs("select",{value:T,onChange:te,style:{...$.select,backgroundColor:T==="tensorflow"?"#0d6efd20":T==="webgpu"?"#ff590020":"#4CAF5020"},disabled:s,children:[pe.jsx("option",{value:"webgl",children:"WebGL Shaders"}),pe.jsx("option",{value:"tensorflow",children:"TensorFlow.js GPGPU"}),pe.jsx("option",{value:"webgpu",children:"WebGPU Compute"})]}),pe.jsx("span",{style:{marginLeft:"5px",fontSize:"0.7em",padding:"2px 5px",backgroundColor:T==="tensorflow"?"#0d6efd":T==="webgpu"?"#ff5900":"#4CAF50",color:"white",borderRadius:"4px",fontWeight:"bold"},children:T==="tensorflow"?"TF":T==="webgpu"?"WGPU":"GL"})]}),pe.jsxs("div",{style:$.controlGroup,children:[pe.jsx("label",{style:$.sliderLabel,children:"Simulation Speed:"}),pe.jsx("input",{type:"range",min:"50",max:"1000",step:"50",value:_,onChange:z,style:$.slider}),pe.jsxs("span",{style:{marginLeft:"5px",fontSize:"0.9em"},children:[_,"ms"]})]})]})},zy={conway3d:{birth:[5,6,7],survival:[4,5,6]},life3d:{birth:[4,5],survival:[5,6,7]},stability:{birth:[4,5,6,7],survival:[3,4,5,6]},crystal:{birth:[5,6,7,8],survival:[5,6,7,8]},pyroclastic:{birth:[4,5,6,7],survival:[6,7,8]},diamoeba3d:{birth:[5,6,7,8],survival:[5,6,7,8,9,10]},hyper:{birth:[5,6,7],survival:[5,6,7,8,9,10]},briansbrain3d:{type:"special"},checkerboard:{type:"static"}},mS=(n,e,t)=>Array(n).fill().map(()=>Array(e).fill().map(()=>Array(t).fill(0))),Tm=(n=30,e=30,t=30,s="checkerboard")=>{console.log("[3DLogicGPU] Creating initial 3D grid with size",n,e,t,"and pattern",s);const r=mS(n,e,t),i=Math.floor(n/2),o=Math.floor(e/2),a=Math.floor(t/2);if(s==="checkerboard"||s==="default")for(let c=0;c<n;c++)for(let h=0;h<e;h++)for(let d=0;d<t;d++)(c+h+d)%2===0&&(r[c][h][d]=1);else if(s==="cross")for(let c=-Math.min(3,Math.floor(n/4));c<=Math.min(3,Math.floor(n/4));c++)r[i+c][o][a]=1,r[i][o+c][a]=1,r[i][o][a+c]=1;else if(s==="random")for(let c=0;c<n;c++)for(let h=0;h<e;h++)for(let d=0;d<t;d++)Math.random()<.3&&(r[c][h][d]=1);else if(s==="sphere"){const c=Math.min(n,e,t)/4;for(let h=0;h<n;h++)for(let d=0;d<e;d++)for(let p=0;p<t;p++){const m=h-i,g=d-o,b=p-a,y=Math.sqrt(m*m+g*g+b*b);Math.abs(y-c)<.8&&(r[h][d][p]=1)}}else{for(let c=-2;c<=2;c++)r[i+c][o][a]=1,r[i][o+c][a]=1,r[i][o][a+c]=1;for(let c=-1;c<=1;c++)for(let h=-1;h<=1;h++)for(let d=-1;d<=1;d++)Math.abs(c)+Math.abs(h)+Math.abs(d)>=2&&(r[i+c][o+h][a+d]=1);for(let c=i-4;c<=i+4;c++)for(let h=o-4;h<=o+4;h++)for(let d=a-4;d<=a+4;d++)c>=0&&c<n&&h>=0&&h<e&&d>=0&&d<t&&Math.random()<.3&&(r[c][h][d]=1)}let l=0;for(let c=0;c<n;c++)for(let h=0;h<e;h++)for(let d=0;d<t;d++)r[c][h][d]===1&&l++;return console.log("[3DLogicGPU] Created initial grid with",l,"active cells"),r};class ZH{constructor(){this.initialized=!1,this.renderer=null,this.scene=new ad,this.camera=new dS(-1,1,1,-1,0,1),this.textureA=null,this.textureB=null,this.currentTexture="A",this.size={x:0,y:0,z:0},this.standardRuleMaterial=null,this.briansBrainMaterial=null,this.copyMaterial=null,this.computeMesh=null,this.renderTargetA=null,this.renderTargetB=null,this.currentRule="conway3d"}initialize(e,t){this.initialized&&this.dispose(),this.currentRule=t;const s=e.length,r=e[0].length,i=e[0][0].length;this.size={x:s,y:r,z:i},this.renderer=new pS({antialias:!1,powerPreference:"high-performance",precision:s*r*i>15e3?"mediump":"highp"}),this.renderer.setSize(1,1);const o=s*r*i,a=s*r,l=new Uint8Array(o*4);for(let p=0;p<i;p++)for(let m=0;m<r;m++)for(let g=0;g<s;g++){const b=(p*a+m*s+g)*4;l[b]=e[g][m][p]*255,l[b+1]=0,l[b+2]=0,l[b+3]=255}const c=s,h=r*i;this.textureA=new HM(l,c,h,Hr),this.textureA.needsUpdate=!0,this.textureB=this.textureA.clone(),this.renderTargetA=new za(c,h,{minFilter:mr,magFilter:mr,format:Hr,type:Ui}),this.renderTargetB=this.renderTargetA.clone(),this.createComputeShaders();const d=new oc(2,2);this.computeMesh=new Os(d,this.standardRuleMaterial),this.scene.add(this.computeMesh),this.renderer.setRenderTarget(this.renderTargetA),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null),this.initialized=!0,console.log("[3DLogicGPU] Initialized with grid size",s,r,i)}createComputeShaders(){const e=`
      varying vec2 vUv;
      
      void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    `,t=`
      varying vec2 vUv;
      uniform sampler2D tState;
      uniform vec3 gridSize;
      uniform float birthValues[8];   // 1 where birth rule applies, 0 elsewhere
      uniform float survivalValues[8]; // 1 where survival rule applies, 0 elsewhere
      
      float getCellState(vec3 pos) {
        // Handle wrapping around edges
        pos.x = mod(pos.x, gridSize.x);
        pos.y = mod(pos.y, gridSize.y);
        pos.z = mod(pos.z, gridSize.z);
        
        // Convert 3D position to 2D texture coordinates
        float zSlice = floor(pos.z);
        vec2 texCoord = vec2(
          pos.x / gridSize.x,
          (pos.y + zSlice * gridSize.y) / (gridSize.y * gridSize.z)
        );
        
        return texture2D(tState, texCoord).r;
      }
      
      void main() {
        // Convert texture coordinate to 3D grid position
        float texY = vUv.y * gridSize.y * gridSize.z;
        float z = floor(texY / gridSize.y);
        float y = mod(texY, gridSize.y);
        float x = vUv.x * gridSize.x;
        
        vec3 pos = vec3(x, y, z);
        
        // Get current cell state (0 or 1)
        float currentState = getCellState(pos);
        
        // Count live neighbors (26 neighbors in 3D)
        float neighbors = 0.0;
        for (float dx = -1.0; dx <= 1.0; dx += 1.0) {
          for (float dy = -1.0; dy <= 1.0; dy += 1.0) {
            for (float dz = -1.0; dz <= 1.0; dz += 1.0) {
              // Skip the center cell
              if (dx == 0.0 && dy == 0.0 && dz == 0.0) continue;
              
              vec3 neighborPos = vec3(pos.x + dx, pos.y + dy, pos.z + dz);
              neighbors += getCellState(neighborPos);
            }
          }
        }
        
        // Apply cellular automata rules
        float newState = 0.0;
        
        // If alive
        if (currentState > 0.5) {
          // Check survival rules
          float floorNeighbors = floor(neighbors);
          if (floorNeighbors >= 3.0 && floorNeighbors <= 10.0) {
            int idx = int(floorNeighbors) - 3;
            if (survivalValues[idx] > 0.5) {
              newState = 1.0;
            }
          }
        } else {
          // Check birth rules
          float floorNeighbors = floor(neighbors);
          if (floorNeighbors >= 3.0 && floorNeighbors <= 10.0) {
            int idx = int(floorNeighbors) - 3;
            if (birthValues[idx] > 0.5) {
              newState = 1.0;
            }
          }
        }
        
        // Output result - red channel contains state
        gl_FragColor = vec4(newState, 0.0, 0.0, 1.0);
      }
    `;this.standardRuleMaterial=new Fi({vertexShader:e,fragmentShader:t,uniforms:{tState:{value:this.textureA},gridSize:{value:new Ce(this.size.x,this.size.y,this.size.z)},birthValues:{value:[0,0,0,0,0,0,0,0]},survivalValues:{value:[0,0,0,0,0,0,0,0]}}});const s=zy.conway3d;if(s){const o=[0,0,0,0,0,0,0,0],a=[0,0,0,0,0,0,0,0];s.birth.forEach(l=>{l>=3&&l<=10&&(o[l-3]=1)}),s.survival.forEach(l=>{l>=3&&l<=10&&(a[l-3]=1)}),this.standardRuleMaterial.uniforms.birthValues.value=o,this.standardRuleMaterial.uniforms.survivalValues.value=a}const r=`
      varying vec2 vUv;
      uniform sampler2D tState;
      uniform vec3 gridSize;
      
      float getCellState(vec3 pos) {
        // Handle wrapping around edges
        pos.x = mod(pos.x, gridSize.x);
        pos.y = mod(pos.y, gridSize.y);
        pos.z = mod(pos.z, gridSize.z);
        
        // Convert 3D position to 2D texture coordinates
        float zSlice = floor(pos.z);
        vec2 texCoord = vec2(
          pos.x / gridSize.x,
          (pos.y + zSlice * gridSize.y) / (gridSize.y * gridSize.z)
        );
        
        return texture2D(tState, texCoord).r;
      }
      
      void main() {
        // Convert texture coordinate to 3D grid position
        float texY = vUv.y * gridSize.y * gridSize.z;
        float z = floor(texY / gridSize.y);
        float y = mod(texY, gridSize.y);
        float x = vUv.x * gridSize.x;
        
        vec3 pos = vec3(x, y, z);
        
        // Get current cell state (0, 0.5, or 1)
        float currentState = getCellState(pos);
        float newState = 0.0;
        
        // Brian's Brain rules:
        // 0 = Dead, 0.5 = Dying, 1 = Alive
        if (currentState < 0.25) { // Dead
          // Count live neighbors
          float onNeighbors = 0.0;
          for (float dx = -1.0; dx <= 1.0; dx += 1.0) {
            for (float dy = -1.0; dy <= 1.0; dy += 1.0) {
              for (float dz = -1.0; dz <= 1.0; dz += 1.0) {
                // Skip the center cell
                if (dx == 0.0 && dy == 0.0 && dz == 0.0) continue;
                
                vec3 neighborPos = vec3(pos.x + dx, pos.y + dy, pos.z + dz);
                float state = getCellState(neighborPos);
                if (state > 0.75) { // Alive
                  onNeighbors += 1.0;
                }
              }
            }
          }
          // Dead cell becomes alive if exactly 2 alive neighbors
          if (onNeighbors >= 1.5 && onNeighbors <= 2.5) {
            newState = 1.0; // Alive
          }
        } else if (currentState > 0.75) { // Alive
          // Alive cell always becomes dying
          newState = 0.5; // Dying
        }
        // Dying cell always becomes dead (default newState = 0.0)
        
        // Output result - red channel contains state
        gl_FragColor = vec4(newState, 0.0, 0.0, 1.0);
      }
    `;this.briansBrainMaterial=new Fi({vertexShader:e,fragmentShader:r,uniforms:{tState:{value:this.textureA},gridSize:{value:new Ce(this.size.x,this.size.y,this.size.z)}}});const i=`
      varying vec2 vUv;
      uniform sampler2D tState;
      
      void main() {
        gl_FragColor = texture2D(tState, vUv);
      }
    `;this.copyMaterial=new Fi({vertexShader:e,fragmentShader:i,uniforms:{tState:{value:this.textureA}}})}setRule(e){if(this.currentRule=e,e==="briansbrain3d"||e==="checkerboard"){console.log(`[3DLogicGPU] Using special rule: ${e}`);return}const t=zy[e]||zy.conway3d,{birth:s,survival:r}=t;console.log(`[3DLogicGPU] Setting rule: ${e}`),console.log(`[3DLogicGPU] Birth values: ${s.join(", ")}`),console.log(`[3DLogicGPU] Survival values: ${r.join(", ")}`);const i=[0,0,0,0,0,0,0,0],o=[0,0,0,0,0,0,0,0];s.forEach(a=>{a>=3&&a<=10&&(i[a-3]=1)}),r.forEach(a=>{a>=3&&a<=10&&(o[a-3]=1)}),console.log(`[3DLogicGPU] Birth values array: ${i.join(", ")}`),console.log(`[3DLogicGPU] Survival values array: ${o.join(", ")}`),this.standardRuleMaterial.uniforms.birthValues.value=i,this.standardRuleMaterial.uniforms.survivalValues.value=o,this.standardRuleMaterial.needsUpdate=!0,this.standardRuleMaterial.uniformsNeedUpdate=!0}computeNextGeneration(){if(!this.initialized)return console.warn("[3DLogicGPU] Not initialized"),null;console.log(`[3DLogicGPU] Computing next generation with rule: ${this.currentRule}`),console.log(`[3DLogicGPU] Current texture: ${this.currentTexture}, Grid size: ${this.size.x}x${this.size.y}x${this.size.z}`),this.currentRule==="briansbrain3d"?(console.log("[3DLogicGPU] Using Brian's Brain shader"),this.computeMesh.material=this.briansBrainMaterial,this.briansBrainMaterial.uniforms.tState.value=this.currentTexture==="A"?this.textureA:this.textureB):this.currentRule==="checkerboard"?(console.log("[3DLogicGPU] Using static checkerboard (copy) shader"),this.computeMesh.material=this.copyMaterial,this.copyMaterial.uniforms.tState.value=this.currentTexture==="A"?this.textureA:this.textureB):(console.log("[3DLogicGPU] Using standard B/S rule shader"),this.computeMesh.material=this.standardRuleMaterial,this.standardRuleMaterial.uniforms.tState.value=this.currentTexture==="A"?this.textureA:this.textureB,this.setRule(this.currentRule)),this.currentTexture==="A"?this.textureA:this.textureB;const e=this.currentTexture==="A"?this.renderTargetB:this.renderTargetA;this.renderer.setRenderTarget(e),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null),this.currentTexture=this.currentTexture==="A"?"B":"A",console.log(`[3DLogicGPU] Swapped textures - new current texture: ${this.currentTexture}`);const t=new Uint8Array(this.size.x*this.size.y*this.size.z*4);this.renderer.readRenderTargetPixels(e,0,0,this.size.x,this.size.y*this.size.z,t);const s=mS(this.size.x,this.size.y,this.size.z),r=this.size.x*this.size.y;for(let i=0;i<this.size.z;i++)for(let o=0;o<this.size.y;o++)for(let a=0;a<this.size.x;a++){const l=(i*r+o*this.size.x+a)*4;s[a][o][i]=t[l]>127?1:0}return s}dispose(){this.textureA&&this.textureA.dispose(),this.textureB&&this.textureB.dispose(),this.renderTargetA&&this.renderTargetA.dispose(),this.renderTargetB&&this.renderTargetB.dispose(),this.standardRuleMaterial&&this.standardRuleMaterial.dispose(),this.briansBrainMaterial&&this.briansBrainMaterial.dispose(),this.copyMaterial&&this.copyMaterial.dispose(),this.computeMesh&&(this.scene.remove(this.computeMesh),this.computeMesh.geometry.dispose()),this.renderer&&this.renderer.dispose(),this.initialized=!1,console.log("[3DLogicGPU] Resources disposed")}}let ri=null;const li=(n,e="conway3d")=>{if(!n||n.length===0||!n[0]||n[0].length===0||!n[0][0]||n[0][0].length===0)return console.warn("[automataLogic3DGPU] Invalid or empty 3D grid provided."),mS(1,1,1);ri||(ri=new ZH);const t=n.length,s=n[0].length,r=n[0][0].length;if(!ri.initialized||ri.size.x!==t||ri.size.y!==s||ri.size.z!==r||ri.currentRule!==e)console.log(`[automataLogic3DGPU] Reinitializing GPU compute instance. Size: ${t}x${s}x${r}, Rule: ${e}`),ri.initialize(n,e);else{const o=t*s,a=new Uint8Array(t*s*r*4);for(let c=0;c<r;c++)for(let h=0;h<s;h++)for(let d=0;d<t;d++){const p=(c*o+h*t+d)*4;a[p]=n[d][h][c]*255,a[p+1]=0,a[p+2]=0,a[p+3]=255}const l=ri.currentTexture==="A"?ri.textureA:ri.textureB;l.image.data.set(a),l.needsUpdate=!0}const i=ri.computeNextGeneration();if(li.generationCount?li.generationCount++:li.generationCount=1,li.generationCount<=3){let o=0;for(let p=0;p<i.length;p++)for(let m=0;m<i[0].length;m++)for(let g=0;g<i[0][0].length;g++)i[p][m][g]>0&&o++;console.log(`[WebGL] GENERATION ${li.generationCount} DATA FOR COMPARISON`),console.log(`Rule: ${e}, Active cells: ${o}`),console.log("[WebGL] Corner region (0,0,0) to (2,2,2):");for(let p=0;p<Math.min(3,i.length);p++)for(let m=0;m<Math.min(3,i[0].length);m++)for(let g=0;g<Math.min(3,i[0][0].length);g++)console.log(`  Cell at (${p},${m},${g}): ${i[p][m][g]}`);const a=Math.floor(i.length/2),l=Math.floor(i[0].length/2),c=Math.floor(i[0][0].length/2);console.log(`[WebGL] Center region (${a-1},${l-1},${c-1}) to (${a+1},${l+1},${c+1}):`);for(let p=a-1;p<=a+1;p++)for(let m=l-1;m<=l+1;m++)for(let g=c-1;g<=c+1;g++)p>=0&&p<i.length&&m>=0&&m<i[0].length&&g>=0&&g<i[0][0].length&&console.log(`  Cell at (${p},${m},${g}): ${i[p][m][g]}`);let h="";[[0,0,0],[a,l,c],[i.length-1,i[0].length-1,i[0][0].length-1],[Math.floor(a/2),Math.floor(l/2),Math.floor(c/2)],[a+Math.floor((i.length-a)/2),l,c]].forEach(([p,m,g])=>{p>=0&&p<i.length&&m>=0&&m<i[0].length&&g>=0&&g<i[0][0].length&&(h+=i[p][m][g])}),console.log(`[WebGL] Generation ${li.generationCount} fingerprint: ${h}`),li.generationCount>=3&&(li.generationCount=0)}return i};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QH=1e-7,JH=1e-4;class rR{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class gS{refCount(e){return Rr("refCount")}incRef(e){return Rr("incRef")}timerAvailable(){return!0}time(e){return Rr("time")}read(e){return Rr("read")}readSync(e){return Rr("readSync")}readToGPU(e,t){return Rr("readToGPU")}numDataIds(){return Rr("numDataIds")}disposeData(e,t){return Rr("disposeData")}write(e,t,s){return Rr("write")}move(e,t,s,r,i){return Rr("move")}createTensorFromGPUData(e,t,s){return Rr("createTensorFromGPUData")}memory(){return Rr("memory")}floatPrecision(){return Rr("floatPrecision")}epsilon(){return this.floatPrecision()===32?QH:JH}dispose(){return Rr("dispose")}}function Rr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e5(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,iu(n,e,t)}function Hl(n,e,t){return Math.max(n,Math.min(e,t))}function xS(n){return n%2===0?n:n+1}function iu(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function t5(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function W(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function vS(n,e,t=""){W(mn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function qg(n){W(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ne(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function mn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Su(n){return n%1===0}function J1(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function hu(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function VI(n,e=r=>0,t,s){return new Promise((r,i)=>{let o=0;const a=()=>{if(n()){r();return}o++;const l=e(o);if(t!=null&&o>=t){i();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function iR(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function qt(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),W(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),W(n.every(s=>Su(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function qa(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:qt(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Us(n,e){return jn(n,e)}function jn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function n5(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function s5(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function oR(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function cg(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function r5(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Ed(n){return typeof n=="string"||n instanceof String}function i5(n){return typeof n=="boolean"}function eb(n){return typeof n=="number"}function Lu(n){return Array.isArray(n)?Lu(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":eb(n)?"float32":Ed(n)?"string":i5(n)?"bool":"float32"}function tb(n){return!!(n&&n.constructor&&n.call&&n.apply)}function nb(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Ct(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function aR(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<i;l++)r[l]=aR(n+l*a,o,t,s)}return r}function Li(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return aR(0,n,e,t)}function o5(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function yS(n,e){const t=zs(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function zs(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function lR(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Li(n,new Float32Array(t));if(e==="int32")return Li(n,new Int32Array(t));if(e==="bool")return Li(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Ko(n){n.forEach(e=>{W(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function lo(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function Pu(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function bS(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GI="tfjsflags";class a5{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=l5,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(bS(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);GI in e&&e[GI].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=u5(r,i)})}}function l5(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(c5(e,s[0],s[1]),s.join("="))),e}function c5(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function u5(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function _e(){return cR}let cR=null;function h5(n){cR=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let By;function uR(){if(By==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");By=n}return By}function d5(){const n=uR();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function SS(n,e){const t=d5();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const Kg="Abs",Td="Acos",Id="Acosh",Ou="Add",wS="AddN",_S="All",CS="Any",Yg="ArgMax",Zg="ArgMin",Ad="Asin",Md="Asinh",Rd="Atan",kd="Atanh",Nd="Atan2",Qg="AvgPool",ES="AvgPoolGrad",Jg="AvgPool3D",TS="AvgPool3DGrad",e0="BatchMatMul",t0="BatchToSpaceND",IS="Bincount",AS="BitwiseAnd",f5="BroadcastTo",hR="BroadcastArgs",Dd="Cast",$d="Ceil",Fd="ClipByValue",MS="Complex",n0="ComplexAbs",s0="Concat",r0="Conv2D",RS="Conv2DBackpropFilter",i0="Conv2DBackpropInput",o0="Conv3D",kS="Conv3DBackpropFilterV2",NS="Conv3DBackpropInputV2",Ld="Cos",Pd="Cosh",DS="Cumprod",a0="Cumsum",$S="CropAndResize",FS="DenseBincount",LS="DepthToSpace",l0="DepthwiseConv2dNative",PS="DepthwiseConv2dNativeBackpropFilter",OS="DepthwiseConv2dNativeBackpropInput",dR="Diag",c0="Dilation2D",sb="Dilation2DBackpropInput",rb="Dilation2DBackpropFilter",p5="Draw",Od="RealDiv",US="Einsum",Ud="Elu",zS="EluGrad",zd="Erf",u0="Equal",Bd="Exp",h0="ExpandDims",Vd="Expm1",BS="FFT",VS="Fill",GS="FlipLeftRight",Gd="Floor",Wd="FloorDiv",d0="FusedBatchNorm",f0="GatherV2",fR="GatherNd",p0="Greater",Hd="GreaterEqual",Xd="Identity",WS="IFFT",HS="Imag",jd="IsFinite",qd="IsInf",Kd="IsNan",m0="LeakyRelu",g0="Less",x0="LessEqual",pR="LinSpace",Yd="Log",Zd="Log1p",v0="LogicalAnd",y0="LogicalNot",b0="LogicalOr",m5="LogSoftmax",S0="LRN",XS="LRNGrad",w0="Max",Qd="Maximum",_0="MaxPool",jS="MaxPoolGrad",C0="MaxPool3D",qS="MaxPool3DGrad",mR="MaxPoolWithArgmax",E0="Mean",T0="Min",Jd="Minimum",I0="MirrorPad",ef="Mod",gR="Multinomial",tf="Multiply",A0="Neg",M0="NotEqual",KS="NonMaxSuppressionV3",YS="NonMaxSuppressionV4",ZS="NonMaxSuppressionV5",R0="OnesLike",k0="OneHot",N0="Pack",D0="PadV2",nf="Pow",$0="Prelu",F0="Prod",xR="RaggedGather",vR="RaggedRange",yR="RaggedTensorToTensor",QS="Range",JS="Real",sf="Reciprocal",rf="Relu",L0="Reshape",P0="ResizeNearestNeighbor",ew="ResizeNearestNeighborGrad",O0="ResizeBilinear",tw="ResizeBilinearGrad",of="Relu6",U0="Reverse",af="Round",lf="Rsqrt",bR="ScatterNd",SR="TensorScatterUpdate",wR="SearchSorted",z0="Select",cf="Selu",B0="Slice",uf="Sin",hf="Sinh",df="Sign",ff="Sigmoid",pf="Softplus",mf="Sqrt",V0="Sum",G0="SpaceToBatchND",W0="SplitV",H0="Softmax",_R="SparseFillEmptyRows",CR="SparseReshape",ER="SparseSegmentMean",TR="SparseSegmentSum",IR="SparseToDense",gf="SquaredDifference",nw="Square",sw="StaticRegexReplace",rw="StridedSlice",AR="StringNGrams",MR="StringSplit",RR="StringToHashBucketFast",xf="Sub",vf="Tan",yf="Tanh",bf="Tile",iw="TopK",ow="Transform",du="Transpose",aw="Unique",X0="Unpack",j0="UnsortedSegmentSum",q0="ZerosLike",Sf="Step",g5="FromPixels",lw="RotateWithOffset",ug="_FusedMatMul",hg="FusedConv2D",kR="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wr(...n){_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn(...n)}function x5(...n){_e().getBool("IS_TEST")||_e().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dg=SS("kernelRegistry",()=>new Map),ib=SS("gradRegistry",()=>new Map);function WI(n,e){const t=DR(n,e);return dg.get(t)}function HI(n){return ib.get(n)}function XI(n){const e=dg.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===n&&t.push(o)}return t}function NR(n){const{kernelName:e,backendName:t}=n,s=DR(e,t);dg.has(s)&&Wr(`The kernel '${e}' for backend '${t}' is already registered`),dg.set(s,n)}function v5(n){const{kernelName:e}=n;ib.has(e)&&_e().getBool("DEBUG")&&Wr(`Overriding the gradient for '${e}'`),ib.set(e,n)}function DR(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Vy,jI;function y5(){if(jI)return Vy;jI=1,Vy=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(T,I,$){this.low=T|0,this.high=I|0,this.unsigned=!!$}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(T){return(T&&T.__isLong__)===!0}e.isLong=t;var s={},r={};function i(T,I){var $,O,B;return I?(T>>>=0,(B=0<=T&&T<256)&&(O=r[T],O)?O:($=a(T,(T|0)<0?-1:0,!0),B&&(r[T]=$),$)):(T|=0,(B=-128<=T&&T<128)&&(O=s[T],O)?O:($=a(T,T<0?-1:0,!1),B&&(s[T]=$),$))}e.fromInt=i;function o(T,I){if(isNaN(T))return I?S:v;if(I){if(T<0)return S;if(T>=g)return N}else{if(T<=-9223372036854776e3)return D;if(T+1>=b)return k}return T<0?o(-T,I).neg():a(T%m|0,T/m|0,I)}e.fromNumber=o;function a(T,I,$){return new e(T,I,$)}e.fromBits=a;var l=Math.pow;function c(T,I,$){if(T.length===0)throw Error("empty string");if(T==="NaN"||T==="Infinity"||T==="+Infinity"||T==="-Infinity")return v;if(typeof I=="number"?($=I,I=!1):I=!!I,$=$||10,$<2||36<$)throw RangeError("radix");var O;if((O=T.indexOf("-"))>0)throw Error("interior hyphen");if(O===0)return c(T.substring(1),I,$).neg();for(var B=o(l($,8)),V=v,H=0;H<T.length;H+=8){var q=Math.min(8,T.length-H),P=parseInt(T.substring(H,H+q),$);if(q<8){var K=o(l($,q));V=V.mul(K).add(o(P))}else V=V.mul(B),V=V.add(o(P))}return V.unsigned=I,V}e.fromString=c;function h(T,I){return typeof T=="number"?o(T,I):typeof T=="string"?c(T,I):a(T.low,T.high,typeof I=="boolean"?I:T.unsigned)}e.fromValue=h;var d=65536,p=1<<24,m=d*d,g=m*m,b=g/2,y=i(p),v=i(0);e.ZERO=v;var S=i(0,!0);e.UZERO=S;var C=i(1);e.ONE=C;var _=i(1,!0);e.UONE=_;var A=i(-1);e.NEG_ONE=A;var k=a(-1,2147483647,!1);e.MAX_VALUE=k;var N=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=N;var D=a(0,-2147483648,!1);e.MIN_VALUE=D;var M=e.prototype;return M.toInt=function(){return this.unsigned?this.low>>>0:this.low},M.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},M.toString=function(I){if(I=I||10,I<2||36<I)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(D)){var $=o(I),O=this.div($),B=O.mul($).sub(this);return O.toString(I)+B.toInt().toString(I)}else return"-"+this.neg().toString(I);for(var V=o(l(I,6),this.unsigned),H=this,q="";;){var P=H.div(V),K=H.sub(P.mul(V)).toInt()>>>0,Z=K.toString(I);if(H=P,H.isZero())return Z+q;for(;Z.length<6;)Z="0"+Z;q=""+Z+q}},M.getHighBits=function(){return this.high},M.getHighBitsUnsigned=function(){return this.high>>>0},M.getLowBits=function(){return this.low},M.getLowBitsUnsigned=function(){return this.low>>>0},M.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var I=this.high!=0?this.high:this.low,$=31;$>0&&(I&1<<$)==0;$--);return this.high!=0?$+33:$+1},M.isZero=function(){return this.high===0&&this.low===0},M.eqz=M.isZero,M.isNegative=function(){return!this.unsigned&&this.high<0},M.isPositive=function(){return this.unsigned||this.high>=0},M.isOdd=function(){return(this.low&1)===1},M.isEven=function(){return(this.low&1)===0},M.equals=function(I){return t(I)||(I=h(I)),this.unsigned!==I.unsigned&&this.high>>>31===1&&I.high>>>31===1?!1:this.high===I.high&&this.low===I.low},M.eq=M.equals,M.notEquals=function(I){return!this.eq(I)},M.neq=M.notEquals,M.ne=M.notEquals,M.lessThan=function(I){return this.comp(I)<0},M.lt=M.lessThan,M.lessThanOrEqual=function(I){return this.comp(I)<=0},M.lte=M.lessThanOrEqual,M.le=M.lessThanOrEqual,M.greaterThan=function(I){return this.comp(I)>0},M.gt=M.greaterThan,M.greaterThanOrEqual=function(I){return this.comp(I)>=0},M.gte=M.greaterThanOrEqual,M.ge=M.greaterThanOrEqual,M.compare=function(I){if(t(I)||(I=h(I)),this.eq(I))return 0;var $=this.isNegative(),O=I.isNegative();return $&&!O?-1:!$&&O?1:this.unsigned?I.high>>>0>this.high>>>0||I.high===this.high&&I.low>>>0>this.low>>>0?-1:1:this.sub(I).isNegative()?-1:1},M.comp=M.compare,M.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add(C)},M.neg=M.negate,M.add=function(I){t(I)||(I=h(I));var $=this.high>>>16,O=this.high&65535,B=this.low>>>16,V=this.low&65535,H=I.high>>>16,q=I.high&65535,P=I.low>>>16,K=I.low&65535,Z=0,U=0,z=0,ne=0;return ne+=V+K,z+=ne>>>16,ne&=65535,z+=B+P,U+=z>>>16,z&=65535,U+=O+q,Z+=U>>>16,U&=65535,Z+=$+H,Z&=65535,a(z<<16|ne,Z<<16|U,this.unsigned)},M.subtract=function(I){return t(I)||(I=h(I)),this.add(I.neg())},M.sub=M.subtract,M.multiply=function(I){if(this.isZero())return v;if(t(I)||(I=h(I)),n){var $=n.mul(this.low,this.high,I.low,I.high);return a($,n.get_high(),this.unsigned)}if(I.isZero())return v;if(this.eq(D))return I.isOdd()?D:v;if(I.eq(D))return this.isOdd()?D:v;if(this.isNegative())return I.isNegative()?this.neg().mul(I.neg()):this.neg().mul(I).neg();if(I.isNegative())return this.mul(I.neg()).neg();if(this.lt(y)&&I.lt(y))return o(this.toNumber()*I.toNumber(),this.unsigned);var O=this.high>>>16,B=this.high&65535,V=this.low>>>16,H=this.low&65535,q=I.high>>>16,P=I.high&65535,K=I.low>>>16,Z=I.low&65535,U=0,z=0,ne=0,Y=0;return Y+=H*Z,ne+=Y>>>16,Y&=65535,ne+=V*Z,z+=ne>>>16,ne&=65535,ne+=H*K,z+=ne>>>16,ne&=65535,z+=B*Z,U+=z>>>16,z&=65535,z+=V*K,U+=z>>>16,z&=65535,z+=H*P,U+=z>>>16,z&=65535,U+=O*Z+B*K+V*P+H*q,U&=65535,a(ne<<16|Y,U<<16|z,this.unsigned)},M.mul=M.multiply,M.divide=function(I){if(t(I)||(I=h(I)),I.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&I.low===-1&&I.high===-1)return this;var $=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,I.low,I.high);return a($,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?S:v;var O,B,V;if(this.unsigned){if(I.unsigned||(I=I.toUnsigned()),I.gt(this))return S;if(I.gt(this.shru(1)))return _;V=S}else{if(this.eq(D)){if(I.eq(C)||I.eq(A))return D;if(I.eq(D))return C;var H=this.shr(1);return O=H.div(I).shl(1),O.eq(v)?I.isNegative()?C:A:(B=this.sub(I.mul(O)),V=O.add(B.div(I)),V)}else if(I.eq(D))return this.unsigned?S:v;if(this.isNegative())return I.isNegative()?this.neg().div(I.neg()):this.neg().div(I).neg();if(I.isNegative())return this.div(I.neg()).neg();V=v}for(B=this;B.gte(I);){O=Math.max(1,Math.floor(B.toNumber()/I.toNumber()));for(var q=Math.ceil(Math.log(O)/Math.LN2),P=q<=48?1:l(2,q-48),K=o(O),Z=K.mul(I);Z.isNegative()||Z.gt(B);)O-=P,K=o(O,this.unsigned),Z=K.mul(I);K.isZero()&&(K=C),V=V.add(K),B=B.sub(Z)}return V},M.div=M.divide,M.modulo=function(I){if(t(I)||(I=h(I)),n){var $=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,I.low,I.high);return a($,n.get_high(),this.unsigned)}return this.sub(this.div(I).mul(I))},M.mod=M.modulo,M.rem=M.modulo,M.not=function(){return a(~this.low,~this.high,this.unsigned)},M.and=function(I){return t(I)||(I=h(I)),a(this.low&I.low,this.high&I.high,this.unsigned)},M.or=function(I){return t(I)||(I=h(I)),a(this.low|I.low,this.high|I.high,this.unsigned)},M.xor=function(I){return t(I)||(I=h(I)),a(this.low^I.low,this.high^I.high,this.unsigned)},M.shiftLeft=function(I){return t(I)&&(I=I.toInt()),(I&=63)===0?this:I<32?a(this.low<<I,this.high<<I|this.low>>>32-I,this.unsigned):a(0,this.low<<I-32,this.unsigned)},M.shl=M.shiftLeft,M.shiftRight=function(I){return t(I)&&(I=I.toInt()),(I&=63)===0?this:I<32?a(this.low>>>I|this.high<<32-I,this.high>>I,this.unsigned):a(this.high>>I-32,this.high>=0?0:-1,this.unsigned)},M.shr=M.shiftRight,M.shiftRightUnsigned=function(I){if(t(I)&&(I=I.toInt()),I&=63,I===0)return this;var $=this.high;if(I<32){var O=this.low;return a(O>>>I|$<<32-I,$>>>I,this.unsigned)}else return I===32?a($,0,this.unsigned):a($>>>I-32,0,this.unsigned)},M.shru=M.shiftRightUnsigned,M.shr_u=M.shiftRightUnsigned,M.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},M.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},M.toBytes=function(I){return I?this.toBytesLE():this.toBytesBE()},M.toBytesLE=function(){var I=this.high,$=this.low;return[$&255,$>>>8&255,$>>>16&255,$>>>24,I&255,I>>>8&255,I>>>16&255,I>>>24]},M.toBytesBE=function(){var I=this.high,$=this.low;return[I>>>24,I>>>16&255,I>>>8&255,I&255,$>>>24,$>>>16&255,$>>>8&255,$&255]},e.fromBytes=function(I,$,O){return O?e.fromBytesLE(I,$):e.fromBytesBE(I,$)},e.fromBytesLE=function(I,$){return new e(I[0]|I[1]<<8|I[2]<<16|I[3]<<24,I[4]|I[5]<<8|I[6]<<16|I[7]<<24,$)},e.fromBytesBE=function(I,$){return new e(I[4]<<24|I[5]<<16|I[6]<<8|I[7],I[0]<<24|I[1]<<16|I[2]<<8|I[3],$)},Vy}var FR=y5();const LR=Ob(FR),b5=bP({__proto__:null,default:LR},[FR]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nl=LR||b5;function K0(n){return Nl.fromString(n,!0,16)}const PR=K0("c3a5c85c97cb3127"),Ml=K0("b492b66fbe98f273"),tr=K0("9ae16a3b2f90404f");function ob(n){return n.xor(n.shru(47))}function OR(n,e,t){const s=n.slice(e,e+t);return Nl.fromBytes(Array.from(s),!0,!0)}function Tn(n,e){return OR(n,e,8)}function qI(n,e){return OR(n,e,4)}function vs(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Fa(n,e,t=K0("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function S5(n,e,t,s,r,i){r=r.add(n),i=vs(i.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(t),i=i.add(vs(r,44)),[r.add(s),i.add(o)]}function Im(n,e,t,s){return S5(Tn(n,e),Tn(n,e+8),Tn(n,e+16),Tn(n,e+24),t,s)}function w5(n,e=n.length){if(e>=8){const t=tr.add(e*2),s=Tn(n,0).add(tr),r=Tn(n,e-8),i=vs(r,37).mul(t).add(s),o=vs(s,25).add(r).mul(t);return Fa(i,o,t)}if(e>=4){const t=tr.add(e*2),s=qI(n,0);return Fa(s.shl(3).add(e),qI(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),o=e+(r<<2);return ob(tr.mul(i).xor(PR.mul(o))).mul(tr)}return tr}function _5(n,e=n.length){const t=tr.add(e*2),s=Tn(n,0).mul(Ml),r=Tn(n,8),i=Tn(n,e-8).mul(t),o=Tn(n,e-16).mul(tr);return Fa(vs(s.add(r),43).add(vs(i,30)).add(o),s.add(vs(r.add(tr),18)).add(i),t)}function C5(n,e=n.length){const t=tr.add(e*2),s=Tn(n,0).mul(tr),r=Tn(n,8),i=Tn(n,e-8).mul(t),o=Tn(n,e-16).mul(tr),a=vs(s.add(r),43).add(vs(i,30)).add(o),l=Fa(a,s.add(vs(r.add(tr),18)).add(i),t),c=Tn(n,16).mul(t),h=Tn(n,24),d=a.add(Tn(n,e-32)).mul(t),p=l.add(Tn(n,e-24)).mul(t);return Fa(vs(c.add(h),43).add(vs(d,30)).add(p),c.add(vs(h.add(s),18)).add(d),t)}function E5(n,e=n.length){const t=Nl.fromNumber(81,!0);if(e<=32)return e<=16?w5(n,e):_5(n,e);if(e<=64)return C5(n,e);let s=t,r=t.mul(Ml).add(113),i=ob(r.mul(tr).add(113)).mul(tr),o=[Nl.UZERO,Nl.UZERO],a=[Nl.UZERO,Nl.UZERO];s=s.mul(tr).add(Tn(n,0));let l=0;const c=(e-1>>6)*64,h=c+(e-1&63)-63;do s=vs(s.add(r).add(o[0]).add(Tn(n,l+8)),37).mul(Ml),r=vs(r.add(o[1]).add(Tn(n,l+48)),42).mul(Ml),s=s.xor(a[1]),r=r.add(o[0]).add(Tn(n,l+40)),i=vs(i.add(a[0]),33).mul(Ml),o=Im(n,l,o[1].mul(Ml),s.add(a[0])),a=Im(n,l+32,i.add(a[1]),r.add(Tn(n,l+16))),[i,s]=[s,i],l+=64;while(l!==c);const d=Ml.add(i.and(255).shl(1));return l=h,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=vs(s.add(r).add(o[0]).add(Tn(n,l+8)),37).mul(d),r=vs(r.add(o[1]).add(Tn(n,l+48)),42).mul(d),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(Tn(n,l+40))),i=vs(i.add(a[0]),33).mul(d),o=Im(n,l,o[1].mul(d),s.add(a[0])),a=Im(n,l+32,i.add(a[1]),r.add(Tn(n,l+16))),[i,s]=[s,i],Fa(Fa(o[0],a[0],d).add(ob(r).mul(PR)).add(i),Fa(o[1],a[1],d).add(s),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ka(n,e){return e==="string"?La(n):ac([n],e)}function T5(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function ac(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Xl(n)),_e().getBool("DEBUG")&&n5(n,e),T5(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function dr(){return _e().platform.now()}function La(n,e="utf-8"){return e=e||"utf-8",_e().platform.encode(n,e)}function Ba(n,e="utf-8"){return e=e||"utf-8",_e().platform.decode(n,e)}function pi(n){return _e().platform.isTypedArray!=null?_e().platform.isTypedArray(n):$R(n)}function Xl(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||bS(n)||n==null||pi(n)&&t)e.push(n);else if(Array.isArray(n)||pi(n))for(let s=0;s<n.length;++s)Xl(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Xl(n[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I5{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new M5)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let o;const a=dr();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:dr()-a})}if(_e().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const h=r[c];h.data().then(d=>{A5(d,h.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}}function A5(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class M5{logKernelProfile(e,t,s,r,i,o){const a=typeof r=="number"?hu(`${r}ms`,9):r.error,l=hu(e,25),c=t.rank,h=t.size,d=hu(t.shape.toString(),14);let p="";for(const m in i){const g=i[m];if(g!=null){const b=g.shape||t.shape,y=b.length;p+=`${m}: ${y}D ${y>0?b:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${d}	%c${h}	%c${p}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],h=c.inputs;for(const d in h){const p=h[d];let m=!1;for(let g=0;g<e.length;g++)if(s[p.id]){c.outputs.forEach(b=>s[b.id]=!0),m=!0,r[c.id]=!0;break}if(m)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],h=c.inputs;for(let d=0;d<c.outputs.length;d++)if(i[c.outputs[d].id]){for(const p in h)i[h[p].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(r[c.id]&&o[c.id]){const h={};for(const p in c.inputs){const m=c.inputs[p];s[m.id]&&(h[p]=m)}const d=Object.assign({},c);d.inputs=h,d.outputs=c.outputs,a.push(d)}}return a}function k5(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=i.inputs[l];if(!mn(c.shape,h.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=c;else{const d=n[h.id];n[h.id]=s(d,c),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KI=20,Vh=3,Gy=7;function N5(n,e,t,s){const r=Ct(e),i=D5(n,e,t,r),o=e.length,a=qm(n,e,t,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function D5(n,e,t,s){const r=Ne(e),i=s[s.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?qh(n):n;if(a>1)for(let c=0;c<r/i;c++){const h=c*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],jh(l[h+d],0,t).length)}return o}function jh(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Gy))} + ${parseFloat(n[1].toFixed(Gy))}j`:Ed(n)?s=`'${n}'`:t==="bool"?s=UR(n):s=parseFloat(n.toFixed(Gy)).toString(),hu(s,e)}function UR(n){return n===0?"false":"true"}function qm(n,e,t,s,r,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const b=qh(n);return[jh(b[0],0,t)]}return t==="bool"?[UR(n[0])]:[n[0].toString()]}if(l===1){if(a>KI){const y=Vh*o;let v=Array.from(n.slice(0,y)),S=Array.from(n.slice((a-Vh)*o,a*o));return t==="complex64"&&(v=qh(v),S=qh(S)),["["+v.map((C,_)=>jh(C,r[_],t)).join(", ")+", ..., "+S.map((C,_)=>jh(C,r[a-Vh+_],t)).join(", ")+"]"]}return["["+(t==="complex64"?qh(n):Array.from(n)).map((y,v)=>jh(y,r[v],t)).join(", ")+"]"]}const c=e.slice(1),h=s.slice(1),d=s[0]*o,p=[];if(a>KI){for(let b=0;b<Vh;b++){const y=b*d,v=y+d;p.push(...qm(n.slice(y,v),c,t,h,r,!1))}p.push("...");for(let b=a-Vh;b<a;b++){const y=b*d,v=y+d;p.push(...qm(n.slice(y,v),c,t,h,r,b===a-1))}}else for(let b=0;b<a;b++){const y=b*d,v=y+d;p.push(...qm(n.slice(y,v),c,t,h,r,b===a-1))}const m=l===2?",":"";p[0]="["+(a>0?p[0]+m:"");for(let b=1;b<p.length-1;b++)p[b]=" "+p[b]+m;let g=`,
`;for(let b=2;b<l;b++)g+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(i?"":g),p}function qh(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ks{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=Ne(e),s!=null){const r=s.length;W(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||jn(t,this.size),this.strides=Ct(e)}set(e,...t){t.length===0&&(t=[0]),W(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ri().makeTensor(this.values,this.shape,this.dtype)}}let Ri=null,ou=null;function $5(n){Ri=n}function F5(n){ou=n}class as{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ne(e),this.strides=Ct(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ou.buffer(this.shape,this.dtype,e)}bufferSync(){return ou.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Li(this.shape,e,this.dtype==="complex64")}arraySync(){return Li(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ri().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Ba(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ri().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ri().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ba(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ri().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ri().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ou.print(this,e)}clone(){return this.throwIfDisposed(),ou.clone(this)}toString(e=!1){const t=this.dataSync();return N5(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ou.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Ri().makeVariable(this,e,t,s)}}Object.defineProperty(as,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Me(){return SS("Tensor",()=>as)}Me();class fg extends as{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!mn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ri().disposeTensor(this),this.dataId=e.dataId,Ri().incRef(this,null)}dispose(){Ri().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(fg,Symbol.hasInstance,{value:n=>n instanceof as&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var YI;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(YI||(YI={}));var ab;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(ab||(ab={}));var lb;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(lb||(lb={}));var cb;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(cb||(cb={}));var ub;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(ub||(ub={}));const L5={float32:cb,int32:ab,bool:lb,complex64:ub};function $r(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return L5[n][e]}function cw(n){return $r(n,"int32")}function zR(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function BR(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kn(n,e){if(n.dtype===e.dtype)return[n,e];const t=$r(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function VR(n){const e=[];return GR(n,e,new Set),e}function GR(n,e,t){if(n==null)return;if(n instanceof as){e.push(n);return}if(!P5(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),GR(i,e,t))}}function P5(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wy(n){return n.kernelName!=null}class ZI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class wu{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ZI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Wr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new I5(this.backendInstance),!0}setupRegisteredKernels(){XI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){XI(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof gS)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Wr(`Initialization of backend ${e} failed`),Wr(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Wr(`Initialization of backend ${e} failed`),Wr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return wu.nextTensorId++}nextVariableId(){return wu.nextVariableId++}clone(e){const t=ae.runKernel(Xd,{x:e}),s={x:e},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ae.runKernel(Dd,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(WI(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=Wy(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Wy(e)){const{kernelName:g,inputs:b,attrs:y}=e;this.backendName==null&&this.backend;const v=WI(g,this.backendName);W(v!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),a=()=>{const S=this.backend.numDataIds();l=v.kernelFunc({inputs:b,attrs:y,backend:this.backend});const C=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,S,C);const _=C.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(r){const A=this.getTensorsForGradient(g,b,_);s=this.saveTensorsForBackwardMode(A)}return _}}else{const{forwardFunc:g}=e,b=y=>{r&&(s=y.map(v=>this.keep(this.clone(v))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,b));const v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,v),v}}const{inputs:h,attrs:d}=e,p=Wy(e)?null:e.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(m=this.profiler.profileKernel(c,h,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),t=m.outputs)}),r&&this.addTapeNode(c,h,t,p,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(g=>h[g]!=null?h[g].shape:null),outputShapes:t.map(g=>g.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=HI(e);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(W(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=s.filter((c,h)=>o[h]);return a.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&Ed(e[0])&&(i=e.map(l=>La(l)));const o=r.write(i,t,s),a=new as(t,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),c=r5(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,o=new as(r,i,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new fg(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*cg(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof fg||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*cg(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},l=HI(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((h,d)=>{if(h==null){const p=s[d],m=zs(p.size,p.dtype);return this.makeTensor(m,p.shape,p.dtype)}return h}),r(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=VR(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(W(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));W(i instanceof as,()=>"The result y returned by f() must be a tensor.");const o=R5(this.state.activeTape,t,i);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s??O5(i.shape),k5(a,o,c=>this.tidy(c),U5);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return W(tb(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{W(t.every(a=>a instanceof as),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=e(...t,l),W(s.value instanceof as,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),W(tb(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),h=Array.isArray(c)?c:[c];W(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),W(h.every(p=>p instanceof as),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return h.forEach((p,m)=>{d[m]=()=>p}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=dr(),s=await this.backend.time(e);return s.wallMs=dr()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ZI;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}wu.nextTensorId=0;wu.nextVariableId=0;function O5(n){const e=yS(Ne(n),"float32");return ae.makeTensor(e,n,"float32")}function WR(){const n=uR();if(n._tfengine==null){const e=new a5(n);n._tfengine=new wu(e)}return h5(n._tfengine.ENV),$5(()=>n._tfengine),n._tfengine}const ae=WR();function U5(n,e){const t={a:n,b:e};return ae.runKernel(Ou,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z5(){return typeof navigator<"u"&&navigator!=null}function HR(n){if(n||z5()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function XR(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vr=_e();vr.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});vr.registerFlag("IS_BROWSER",()=>XR());vr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");vr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));vr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));vr.registerFlag("PROD",()=>!1);vr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>vr.getBool("DEBUG"));vr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);vr.registerFlag("IS_TEST",()=>!1);vr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>vr.getBool("DEBUG"));vr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);vr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);vr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uu(n,e){let t=n;if(pi(n))return e==="string"?[]:[n.length];if(zR(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(BR(n))return[n.buffer.size/(e==null?4:cg(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||pi(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&_e().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&jR(n,s,[]),s}function jR(n,e,t){if(t=t||[],!Array.isArray(n)&&!pi(n)){W(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}W(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),W(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)jR(n[r],s,t.concat(r))}function QI(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function ee(n,e,t,s="numeric"){if(n instanceof Me())return QI(s,n.dtype,e,t),n;let r=Lu(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),QI(s,r,e,t),n==null||!pi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=Uu(n,r);!pi(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?ac(n,r):Xl(n,[],!0);return ae.makeTensor(a,i,r)}function qR(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>ee(i,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B5="__op";function me(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+B5;const r=(...i)=>{ae.startScope(t);try{const o=s(...i);return bS(o)&&console.error("Cannot return a Promise inside of tidy."),ae.endScope(o),o}catch(o){throw ae.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V5(n,e){const t=ee(n,"real","complex"),s=ee(e,"imag","complex");vS(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return ae.runKernel(MS,r)}const _u=me({complex_:V5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu(n,e,t,s){if(s==null)s=Lu(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(BR(n)||zR(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return ae.backend.createTensorFromGPUData(n,e||t,s)}if(!pi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ko(e);const r=Ne(e),i=Ne(t);W(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Ne(e.slice(o)):!0;W(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!pi(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?ac(n,s):Xl(n,[],!0),ae.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KR(n,e,t){const s=Uu(n,t);return zu(n,e,s,t)}class Bu{static join(e){return new Bu(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>pi(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),o=new Uint8Array(i);let a=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],d=e+a-c.start,p=a,g=Math.min(t,c.end)-c.start,b=new Uint8Array(c.buffer,d,g-d);if(o.set(b,p),a+=b.length,t<c.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=G5(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function G5(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(){return ae}function JI(){return ae.memory()}function be(n,e){return ae.tidy(n,e)}function Yt(n){VR(n).forEach(t=>t.dispose())}function co(n){return ae.keep(n)}function W5(n){return ae.setBackend(n)}function Hy(){return ae.backendName}function YR(n,e,t=1){return ae.registerBackend(n,e,t)}function ZR(){return ae.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e2=4;async function t2(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async d=>{const p=await l.bytes(),m=p.reduce((y,v)=>y+v.length,0)+e2*p.length,g=new Uint8Array(m);let b=0;for(let y=0;y<p.length;y++){const v=p[y],S=new Uint8Array(new Uint32Array([v.length]).buffer);g.set(S,b),b+=e2,g.set(v,b),b+=v.length}d(g)});s.push(h)}else s.push(l.data());e!=null&&(c.group=e),t.push(c)}const i=await Promise.all(s);return{data:H5(i),specs:t}}function H5(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const uw=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function n2(n){return uw?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function X5(n){if(uw)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function j5(n){if(uw){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function q5(n){return Bu.join(n)}function QR(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:n2(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:n2(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Bu(n.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Js{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Js.instance==null&&(Js.instance=new Js),Js.instance}static registerSaveRouter(e){Js.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Js.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Js.getHandlers(e,"save")}static getLoadHandlers(e,t){return Js.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?Js.getInstance().loadRouters:Js.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&r.push(a)}),r}}const K5=n=>Js.getSaveHandlers(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hb="tensorflowjs",db=1,Pl="models_store",Ma="model_info_store";function JR(){if(!_e().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function fb(n){const e=n.result;e.createObjectStore(Pl,{keyPath:"modelPath"}),e.createObjectStore(Ma,{keyPath:"modelPath"})}class jl{constructor(e){if(this.indexedDB=JR(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(hb,db);i.onupgradeneeded=()=>fb(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Pl,"readonly"),c=a.objectStore(Pl).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{t.weightData=Bu.join(t.weightData);const a=QR(t),l=o.transaction(Ma,"readwrite");let c=l.objectStore(Ma),h;try{h=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(p){return r(p)}let d;h.onsuccess=()=>{d=o.transaction(Pl,"readwrite");const p=d.objectStore(Pl);let m;try{m=p.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(g){return r(g)}m.onsuccess=()=>s({modelArtifactsInfo:a}),m.onerror=g=>{c=l.objectStore(Ma);const b=c.delete(this.modelPath);b.onsuccess=()=>(o.close(),r(m.error)),b.onerror=y=>(o.close(),r(m.error))}},h.onerror=p=>(o.close(),r(h.error)),l.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}jl.URL_SCHEME="indexeddb://";const ek=n=>_e().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(jl.URL_SCHEME)?Y5(n.slice(jl.URL_SCHEME.length)):null;Js.registerSaveRouter(ek);Js.registerLoadRouter(ek);function Y5(n){return new jl(n)}function Z5(n){return n.startsWith(jl.URL_SCHEME)?n.slice(jl.URL_SCHEME.length):n}class Q5{constructor(){this.indexedDB=JR()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(hb,db);s.onupgradeneeded=()=>fb(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Ma,"readonly"),a=i.objectStore(Ma).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(r.close(),t(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=Z5(e),new Promise((t,s)=>{const r=this.indexedDB.open(hb,db);r.onupgradeneeded=()=>fb(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Ma,"readwrite"),a=o.objectStore(Ma),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const h=a.delete(e),d=()=>{c=i.transaction(Pl,"readwrite");const m=c.objectStore(Pl).delete(e);m.onsuccess=()=>t(l.result.modelArtifactsInfo),m.onerror=g=>s(l.error)};h.onsuccess=d,h.onerror=p=>(d(),i.close(),s(l.error))}},l.onerror=h=>(i.close(),s(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uo="/",au="tensorflowjs_models",tk="info",J5="model_topology",e6="weight_specs",t6="weight_data",n6="model_metadata";function nk(n){return{info:[au,n,tk].join(Uo),topology:[au,n,J5].join(Uo),weightSpecs:[au,n,e6].join(Uo),weightData:[au,n,t6].join(Uo),modelMetadata:[au,n,n6].join(Uo)}}function sk(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function s6(n){const e=n.split(Uo);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Uo)}function r6(n){return n.startsWith(ql.URL_SCHEME)?n.slice(ql.URL_SCHEME.length):n}class ql{constructor(e){if(!_e().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=nk(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=QR(e),i=Bu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,X5(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw sk(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=j5(o),t}}ql.URL_SCHEME="localstorage://";const rk=n=>_e().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ql.URL_SCHEME)?i6(n.slice(ql.URL_SCHEME.length)):null;Js.registerSaveRouter(rk);Js.registerLoadRouter(rk);function i6(n){return new ql(n)}class o6{constructor(){W(_e().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),W(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=au+Uo,s=Uo+tk;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const o=s6(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=r6(e);const t=nk(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return sk(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s2="://";class Ji{constructor(){this.managers={}}static getInstance(){return Ji.instance==null&&(Ji.instance=new Ji),Ji.instance}static registerManager(e,t){W(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(s2)&&(e=e.slice(0,e.indexOf(s2))),W(e.length>0,()=>"scheme must not be an empty string.");const s=Ji.getInstance();W(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=Ji.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ji.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a6{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!_e().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return $R(e)}}if(_e().get("IS_BROWSER")){_e().setPlatform("browser",new a6);try{Ji.registerManager(ql.URL_SCHEME,new o6)}catch{}try{Ji.registerManager(jl.URL_SCHEME,new Q5)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l6={importFetch:()=>require("node-fetch")};let Xy;class c6{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return _e().global.fetch!=null?_e().global.fetch(e,t):(Xy==null&&(Xy=l6.importFetch()),Xy(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}_e().get("IS_NODE")&&!_e().get("IS_BROWSER")&&_e().setPlatform("node",new c6);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(n,e="float32",t){return e=e||"float32",Ko(n),new ks(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u6(n,e){const t=ee(n,"x","cast");if(!s5(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return ae.runKernel(Dd,s,r)}const at=me({cast_:u6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h6(n){const t={x:ee(n,"x","clone","string_or_numeric")};return ae.runKernel(Xd,t)}const zl=me({clone_:h6});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d6(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */WR();const f6={buffer:jt,cast:at,clone:zl,print:d6};F5(f6);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6(n,e){let t=ee(n,"a","add"),s=ee(e,"b","add");[t,s]=Kn(t,s);const r={a:t,b:s};return ae.runKernel(Ou,r)}const je=me({add_:p6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6(n,e){let t=ee(n,"a","floorDiv"),s=ee(e,"b","floorDiv");[t,s]=Kn(t,s);const r={a:t,b:s};return ae.runKernel(Wd,r)}const ik=me({floorDiv_:m6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g6(n,e){let t=ee(n,"a","div"),s=ee(e,"b","div");if([t,s]=Kn(t,s),t.dtype==="int32"&&s.dtype==="int32")return ik(t,s);const r={a:t,b:s},i={};return ae.runKernel(Od,r,i)}const At=me({div_:g6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x6(n,e){let t=ee(n,"a","mul"),s=ee(e,"b","mul");[t,s]=Kn(t,s);const r={a:t,b:s};return ae.runKernel(tf,r)}const oe=me({mul_:x6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v6(n){const e=ee(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ae.runKernel(n0,t)}else{const t={x:e};return ae.runKernel(Kg,t)}}const er=me({abs_:v6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y6(n){const t={x:ee(n,"x","acos")};return ae.runKernel(Td,t)}const b6=me({acos_:y6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S6(n){const t={x:ee(n,"x","acosh")};return ae.runKernel(Id,t)}const w6=me({acosh_:S6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _6(n,e=null,t=!1){const r={x:ee(n,"x","all","bool")},i={axis:e,keepDims:t};return ae.runKernel(_S,r,i)}const ok=me({all_:_6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C6(n,e=null,t=!1){const r={x:ee(n,"x","any","bool")},i={axis:e,keepDims:t};return ae.runKernel(CS,r,i)}const pb=me({any_:C6});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E6(n,e=0){const s={x:ee(n,"x","argMax")},r={axis:e};return ae.runKernel(Yg,s,r)}const cd=me({argMax_:E6});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T6(n,e=0){const s={x:ee(n,"x","argMin")},r={axis:e};return ae.runKernel(Zg,s,r)}const I6=me({argMin_:T6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A6(n){const t={x:ee(n,"x","asin")};return ae.runKernel(Ad,t)}const M6=me({asin_:A6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R6(n){const t={x:ee(n,"x","asinh")};return ae.runKernel(Md,t)}const k6=me({asinh_:R6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N6(n){const t={x:ee(n,"x","atan")};return ae.runKernel(Rd,t)}const D6=me({atan_:N6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6(n,e){let t=ee(n,"a","atan2"),s=ee(e,"b","atan2");[t,s]=Kn(t,s);const r={a:t,b:s};return ae.runKernel(Nd,r)}const F6=me({atan2_:$6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L6(n){const t={x:ee(n,"x","atanh")};return ae.runKernel(kd,t)}const P6=me({atanh_:L6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wf(n,e,t,s,r="NHWC",i){const o=n[3],a=[...e,o],l=Zo(r);return Ns(n,a,t,i,s,null,null,l)}function gi(n,e,t,s,r,i,o="channelsLast"){const[a,l]=ud(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ns(n,c,t,s,r,i,!1,o)}function Yo(n,e,t,s,r,i,o="NDHWC"){const[a,l,c]=mb(e);let h,d;if(o==="NDHWC")d="channelsLast",h=[a,l,c,n[4],n[4]];else if(o==="NCDHW")d="channelsFirst",h=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ya(n,h,t,s,r,!1,d,i)}function Ns(n,e,t,s,r,i,o=!1,a="channelsLast"){let[l,c,h,d]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,h,d]=n;else if(a==="channelsFirst")[l,d,c,h]=n;else throw new Error(`Unknown dataFormat ${a}`);const[p,m,,g]=e,[b,y]=ud(t),[v,S]=ud(s),C=fu(p,v),_=fu(m,S),{padInfo:A,outHeight:k,outWidth:N}=z6(r,c,h,b,y,C,_,i,a),D=o?g*d:g;let M;return a==="channelsFirst"?M=[l,D,k,N]:a==="channelsLast"&&(M=[l,k,N,D]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:h,inChannels:d,outHeight:k,outWidth:N,outChannels:D,padInfo:A,strideHeight:b,strideWidth:y,filterHeight:p,filterWidth:m,effectiveFilterHeight:C,effectiveFilterWidth:_,dilationHeight:v,dilationWidth:S,inShape:n,outShape:M,filterShape:e}}function Ya(n,e,t,s,r,i=!1,o="channelsLast",a){let[l,c,h,d,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,d,p]=n;else if(o==="channelsFirst")[l,p,c,h,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[m,g,b,,y]=e,[v,S,C]=mb(t),[_,A,k]=mb(s),N=fu(m,_),D=fu(g,A),M=fu(b,k),{padInfo:T,outDepth:I,outHeight:$,outWidth:O}=B6(r,c,h,d,v,S,C,N,D,M,a),B=i?y*p:y;let V;return o==="channelsFirst"?V=[l,B,I,$,O]:o==="channelsLast"&&(V=[l,I,$,O,B]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:h,inWidth:d,inChannels:p,outDepth:I,outHeight:$,outWidth:O,outChannels:B,padInfo:T,strideDepth:v,strideHeight:S,strideWidth:C,filterDepth:m,filterHeight:g,filterWidth:b,effectiveFilterDepth:N,effectiveFilterHeight:D,effectiveFilterWidth:M,dilationDepth:_,dilationHeight:A,dilationWidth:k,inShape:n,outShape:V,filterShape:e}}function O6(n,e,t,s,r){s==null&&(s=hw(n,e,t));const i=n[0],o=n[1],a=hd((i-e+2*s)/t+1,r),l=hd((o-e+2*s)/t+1,r);return[a,l]}function U6(n,e,t,s,r,i){r==null&&(r=hw(n,e[0],s[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*r>=e[a]&&(o[a]=hd((n[a]-e[a]+2*r)/s[a]+1,i));return o}function hw(n,e,t,s=1){const r=fu(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function ud(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function mb(n){return typeof n=="number"?[n,n,n]:n}function fu(n,e){return e<=1?n:n+(n-1)*(e-1)}function z6(n,e,t,s,r,i,o,a,l){let c,h,d;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const m=O6([e,t],i,s,n,a);h=m[0],d=m[1]}else if(n==="same"){h=Math.ceil(e/s),d=Math.ceil(t/r);const p=Math.max(0,(h-1)*s+i-e),m=Math.max(0,(d-1)*r+o-t),g=Math.floor(p/2),b=p-g,y=Math.floor(m/2),v=m-y;c={top:g,bottom:b,left:y,right:v,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-i+1)/s),d=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const p=l==="channelsLast"?n[1][0]:n[2][0],m=l==="channelsLast"?n[1][1]:n[2][1],g=l==="channelsLast"?n[2][0]:n[3][0],b=l==="channelsLast"?n[2][1]:n[3][1];c={top:p,bottom:m,left:g,right:b,type:p===0&&m===0&&g===0&&b===0?"VALID":"EXPLICIT"},h=hd((e-i+p+m)/s+1,a),d=hd((t-o+g+b)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:h,outWidth:d}}function B6(n,e,t,s,r,i,o,a,l,c,h){let d,p,m,g;if(n==="valid"&&(n=0),typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=U6([e,t,s,1],[a,l,c],1,[r,i,o],n,h);p=y[0],m=y[1],g=y[2]}else if(n==="same"){p=Math.ceil(e/r),m=Math.ceil(t/i),g=Math.ceil(s/o);const b=(p-1)*r+a-e,y=(m-1)*i+l-t,v=(g-1)*o+c-s,S=Math.floor(b/2),C=b-S,_=Math.floor(y/2),A=y-_,k=Math.floor(v/2),N=v-k;d={top:_,bottom:A,left:k,right:N,front:S,back:C,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:p,outHeight:m,outWidth:g}}function hd(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Kl(n){const[e,t,s]=ud(n);return e===1&&t===1&&s===1}function Vs(n,e){return Kl(n)||Kl(e)}function Yl(n){return ud(n).every(e=>e>0)}function Zo(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function wr(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")W(Su(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{W(Su(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V6(n,e){const s={x:ee(n,"x","reshape","string_or_numeric")},r={shape:e};return ae.runKernel(L0,s,r)}const fe=me({reshape_:V6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G6(n,e,t,s,r){const i=ee(n,"x","avgPool","float32"),o=1;W(Vs(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=fe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),wr("avgPool",s,r);const c={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let d=ae.runKernel(Qg,c,h);return d=at(d,i.dtype),l?fe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const dw=me({avgPool_:G6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W6(n,e,t,s,r,i="NDHWC"){const o=ee(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=fe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),W(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),W(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),wr("avgPool3d",s,r);const c={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let d=ae.runKernel(Jg,c,h);return d=at(d,a.dtype),l?fe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const H6=me({avgPool3d_:W6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X6(n,e=0){W(n.length>=1,()=>"Pass at least one tensor to concat");const t=qR(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return zl(t[0]);const s=t,r={axis:e};return ae.runKernel(s0,s,r)}const xr=me({concat_:X6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j6(n,e,t=!1,s=!1){let r=ee(n,"a","matMul"),i=ee(e,"b","matMul");[r,i]=Kn(r,i);const o={a:r,b:i},a={transposeA:t,transposeB:s};return ae.runKernel(e0,o,a)}const pn=me({matMul_:j6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q6(n){const t={x:ee(n,"x","sigmoid","float32")};return ae.runKernel(ff,t)}const Vu=me({sigmoid_:q6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K6(n,e,t){const s=ee(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return ae.runKernel(B0,r,i)}const In=me({slice_:K6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y6(n){const t={x:ee(n,"x","tanh","float32")};return ae.runKernel(yf,t)}const Y0=me({tanh_:Y6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z6(n,e,t){const s=ee(n,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);W(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),W(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),W(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},o={blockShape:e,crops:t};return ae.runKernel(t0,i,o)}const fw=me({batchToSpaceND_:Z6});function Q6(n){let e;return n.rank===0||n.rank===1?e=fe(n,[1,1,1,n.size]):n.rank===2?e=fe(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=fe(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J6(n,e,t,s,r,i){i==null&&(i=.001);const o=ee(n,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(t,"variance","batchNorm");let c;r!=null&&(c=ee(r,"scale","batchNorm"));let h;s!=null&&(h=ee(s,"offset","batchNorm")),W(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(h==null||a.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:Q6(o),scale:c,offset:h,mean:a,variance:l},m={varianceEpsilon:i},g=ae.runKernel(d0,p,m);return fe(g,o.shape)}const Z0=me({batchNorm_:J6});function e8(n,e,t,s,r,i){const o=ee(n,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(t,"variance","batchNorm");let c;r!=null&&(c=ee(r,"scale","batchNorm"));let h;return s!=null&&(h=ee(s,"offset","batchNorm")),W(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),W(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),W(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&W(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&W(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),Z0(o,a,l,h,c,i)}const t8=me({batchNorm2d_:e8});function n8(n,e,t,s,r,i){const o=ee(n,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(t,"variance","batchNorm");let c;r!=null&&(c=ee(r,"scale","batchNorm"));let h;return s!=null&&(h=ee(s,"offset","batchNorm")),W(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),W(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),W(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&W(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&W(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),Z0(o,a,l,h,c,i)}const s8=me({batchNorm3d_:n8});function r8(n,e,t,s,r,i){const o=ee(n,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(t,"variance","batchNorm");let c;r!=null&&(c=ee(r,"scale","batchNorm"));let h;return s!=null&&(h=ee(s,"offset","batchNorm")),W(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),W(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),W(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&W(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&W(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),Z0(o,a,l,h,c,i)}const i8=me({batchNorm4d_:r8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n,e,t){const s=ee(n,"x","bincount"),r=ee(e,"weights","bincount");W(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),W(t>=0,()=>`size must be non-negative, but got ${t}.`),W(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:t};return ae.runKernel(IS,i,o)}const a8=me({bincount_:o8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8(n,e){let t=ee(n,"broadcastTo","x");const s=t.shape;if(Ko(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=fe(t,c)}const r=t.shape,i=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])i[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return zl(t);const a={x:t},l={reps:i};return ae.runKernel(bf,a,l)}const Jh=me({broadcastTo_:l8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8(n){const t={x:ee(n,"x","ceil","float32")};return ae.runKernel($d,t)}const u8=me({ceil_:c8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0(n,e,t){Ko(n),t=t||Lu(e);const s={shape:n,value:e,dtype:t};return ae.runKernel(VS,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n,e,t){const s=ee(n,"x","clipByValue");if(W(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Q0(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return ae.runKernel(Fd,r,i)}const qr=me({clipByValue_:h8});function d8(n){return xr(n,0)}const f8=me({concat1d_:d8});function p8(n,e){return xr(n,e)}const m8=me({concat2d_:p8});function g8(n,e){return xr(n,e)}const x8=me({concat3d_:g8});function v8(n,e){return xr(n,e)}const y8=me({concat4d_:v8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b8(n,e,t,s,r="NHWC",i=[1,1],o){const a=ee(n,"x","conv2d","float32"),l=ee(e,"filter","conv2d","float32");let c=a,h=!1;a.rank===3&&(h=!0,c=fe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),W(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),W(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),wr("conv2d",s,o);const d=r==="NHWC"?c.shape[3]:c.shape[1];W(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),W(Vs(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),W(Yl(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),W(Yl(t),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},m={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},g=ae.runKernel(r0,p,m);return h?fe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Zl=me({conv2d_:b8});function S8(n,e,t,s,r="NWC",i=1,o){const a=ee(n,"x","conv1d"),l=ee(e,"filter","conv1d");let c=a,h=!1;a.rank===2&&(h=!0,c=fe(a,[1,a.shape[0],a.shape[1]])),W(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),W(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),wr("conv1d",s,o),W(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),W(Vs(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),W(Yl(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),W(Yl(t),()=>"Error in conv1D: Stride should be larger than 0."),W(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=fe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=fe(c,[c.shape[0],1,c.shape[1],c.shape[2]]),y=Zl(p,d,[1,t],s,"NHWC",[1,i],o);return h?fe(y,[y.shape[2],y.shape[3]]):fe(y,[y.shape[0],y.shape[2],y.shape[3]])}const ak=me({conv1d_:S8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w8(n,e,t,s,r,i="NHWC",o){W(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),W(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),W(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),W(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const h=i==="NHWC"?a[3]:a[1],d=i==="NHWC"?l.shape[3]:l.shape[1];W(h===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[2]}.`),W(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),wr("conv2dDerInput",r,o);const p={dy:l,filter:t},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},g=ae.runKernel(i0,p,m);return c?fe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const pw=me({conv2DBackpropInput_:w8});function _8(n,e,t,s,r,i){const o=ee(n,"x","conv2dTranspose"),a=ee(e,"filter","conv2dTranspose");return pw(t,o,a,s,r,"NHWC",i)}const lk=me({conv2dTranspose_:_8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C8(n,e,t,s,r="NDHWC",i=[1,1,1]){const o=ee(n,"x","conv3d"),a=ee(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=fe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),W(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),W(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),W(Vs(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),W(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),W(Yl(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),W(Yl(t),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:l,filter:a},d={strides:t,pad:s,dataFormat:r,dilations:i},p=ae.runKernel(o0,h,d);return c?fe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const gb=me({conv3d_:C8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E8(n,e,t,s,r){W(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=fe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];W(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),W(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),W(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),W(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),W(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const h={dy:o,filter:t},d={pad:r,strides:s,inputShape:i},p=ae.runKernel(NS,h,d);return a?fe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const ck=me({conv3DBackpropInput_:E8});function T8(n,e,t,s,r){const i=ee(n,"x","conv3dTranspose"),o=ee(e,"filter","conv3dTranspose");return ck(t,i,o,s,r)}const I8=me({conv3dTranspose_:T8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A8(n){const t={x:ee(n,"x","cos","float32")};return ae.runKernel(Ld,t)}const mw=me({cos_:A8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M8(n){const t={x:ee(n,"x","cosh","float32")};return ae.runKernel(Pd,t)}const uk=me({cosh_:M8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R8(n,e=0,t=!1,s=!1){const i={x:ee(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return ae.runKernel(DS,i,o)}const xb=me({cumprod_:R8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k8(n,e=0,t=!1,s=!1){const i={x:ee(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return ae.runKernel(a0,i,o)}const hk=me({cumsum_:k8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N8(n,e,t,s=!1){const r=ee(n,"x","denseBincount"),i=ee(e,"weights","denseBincount");W(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),W(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),W(t>=0,()=>`size must be non-negative, but got ${t}.`),W(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:t,binaryOutput:s};return ae.runKernel(FS,o,a)}const r2=me({denseBincount_:N8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D8(n,e,t="NHWC"){const s=ee(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];W(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),W(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),W(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),W(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return ae.runKernel(LS,a,l)}const $8=me({depthToSpace_:D8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F8(n,e,t,s,r="NHWC",i=[1,1],o){const a=ee(n,"x","depthwiseConv2d","float32"),l=ee(e,"filter","depthwiseConv2d","float32");let c=a,h=!1;a.rank===3&&(h=!0,c=fe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),W(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),W(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=r==="NHWC"?c.shape[3]:c.shape[1];W(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),wr("depthwiseConv2d",s,o);const p={x:c,filter:l},m={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},g=ae.runKernel(l0,p,m);return h?fe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const gw=me({depthwiseConv2d_:F8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L8(n,e,t,s,r=[1,1],i="NHWC"){const o=ee(n,"x","dilation2d"),a=ee(e,"filter","dilation2d");W(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),W(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),W(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=fe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),W(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h={x:l,filter:a},d={strides:t,pad:s,dilations:r},p=ae.runKernel(c0,h,d);return c?fe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const P8=me({dilation2d_:L8});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cu(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,o=n[i]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function fs(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,o=e[i];(r==null||r===1&&o>1)&&t.unshift(i)}return t}function Ut(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=e[e.length-r-1];if(o==null&&(o=1),i===1)s[t-r-1]=o;else if(o===1)s[t-r-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-r-1]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O8(n,e){let t=ee(n,"a","equal","string_or_numeric"),s=ee(e,"b","equal","string_or_numeric");[t,s]=Kn(t,s),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(u0,r)}const mo=me({equal_:O8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U8(n,e,t){const s=ee(e,"a","where"),r=ee(t,"b","where"),i=ee(n,"condition","where","bool"),o=Ut(Ut(i.shape,s.shape),r.shape),a=Jh(i,o),l=Jh(s,o),c=Jh(r,o),h={condition:a,t:l,e:c};return ae.runKernel(z0,h)}const ir=me({where_:U8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z8(n){const t={x:ee(n,"x","zerosLike")};return ae.runKernel(q0,t)}const rn=me({zerosLike_:z8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B8(n,e){let t=ee(n,"a","div"),s=ee(e,"b","div");[t,s]=Kn(t,s);const r=At(t,s),i=rn(r),o=mo(s,i);return ir(o,i,r)}const V8=me({divNoNan_:B8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G8(n,e){const t=ee(n,"t1","dot"),s=ee(e,"t2","dot");W((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(W(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const o=fe(t,[1,-1]),a=fe(s,[-1,1]),l=pn(o,a);return fe(l,[])}else if(t.rank===1&&s.rank===2){const o=fe(t,[1,-1]),a=fe(s,[s.shape[0],s.shape[1]]),l=pn(o,a);return fe(l,[l.size])}else if(t.rank===2&&s.rank===1){const o=fe(s,[-1,1]),a=pn(t,o);return fe(a,[a.size])}else{const o=fe(s,[s.shape[0],s.shape[1]]);return pn(t,o)}}const W8=me({dot_:G8});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8(n,...e){const t=e.map((r,i)=>ee(r,`tensors${i}`,"einsum")),s={equation:n};return ae.runKernel(US,t,s)}const Gh=me({einsum_:H8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X8(n){const t={x:ee(n,"x","elu","float32")};return ae.runKernel(Ud,t)}const J0=me({elu_:X8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j8(n){let e=ee(n,"x","erf");W(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=at(e,"float32"));const t={x:e};return ae.runKernel(zd,t)}const dk=me({erf_:j8});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xw(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function fk(n,e,t){const s=n.length+e.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?r.push(n[i++]):r.push(e[o++]);return r}function ws(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function rs(n,e){const t=e.map(s=>1);return fk(n,t,e)}function Ds(n,e,t){W(xw(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function zn(n,e){if(xw(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Za(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Yn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q8(n,e=null,t=!1){const r={x:ee(n,"x","max")},i={reductionIndices:e,keepDims:t};return ae.runKernel(w0,r,i)}const Pi=me({max_:q8});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K8(n,e=null,t=!1){const r={x:ee(n,"x","min")},i={axis:e,keepDims:t};return ae.runKernel(T0,r,i)}const pg=me({min_:K8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y8(n,e){let t=ee(n,"base","pow"),s=ee(e,"exp","pow");[t,s]=Kn(t,s);const r={a:t,b:s};return ae.runKernel(nf,r)}const Ql=me({pow_:Y8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function en(n,e){if((pi(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&pi(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return zu(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z8(n){const t={x:ee(n,"x","sqrt","float32")};return ae.runKernel(mf,t)}const Bs=me({sqrt_:Z8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q8(n){const e=ee(n,"x","square"),t={};return ae.runKernel("Square",{x:e},t)}const kn=me({square_:Q8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J8(n,e=null,t=!1){let s=ee(n,"x","sum");s.dtype==="bool"&&(s=at(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return ae.runKernel(V0,r,i)}const It=me({sum_:J8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eX(n,e="euclidean",t=null,s=!1){n=ee(n,"x","norm");const r=pk(n,e,t);let i=r.shape;if(s){const o=qt(t,n.shape);i=rs(r.shape,o)}return fe(r,i)}function pk(n,e,t=null){if(n.rank===0)return er(n);if(n.rank!==1&&t===null)return pk(fe(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return It(er(n),t);if(e===1/0)return Pi(er(n),t);if(e===-1/0)return pg(er(n),t);if(e==="euclidean"||e===2)return Bs(It(Ql(er(n),en(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Pi(It(er(n),t[0]),t[1]-1);if(e===1/0)return Pi(It(er(n),t[1]),t[0]);if(e===-1/0)return pg(It(er(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Bs(It(kn(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const ex=me({norm_:eX});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tX(n,e=null,t=!1){return ex(n,"euclidean",e,t)}const nX=me({euclideanNorm_:tX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sX(n){const t={x:ee(n,"x","exp")};return ae.runKernel(Bd,t)}const go=me({exp_:sX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rX(n,e=0){const t=ee(n,"x","expandDims","string_or_numeric");W(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return ae.runKernel(h0,s,r)}const fr=me({expandDims_:rX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iX(n){const t={x:ee(n,"x","expm1")};return ae.runKernel(Vd,t)}const oX=me({expm1_:iX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aX(n,e){const t=ee(n,"x","tile","string_or_numeric");W(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return ae.runKernel(bf,s,r)}const Di=me({tile_:aX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lX(n,e,t,s="float32"){e==null&&(e=n);const r=jt([n,e],s),i=n<=e?n:e;for(let a=0;a<i;++a)r.set(1,a,a);const o=fe(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Di(fr(o,0),[t[0],1,1]);if(t.length===2)return Di(fr(fr(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Di(fr(fr(fr(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const mk=me({eye_:lX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cX(n){const t={x:ee(n,"x","floor","float32")};return ae.runKernel(Gd,t)}const tx=me({floor_:cX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uX(n,e,t=0,s=0){const r=ee(n,"x","gather"),i=ee(e,"indices","gather","int32"),o={x:r,indices:i},a={axis:t,batchDims:s};return ae.runKernel(f0,o,a)}const vw=me({gather_:uX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hX(n,e){let t=ee(n,"a","greater","string_or_numeric"),s=ee(e,"b","greater","string_or_numeric");[t,s]=Kn(t,s),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(p0,r)}const Kr=me({greater_:hX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dX(n,e){let t=ee(n,"a","greaterEqual","string_or_numeric"),s=ee(e,"b","greaterEqual","string_or_numeric");[t,s]=Kn(t,s),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(Hd,r)}const lc=me({greaterEqual_:dX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fX(n){const t={input:ee(n,"input","imag")};return ae.runKernel(HS,t)}const yw=me({imag_:fX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pX(n){const t={x:ee(n,"x","isFinite")};return ae.runKernel(jd,t)}const mX=me({isFinite_:pX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(n){const t={x:ee(n,"x","isInf")};return ae.runKernel(qd,t)}const xX=me({isInf_:gX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vX(n){const t={x:ee(n,"x","isNaN")};return ae.runKernel(Kd,t)}const yX=me({isNaN_:vX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bX(n,e=.2){const s={x:ee(n,"x","leakyRelu")},r={alpha:e};return ae.runKernel(m0,s,r)}const bw=me({leakyRelu_:bX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SX(n,e){let t=ee(n,"a","less","string_or_numeric"),s=ee(e,"b","less","string_or_numeric");[t,s]=Kn(t,s),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(g0,r)}const mg=me({less_:SX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(n,e){let t=ee(n,"a","lessEqual","string_or_numeric"),s=ee(e,"b","lessEqual","string_or_numeric");[t,s]=Kn(t,s),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(x0,r)}const Gu=me({lessEqual_:wX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _X(n,e=5,t=1,s=1,r=.5){const i=ee(n,"x","localResponseNormalization");W(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),W(Su(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=fe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:s,beta:r},h=ae.runKernel(S0,l,c);return a?fe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const CX=me({localResponseNormalization_:_X});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(n){const t={x:ee(n,"x","log","float32")};return ae.runKernel(Yd,t)}const xo=me({log_:EX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TX(n){const t={x:ee(n,"x","log1p")};return ae.runKernel(Zd,t)}const gk=me({log1p_:TX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IX(n,e){W(tb(n),()=>"The f passed in variableGrads(f) must be a function"),W(e==null||Array.isArray(e)&&e.every(c=>c instanceof fg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in ae.registeredVariables)e.push(ae.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,r=e.length;e=e.filter(c=>c.trainable),W(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=ae.gradients(n,e,null,i);W(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),W(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,h)=>{a[h]!=null&&(l[c.name]=a[h])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:o,grads:l}}function Eu(n){return ae.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AX(n){const t={x:ee(n,"x","neg")};return ae.runKernel(A0,t)}const qn=me({neg_:AX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MX(n){const t={x:ee(n,"x","softplus")};return ae.runKernel(pf,t)}const _f=me({softplus_:MX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RX(n){const e=ee(n,"x","logSigmoid");return Eu(s=>({value:qn(_f(qn(s))),gradFunc:o=>oe(o,Vu(qn(s)))}))(e)}const kX=me({logSigmoid_:RX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NX(n,e){let t=ee(n,"a","sub"),s=ee(e,"b","sub");[t,s]=Kn(t,s);const r={a:t,b:s};return ae.runKernel(xf,r)}const Nt=me({sub_:NX});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DX(n,e=-1){const t=ee(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Eu((r,i)=>{const a=Pi(r,e,!0),l=Nt(r,a),c=Nt(at(l,"float32"),xo(It(go(l),e,!0)));return i([c]),{value:c,gradFunc:(d,p)=>{const[m]=p,g=!0,b=go(m);return Nt(d,oe(It(d,e,g),b))}}})(t)}const xk=me({logSoftmax_:DX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $X(n,e=null,t=!1){const s=ee(n,"x","logSumExp"),r=qt(e,s.shape),i=Pi(s,r,!0),o=Nt(s,i),a=go(o),l=It(a,r),c=xo(l),h=je(fe(i,c.shape),c);if(t){const d=rs(h.shape,r);return fe(h,d)}return h}const vk=me({logSumExp_:$X});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FX(n,e){const t=ee(n,"a","logicalAnd","bool"),s=ee(e,"b","logicalAnd","bool");Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(v0,r)}const Ho=me({logicalAnd_:FX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LX(n){const t={x:ee(n,"x","logicalNot","bool")};return ae.runKernel(y0,t)}const Sw=me({logicalNot_:LX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(n,e){const t=ee(n,"a","logicalOr","bool"),s=ee(e,"b","logicalOr","bool");Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(b0,r)}const yk=me({logicalOr_:PX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(n,e){const t=ee(n,"a","logicalXor","bool"),s=ee(e,"b","logicalXor","bool");return Ut(t.shape,s.shape),Ho(yk(n,e),Sw(Ho(n,e)))}const UX=me({logicalXor_:OX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zX(n,e,t,s,r){const i=ee(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=fe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),W(Vs(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),wr("maxPool",s,r);const c={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r},d=ae.runKernel(_0,c,h);return l?fe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ww=me({maxPool_:zX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BX(n,e=[1,1,1],t,s,r,i="NDHWC"){const o=ee(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=fe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),W(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),wr("maxPool3d",s,r);const c={x:a},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},d=ae.runKernel(C0,c,h);return l?fe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const VX=me({maxPool3d_:BX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GX(n,e){let t=ee(n,"a","maximum"),s=ee(e,"b","maximum");[t,s]=Kn(t,s),t.dtype==="bool"&&(t=at(t,"int32"),s=at(s,"int32")),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(Qd,r)}const Qa=me({maximum_:GX});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WX(n,e=null,t=!1){const r={x:ee(n,"x","mean")},i={axis:e,keepDims:t};return ae.runKernel(E0,r,i)}const ss=me({mean_:WX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(n,e="float32"){if(Ko(n),e==="complex64"){const s=ls(n,"float32"),r=ls(n,"float32");return _u(s,r)}const t=zs(Ne(n),e);return ae.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ja(n,e="float32"){if(Ko(n),e==="complex64"){const s=Ja(n,"float32"),r=ls(n,"float32");return _u(s,r)}const t=yS(Ne(n),e);return ae.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HX(n,e){let t=ee(n,"a","minimum"),s=ee(e,"b","minimum");[t,s]=Kn(t,s),t.dtype==="bool"&&(t=at(t,"int32"),s=at(s,"int32")),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(Jd,r)}const dd=me({minimum_:HX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XX(n,e,t){W(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=ee(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");W(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)W(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),W(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},o={x:s};return ae.runKernel(I0,o,i)}const jX=me({mirrorPad_:XX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qX(n,e){let t=ee(n,"a","mod"),s=ee(e,"b","mod");[t,s]=Kn(t,s);const r={a:t,b:s};return ae.runKernel(ef,r)}const KX=me({mod_:qX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YX(n,e=null,t=!1){n=ee(n,"x","moments");const s=qt(e,n.shape),r=ss(n,s,t);let i=r.shape;t||(i=rs(r.shape,s));const o=kn(Nt(at(n,"float32"),fe(r,i))),a=ss(o,s,t);return{mean:r,variance:a}}const _w=me({moments_:YX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZX(n,e){let t=ee(n,"a","notEqual","string_or_numeric"),s=ee(e,"b","notEqual","string_or_numeric");[t,s]=Kn(t,s),Ut(t.shape,s.shape);const r={a:t,b:s};return ae.runKernel(M0,r)}const gg=me({notEqual_:ZX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QX(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:ee(n,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:t,offValue:s};return ae.runKernel(k0,o,a)}const bk=me({oneHot_:QX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JX(n){const t={x:ee(n,"x","onesLike")};return ae.runKernel(R0,t)}const mi=me({onesLike_:JX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ej(n,e,t=0){const s=ee(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return ae.runKernel(D0,i,r)}const Cw=me({pad_:ej});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tj(n,e,t){const s=ee(n,"x","spaceToBatchND");W(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),W(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),W(s.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return ae.runKernel(G0,r,i)}const Ew=me({spaceToBatchND_:tj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nj(n,e,t,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const a=ee(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=fe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),W(Vs(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const h=gi(l.shape,e,i,r,s),d=[h.dilationHeight,h.dilationWidth];let p;s==="same"?p=rj([h.filterHeight,h.filterWidth],d):p=[[0,0],[0,0]];const m=d[0]===1&&d[1]===1,[g,b]=sj([h.inHeight,h.inWidth],d,p),y=m?s:"valid",v=m?l:Ew(l,d,g),C=(t==="avg"?()=>dw(v,e,i,y,o):()=>ww(v,e,i,y,o))(),_=m?C:fw(C,d,b);return c?fe(_,[_.shape[1],_.shape[2],_.shape[3]]):_}function sj(n,e,t){const s=t.map(h=>h[0]),r=t.map(h=>h[1]),i=n.concat(s,r),o=e.map((h,d)=>(h-i[d]%h)%h),a=r.map((h,d)=>h+o[d]),l=e.map((h,d)=>[s[d],a[d]]),c=e.map((h,d)=>[0,o[d]]);return[l,c]}function rj(n,e){const s=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}const ij=me({pool_:nj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oj(n,e){const t=ee(n,"x","prelu"),s=ee(e,"alpha","prelu"),r={x:t,alpha:s};return ae.runKernel($0,r)}const Tw=me({prelu_:oj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aj(n,e=null,t=!1){let s=ee(n,"x","prod");s.dtype==="bool"&&(s=at(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return ae.runKernel(F0,r,i)}const lj=me({prod_:aj});var Km={exports:{}},cj=Km.exports,i2;function uj(){return i2||(i2=1,function(n){(function(e,t,s){function r(l){var c=this,h=a();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(l),c.s0<0&&(c.s0+=1),c.s1-=h(l),c.s1<0&&(c.s1+=1),c.s2-=h(l),c.s2<0&&(c.s2+=1),h=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var h=new r(l),d=c&&c.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}function a(){var l=4022871197,c=function(h){h=String(h);for(var d=0;d<h.length;d++){l+=h.charCodeAt(d);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:this.alea=o})(cj,n)}(Km)),Km.exports}var Ym={exports:{}},hj=Ym.exports,o2;function dj(){return o2||(o2=1,function(n){(function(e,t,s){function r(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},a===(a|0)?l.x=a:c+=a;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new r(a),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&i(h,c),d.state=function(){return i(c,{})}),d}t&&t.exports?t.exports=o:this.xor128=o})(hj,n)}(Ym)),Ym.exports}var Zm={exports:{}},fj=Zm.exports,a2;function pj(){return a2||(a2=1,function(n){(function(e,t,s){function r(a){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,h==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new r(a),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&i(h,c),d.state=function(){return i(c,{})}),d}t&&t.exports?t.exports=o:this.xorwow=o})(fj,n)}(Zm)),Zm.exports}var Qm={exports:{}},mj=Qm.exports,l2;function gj(){return l2||(l2=1,function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var h=l.x,d=l.i,p,m;return p=h[d],p^=p>>>7,m=p^p<<24,p=h[d+1&7],m^=p^p>>>10,p=h[d+3&7],m^=p^p>>>3,p=h[d+4&7],m^=p^p<<7,p=h[d+7&7],p=p^p<<13,m^=p^p<<9,h[d]=m,l.i=d+1&7,m};function c(h,d){var p,m=[];if(d===(d|0))m[0]=d;else for(d=""+d,p=0;p<d.length;++p)m[p&7]=m[p&7]<<15^d.charCodeAt(p)+m[p+1&7]<<13;for(;m.length<8;)m.push(0);for(p=0;p<8&&m[p]===0;++p);for(p==8?m[7]=-1:m[p],h.x=m,h.i=0,p=256;p>0;--p)h.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(h.x&&i(h,c),d.state=function(){return i(c,{})}),d}t&&t.exports?t.exports=o:this.xorshift7=o})(mj,n)}(Qm)),Qm.exports}var Jm={exports:{}},xj=Jm.exports,c2;function vj(){return c2||(c2=1,function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var h=l.w,d=l.X,p=l.i,m,g;return l.w=h=h+1640531527|0,g=d[p+34&127],m=d[p=p+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,g=d[p]=g^m,l.i=p,g+(h^h>>>16)|0};function c(h,d){var p,m,g,b,y,v=[],S=128;for(d===(d|0)?(m=d,d=null):(d=d+"\0",m=0,S=Math.max(S,d.length)),g=0,b=-32;b<S;++b)d&&(m^=d.charCodeAt((b+32)%d.length)),b===0&&(y=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,b>=0&&(y=y+1640531527|0,p=v[b&127]^=m+y,g=p==0?g+1:0);for(g>=128&&(v[(d&&d.length||0)&127]=-1),g=127,b=4*128;b>0;--b)m=v[g+34&127],p=v[g=g+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,v[g]=m^p;h.w=y,h.X=v,h.i=g}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(h.X&&i(h,c),d.state=function(){return i(c,{})}),d}t&&t.exports?t.exports=o:this.xor4096=o})(xj,n)}(Jm)),Jm.exports}var eg={exports:{}},yj=eg.exports,u2;function bj(){return u2||(u2=1,function(n){(function(e,t,s){function r(a){var l=this,c="";l.next=function(){var d=l.b,p=l.c,m=l.d,g=l.a;return d=d<<25^d>>>7^p,p=p-m|0,m=m<<24^m>>>8^g,g=g-d|0,l.b=d=d<<20^d>>>12^p,l.c=p=p-m|0,l.d=m<<16^p>>>16^g,l.a=g-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var h=0;h<c.length+20;h++)l.b^=c.charCodeAt(h)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new r(a),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&i(h,c),d.state=function(){return i(c,{})}),d}t&&t.exports?t.exports=o:this.tychei=o})(yj,n)}(eg)),eg.exports}var tg={exports:{}};const Sj={},wj=Object.freeze(Object.defineProperty({__proto__:null,default:Sj},Symbol.toStringTag,{value:"Module"})),_j=SP(wj);var Cj=tg.exports,h2;function Ej(){return h2||(h2=1,function(n){(function(e,t,s){var r=256,i=6,o=52,a="random",l=s.pow(r,i),c=s.pow(2,o),h=c*2,d=r-1,p;function m(_,A,k){var N=[];A=A==!0?{entropy:!0}:A||{};var D=v(y(A.entropy?[_,C(t)]:_??S(),3),N),M=new g(N),T=function(){for(var I=M.g(i),$=l,O=0;I<c;)I=(I+O)*r,$*=r,O=M.g(1);for(;I>=h;)I/=2,$/=2,O>>>=1;return(I+O)/$};return T.int32=function(){return M.g(4)|0},T.quick=function(){return M.g(4)/4294967296},T.double=T,v(C(M.S),t),(A.pass||k||function(I,$,O,B){return B&&(B.S&&b(B,M),I.state=function(){return b(M,{})}),O?(s[a]=I,$):I})(T,D,"global"in A?A.global:this==s,A.state)}function g(_){var A,k=_.length,N=this,D=0,M=N.i=N.j=0,T=N.S=[];for(k||(_=[k++]);D<r;)T[D]=D++;for(D=0;D<r;D++)T[D]=T[M=d&M+_[D%k]+(A=T[D])],T[M]=A;(N.g=function(I){for(var $,O=0,B=N.i,V=N.j,H=N.S;I--;)$=H[B=d&B+1],O=O*r+H[d&(H[B]=H[V=d&V+$])+(H[V]=$)];return N.i=B,N.j=V,O})(r)}function b(_,A){return A.i=_.i,A.j=_.j,A.S=_.S.slice(),A}function y(_,A){var k=[],N=typeof _,D;if(A&&N=="object")for(D in _)try{k.push(y(_[D],A-1))}catch{}return k.length?k:N=="string"?_:_+"\0"}function v(_,A){for(var k=_+"",N,D=0;D<k.length;)A[d&D]=d&(N^=A[d&D]*19)+k.charCodeAt(D++);return C(A)}function S(){try{var _;return p&&(_=p.randomBytes)?_=_(r):(_=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(_)),C(_)}catch{var A=e.navigator,k=A&&A.plugins;return[+new Date,e,k,e.screen,C(t)]}}function C(_){return String.fromCharCode.apply(0,_)}if(v(s.random(),t),n.exports){n.exports=m;try{p=_j}catch{}}else s["seed"+a]=m})(typeof self<"u"?self:Cj,[],Math)}(tg)),tg.exports}var jy,d2;function Tj(){if(d2)return jy;d2=1;var n=uj(),e=dj(),t=pj(),s=gj(),r=vj(),i=bj(),o=Ej();return o.alea=n,o.xor128=e,o.xorwow=t,o.xorshift7=s,o.xor4096=r,o.tychei=i,jy=o,jy}var Iw=Tj();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sk{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Iw.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Ij{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Iw.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aj(n,e=0,t=1,s,r){if(Ko(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new Sk(e,t,s,!1,r),o=jt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Mj=me({randomNormal_:Aj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rj(n,e=0,t=1,s="float32",r){Ko(n);const i=jt(n,s),o=new Ij(e,t,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Cf=me({randomUniform_:Rj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fd(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return ae.runKernel(QS,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(n){const t={input:ee(n,"input","real")};return ae.runKernel(JS,t)}const xg=me({real_:kj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(n){const t={x:ee(n,"x","reciprocal")};return ae.runKernel(sf,t)}const Dj=me({reciprocal_:Nj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $j(n){const t={x:ee(n,"x","relu")};return ae.runKernel(rf,t)}const cc=me({relu_:$j});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fj(n){const t={x:ee(n,"x","relu6")};return ae.runKernel(of,t)}const wk=me({relu6_:Fj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lj(n,e){const s={x:ee(n,"x","reverse")},r={dims:e};return ae.runKernel(U0,s,r)}const Jl=me({reverse_:Lj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(n){const t={x:ee(n,"x","round")};return ae.runKernel(af,t)}const _k=me({round_:Pj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oj(n){const t={x:ee(n,"x","rsqrt","float32")};return ae.runKernel(lf,t)}const Ck=me({rsqrt_:Oj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uj(n){const t={x:ee(n,"x","selu")};return ae.runKernel(cf,t)}const Ek=me({selu_:Uj});function zj(n,e,t,s,r,i=[1,1],o="NHWC"){const a=ee(n,"x","separableConv2d"),l=ee(e,"depthwiseFilter","separableConv2d"),c=ee(t,"pointwiseFilter","separableConv2d");let h=a,d=!1;if(a.rank===3&&(d=!0,h=fe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");W(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),W(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),W(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),W(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),W(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],m=l.shape[3];W(c.shape[2]===p*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*m}, but got ${c.shape[2]}.`);const g=gw(h,l,s,r,o,i),y=Zl(g,c,1,"valid",o);return d?fe(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const Tk=me({separableConv2d_:zj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(n){const t={x:ee(n,"x","sign")};return ae.runKernel(df,t)}const Vj=me({sign_:Bj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gj(n){const t={x:ee(n,"x","sin","float32")};return ae.runKernel(uf,t)}const Ik=me({sin_:Gj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wj(n){const t={x:ee(n,"x","sinh")};return ae.runKernel(hf,t)}const Ak=me({sinh_:Wj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hj(n,e,t){const s=ee(n,"x","slice1d");return W(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),In(s,[e],[t])}const Aw=me({slice1d_:Hj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xj(n,e,t){const s=ee(n,"x","slice2d");return W(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),In(s,e,t)}const Mk=me({slice2d_:Xj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jj(n,e,t){const s=ee(n,"x","slice3d");return W(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),In(s,e,t)}const Mw=me({slice3d_:jj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(n,e,t){const s=ee(n,"x","slice4d");return W(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),In(s,e,t)}const vg=me({slice4d_:qj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kj(n,e=-1){const t=ee(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return ae.runKernel(H0,s,r)}const Rw=me({softmax_:Kj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yj(n){W(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ae.runKernel(BS,e)}const Rk=me({fft_:Yj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zj(n){W(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ae.runKernel(WS,e)}const vb=me({ifft_:Zj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qj(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=fe(n,[t,e]);s=vb(r)}else{const r=[t,2*(e-1)],i=fe(xg(n),[t,e]),o=fe(yw(n),[t,e]),a=Jl(In(i,[0,1],[t,e-2]),1),l=oe(Jl(In(o,[0,1],[t,e-2]),1),en(-1)),c=xr([i,a],1),h=xr([o,l],1),d=fe(_u(c,h),[r[0],r[1]]);s=vb(d)}if(s=xg(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=fe(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const Jj=me({irfft_:Qj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(n,e,t=0){const r={x:ee(n,"x","split")},i={numOrSizeSplits:e,axis:t};return ae.runKernel(W0,r,i)}const jr=me({split_:e7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t7(n,e){W(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const g=n.shape.map(y=>0),b=n.shape.map(y=>y);b[n.shape.length-1]=e,r=In(n,g,b),t=e}else if(e!=null&&e>t){const g=n.shape.map(b=>b);g[n.shape.length-1]=e-t,r=xr([n,ls(g)],n.shape.length-1),t=e}else r=n;const i=rn(r),o=fe(_u(r,i),[s,t]),a=Rk(o),l=Math.floor(t/2)+1,c=xg(a),h=yw(a),d=jr(c,[l,t-l],c.shape.length-1),p=jr(h,[l,t-l],h.shape.length-1),m=r.shape.slice();return m[r.shape.length-1]=l,fe(_u(d[0],p[0]),m)}const n7=me({rfft_:t7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s7(n,e){let t=ee(n,"a","squaredDifference"),s=ee(e,"b","squaredDifference");[t,s]=Kn(t,s),Ut(t.shape,s.shape);const r={a:t,b:s},i={};return ae.runKernel(gf,r,i)}const r7=me({squaredDifference_:s7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(n,e){const t=ee(n,"x","squeeze","string_or_numeric");return fe(t,qa(t.shape,e).newShape)}const Ef=me({squeeze_:i7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o7(n,e=0){const t=qR(n,"tensors","stack","string_or_numeric");W(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&W(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return ae.runKernel(N0,s,r)}const Xo=me({stack_:o7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a7(n,e=0){const s={x:ee(n,"x","step")},r={alpha:e};return ae.runKernel(Sf,s,r)}const Tf=me({step_:a7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n,e,t,s,r=0,i=0,o=0,a=0,l=0){const h={x:ee(n,"x","stridedSlice","string_or_numeric")},d={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ae.runKernel(rw,h,d)}const c7=me({stridedSlice_:l7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u7(n){const t={x:ee(n,"x","tan","float32")};return ae.runKernel(vf,t)}const h7=me({tan_:u7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(n,e){qg(n);const t=Uu(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return zu(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qy(n,e,t){if(qg(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Uu(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return zu(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2(n,e,t){if(qg(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Uu(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return zu(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7(n,e,t){if(qg(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Uu(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return zu(n,e,s,t)}function kk(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function f7(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}kk(t,e,n)}function uc(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let o=1;for(let d=r;d<i;++d)o*=t[d];const a=r<1?1:r,l=Ne(e.shape)/a,c=[...Ct(t.slice(0,r)),1],h=Ne(t);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:c,outputSize:h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p7(n,e=1,t=!0){const s=ee(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:t},[a,l]=ae.runKernel(iw,i,o);return{values:a,indices:l}}const m7=me({topk_:p7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g7(n,e=0,t=1,s,r){if(Ko(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new Sk(e,t,s,!0,r),o=jt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Nk=me({truncatedNormal_:g7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x7(n,e=0){const t=ee(n,"x","unique","string_or_numeric");W(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,o]=ae.runKernel(aw,s,r);return{values:i,indices:o}}const v7=me({unique_:x7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y7(n,e,t){const s=ee(n,"x","unsortedSegmentSum"),r=ee(e,"segmentIds","unsortedSegmentSum","int32");W(Su(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:t};return ae.runKernel(j0,i,o)}const Dk=me({unsortedSegmentSum_:y7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(n,e=0){const t=ee(n,"x","unstack","string_or_numeric");W(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return ae.runKernel(X0,s,r)}const ec=me({unstack_:b7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(n,e=!0,t,s){return ae.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=jt(n,"int32"),r=jt([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=s.indexToLoc(t[i]),a=i*n.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w7(n,e,t){const s=ee(n,"x","transpose");if(e==null&&(e=s.shape.map((o,a)=>a).reverse()),W(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{W(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?be(()=>{let o=xg(s),a=yw(s);return o=ae.runKernel(du,{x:o},i),a=ae.runKernel(du,{x:a},i),t&&(a=qn(a)),_u(o,a)}):ae.runKernel(du,r,i)}const sn=me({transpose_:w7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(n,e){if(e==null)return n.shape.slice();if(mn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C7(n,e,t,s){const r=ee(n,"x","dropout");if(W(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),W(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof as?r.clone():r;const i=_7(r,t),o=1-e,a=At(tx(je(Cf(i,0,1,"float32",s),o)),o);return oe(r,a)}const E7=me({dropout_:C7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7(n,e,t,s,r,i="NHWC",o){let a=n;n.rank===3&&(a=fe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),W(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),W(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),W(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],h=i==="NHWC"?l.shape[3]:l.shape[1];W(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),W(h===t[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${t[3]}).`),wr("conv2dDerFilter",r,o);const d={x:a,dy:l},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:t};return ae.runKernel(RS,d,p)}const kw=me({conv2DBackpropFilter_:T7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return oe(n,Tf(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Dw(n,e){let t=e;const s=fs(n.shape,e.shape);return s.length>0&&(t=It(t,s)),fe(t,n.shape)}function $w(n,e,t,s){if(e==="linear")return n;if(e==="relu")return cc(n);if(e==="elu")return J0(n);if(e==="relu6")return wk(n);if(e==="prelu")return Tw(n,t);if(e==="leakyrelu")return bw(n,s);if(e==="sigmoid")return Vu(n);throw new Error(`Unknown fused activation ${e}.`)}const Fw=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",Fw(ae.state.gradientDepth,l)===!1){W(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=Zl(n,e,t,s,r,i,o);return a!=null&&(k=je(k,a)),$w(k,l,c,h)}const d=ee(n,"x","conv2d","float32"),p=ee(e,"filter","conv2d","float32");let m=d,g=!1;d.rank===3&&(g=!0,m=fe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),W(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),W(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),wr("fused conv2d",s,o);const b=r==="NHWC"?m.shape[3]:m.shape[1];W(p.shape[2]===b,()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${p.shape[2]}.`),W(Vs(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const y=Ns(m.shape,p.shape,t,i,s,o);let v;a!=null&&(v=ee(a,"bias","fused conv2d"),[v]=Kn(v,d),r==="NHWC"?Ut(y.outShape,v.shape):(W(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),W(v.shape.length===0||v.shape[0]===y.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let S;if(c!=null){const k=c.shape;if(W(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)W(k[0]===1||k[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${y.outChannels}).`);else if(k.length===3)try{Ut(k,y.outShape)}catch{const D=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(D)}S=ee(c,"prelu weights","fused conv2d")}const C=(k,N)=>{W(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[D,M,T,I]=N,$=Nw(k,T,l);W(Kl(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const O=pw(M.shape,$,D,t,s),B=kw(M,$,D.shape,t,s),V=[O,B];if(I!=null){const H=Dw(I,$);V.push(H)}return V},_={x:m,filter:p,bias:v,preluActivationWeights:S},A={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return a==null?Eu((N,D,M)=>{let T=ae.runKernel(hg,_,A);return M([D,N,T]),g&&(T=fe(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:C}})(m,p):Eu((N,D,M,T)=>{let I=ae.runKernel(hg,_,A);return T([D,N,I,M]),g&&(I=fe(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:C}})(m,p,v)}const A7=me({fusedConv2d_:I7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M7(n,e,t,s,r,i=[1,1],o){let a=n;n.rank===3&&(a=fe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:t};return ae.runKernel(PS,c,h)}const R7=me({depthwiseConv2dNativeBackpropFilter_:M7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k7(n,e,t,s,r,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},d=ae.runKernel(OS,c,h);return l?fe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const N7=me({depthwiseConv2dNativeBackpropInput_:k7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(Fw(ae.state.gradientDepth,i)===!1){let I=pn(n,e,t,s);return r!=null&&(I=je(I,r)),$w(I,i,o,a)}let l=ee(n,"a","fused matMul"),c=ee(e,"b","fused matMul");[l,c]=Kn(l,c);const h=t?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=t?l.shape[l.rank-1]:l.shape[l.rank-2],m=s?c.shape[c.rank-2]:c.shape[c.rank-1],g=l.shape.slice(0,-2),b=c.shape.slice(0,-2),y=Ne(g),v=Ne(b);W(h===d,()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const C=Ut(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,m]),_=t?fe(l,[y,h,p]):fe(l,[y,p,h]),A=s?fe(c,[v,m,d]):fe(c,[v,d,m]);let k;r!=null&&(k=ee(r,"bias","fused matMul"),[k]=Kn(k,l),Ut(C,k.shape));let N;o!=null&&(N=ee(o,"prelu weights","fused matMul"));const D=(I,$)=>{const[O,B,V,H]=$,q=Nw(fe(I,V.shape),V,i);let P,K;if(!t&&!s?(P=pn(q,B,!1,!0),K=pn(O,q,!0,!1)):!t&&s?(P=pn(q,B,!1,!1),K=pn(q,O,!0,!1)):t&&!s?(P=pn(B,q,!1,!0),K=pn(O,q,!1,!1)):(P=pn(B,q,!0,!0),K=pn(q,O,!0,!0)),r!=null){const Z=Dw(H,q);return[P,K,Z]}else return[P,K]},M={a:_,b:A,bias:k,preluActivationWeights:N},T={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?Eu(($,O,B)=>{const V=ae.runKernel(ug,M,T);return B([$,O,V]),{value:fe(V,C),gradFunc:D}})(_,A):Eu(($,O,B,V)=>{const H=ae.runKernel(ug,M,T);return V([$,O,H,B]),{value:fe(H,C),gradFunc:D}})(_,A,k)}const p2=me({fusedMatMul_:D7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(n,e,t,s,r="bilinear",i=0){const o=ee(n,"image","cropAndResize"),a=ee(e,"boxes","cropAndResize","float32"),l=ee(t,"boxInd","cropAndResize","int32"),c=a.shape[0];W(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),W(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),W(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),W(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),W(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),W(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const h={image:o,boxes:a,boxInd:l},d={method:r,extrapolationValue:i,cropSize:s};return ae.runKernel($S,h,d)}const F7=me({cropAndResize_:$7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(n){const e=ee(n,"image","flipLeftRight","float32");W(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ae.runKernel(GS,t,{})}const P7=me({flipLeftRight_:L7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O7(n){const e=ee(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];W(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),W(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Di(e,r)}const U7=me({grayscaleToRGB_:O7});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z7(n){const e=ee(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];W(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),W(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=at(e,"float32"),o=Dr([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Gh("ij,j->i",i,o);break;case 3:a=Gh("ijk,k->ij",i,o);break;case 4:a=Gh("ijkl,l->ijk",i,o);break;case 5:a=Gh("ijklm,m->ijkl",i,o);break;case 6:a=Gh("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=fr(a,-1),at(a,r)}const B7=me({rgbToGrayscale_:z7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V7(n,e,t=0,s=.5){const r=ee(n,"image","rotateWithOffset","float32");W(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:e,fillValue:t,center:s};return ae.runKernel(lw,i,o)}const G7=me({rotateWithOffset_:V7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wu(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),W(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),W(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),W(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),W(e.rank===1,()=>"scores must be a 1D tensor"),W(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),W(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=ee(n,"boxes","nonMaxSuppression","float32"),o=ee(e,"scores","nonMaxSuppression","float32"),a=Wu(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return ae.runKernel(KS,{boxes:i,scores:o},l)}const H7=me({nonMaxSuppression_:W7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X7(n,e,t){const s=j7(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function j7(n,e,t){return K7(n,e,t||q7)}function q7(n,e){return n>e?1:n<e?-1:0}function K7(n,e,t){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=t(e,n[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lw(n,e,t,s,r){return Uw(n,e,t,s,r,0)}function Pw(n,e,t,s,r,i){return Uw(n,e,t,s,r,0,!1,i,!0)}function Ow(n,e,t,s,r,i){return Uw(n,e,t,s,r,i,!0)}function Uw(n,e,t,s,r,i,o=!1,a=!1,l=!1){const c=[];for(let y=0;y<e.length;y++)e[y]>r&&c.push({score:e[y],boxIndex:y,suppressBeginIndex:0});c.sort(m2);const h=i>0?-.5/i:0,d=[],p=[];for(;d.length<t&&c.length>0;){const y=c.pop(),{score:v,boxIndex:S,suppressBeginIndex:C}=y;if(v<r)break;let _=!1;for(let A=d.length-1;A>=C;--A){const k=Y7(n,S,d[A]);if(k>=s){_=!0;break}if(y.score=y.score*Z7(s,h,k),y.score<=r)break}y.suppressBeginIndex=d.length,_||(y.score===v?(d.push(S),p.push(y.score)):y.score>r&&X7(c,y,m2))}const m=d.length,g=t-m;a&&g>0&&(d.push(...new Array(g).fill(0)),p.push(...new Array(g).fill(0)));const b={selectedIndices:d};return o&&(b.selectedScores=p),l&&(b.validOutputs=m),b}function Y7(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),h=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),m=(a-i)*(l-o),g=(d-c)*(p-h);if(m<=0||g<=0)return 0;const b=Math.max(i,c),y=Math.max(o,h),v=Math.min(a,d),S=Math.min(l,p),C=Math.max(v-b,0)*Math.max(S-y,0);return C/(m+g-C)}function Z7(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function m2(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Q7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=ee(n,"boxes","nonMaxSuppressionAsync"),o=ee(e,"scores","nonMaxSuppressionAsync"),a=Wu(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:d}=Lw(c,h,t,s,r);return i!==n&&i.dispose(),o!==e&&o.dispose(),Dr(d,"int32")}const J7=Q7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=ee(n,"boxes","nonMaxSuppression"),a=ee(e,"scores","nonMaxSuppression"),l=Wu(o,a,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},h={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},d=ae.runKernel(ZS,c,h);return{selectedIndices:d[0],selectedScores:d[1]}}const t9=me({nonMaxSuppressionWithScore_:e9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function n9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=ee(n,"boxes","nonMaxSuppressionAsync"),a=ee(e,"scores","nonMaxSuppressionAsync"),l=Wu(o,a,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),h=c[0],d=c[1],{selectedIndices:p,selectedScores:m}=Ow(h,d,t,s,r,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Dr(p,"int32"),selectedScores:Dr(m)}}const s9=n9;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=ee(n,"boxes","nonMaxSuppression"),a=ee(e,"scores","nonMaxSuppression"),l=Wu(o,a,t,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,p={boxes:o,scores:a},m={maxOutputSize:c,iouThreshold:h,scoreThreshold:d,padToMaxOutputSize:i},g=ae.runKernel(YS,p,m);return{selectedIndices:g[0],validOutputs:g[1]}}const i9=me({nonMaxSuppressionPadded_:r9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function o9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=ee(n,"boxes","nonMaxSuppressionAsync"),a=ee(e,"scores","nonMaxSuppressionAsync"),l=Wu(o,a,t,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,[p,m]=await Promise.all([o.data(),a.data()]),{selectedIndices:g,validOutputs:b}=Pw(p,m,c,h,d,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Dr(g,"int32"),validOutputs:en(b,"int32")}}const a9=o9;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l9(n,e,t=!1,s=!1){const r=ee(n,"images","resizeBilinear");W(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),W(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),W(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=fe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},c=ae.runKernel(O0,a,l);return o?fe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Fk=me({resizeBilinear_:l9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9(n,e,t=!1,s=!1){const r=ee(n,"images","resizeNearestNeighbor");W(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),W(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),W(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),W(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=fe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},c=ae.runKernel(P0,a,l);return o?fe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Lk=me({resizeNearestNeighbor_:c9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9(n,e="binary",t=!1,s=.5){const r=ee(n,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=oe(Dr([s]),255),h,d,p,m;if(W(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),W(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),W(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),W(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[h,d,p]=jr(r,[1,1,1],-1);const y=oe(h,i),v=oe(d,o),S=oe(p,a);m=je(je(y,v),S)}else m=n;if(e==="otsu"){const y=a8(at(_k(m),"int32"),KR([]),256);c=h9(y,l)}const g=t?Gu(m,c):Kr(m,c);return at(oe(g,255),"int32")}function h9(n,e){let t=Dr([-1]),s=Dr([0]),r=Dr([0]),i,o,a,l,c,h;for(let d=0;d<n.size-1;d++){i=In(n,0,d+1),o=In(n,d+1),c=At(It(i),e),h=At(It(o),e);const p=It(oe(i,fd(0,i.size)));a=At(p,It(i));const m=Q0(o.shape,i.size),g=je(fd(0,o.size),m),b=oe(o,g);l=At(It(b),It(o));const y=Nt(a,l),v=Nt(a,l),S=oe(c,h);r=oe(oe(S,y),v);const C=Kr(r,s);s=ir(C,r,s),t=ir(C,Dr([d]),t)}return t}const d9=me({threshold_:u9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f9(n,e,t="nearest",s="constant",r=0,i){const o=ee(n,"image","transform","float32"),a=ee(e,"transforms","transform","float32");W(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),W(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),W(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return ae.runKernel(ow,l,c)}const p9=me({transform_:f9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m9(n,e,t){const s=ee(n,"a","bandPart");W(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let a,l;typeof e=="number"?(W(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),W(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=ee(e<0?i:e,"numLower","bandPart")):(W(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=ir(mg(e,0),i,dd(e,i))),typeof t=="number"?(W(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),W(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=ee(t<0?o:t,"numUpper","bandPart")):(W(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=ir(mg(t,0),o,dd(t,o)));const c=fe(fd(0,i,1,"int32"),[-1,1]),h=fd(0,o,1,"int32"),d=Nt(c,h),p=Ho(Gu(d,a),lc(d,qn(l))),m=ls([i,o],s.dtype);return fe(Xo(ec(fe(s,[-1,i,o])).map(g=>ir(p,g,m))),r)}const g9=me({bandPart_:m9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x9(n){let e;if(Array.isArray(n)){e=!1,W(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)W(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=jr(n,n.shape[0],0).map(r=>Ef(r,[0]));W(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(ae.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=oe(It(oe(t[o],i)),t[o]);i=Nt(i,a)}return At(i,ex(i,"euclidean"))}));return e?Xo(t,0):t}const v9=me({gramSchmidt_:x9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y9(n,e=!1){if(W(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return g2(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=ec(fe(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[c,h]=g2(l,e);r.push(c),i.push(h)});const o=fe(Xo(r,0),n.shape),a=fe(Xo(i,0),n.shape);return[o,a]}}function g2(n,e=!1){return ae.tidy(()=>{W(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=mk(t),i=zl(n);const o=qy([[1]],[1,1]);let a=zl(o);const l=t>=s?s:t;for(let c=0;c<l;++c){const h=i,d=a,p=r;[a,i,r]=ae.tidy(()=>{const m=In(i,[c,c],[t-c,1]),g=ex(m),b=In(i,[c,c],[1,1]),y=ir(Kr(b,0),qy([[-1]]),qy([[1]])),v=Nt(b,oe(y,g)),S=At(m,v);S.shape[0]===1?a=zl(o):a=xr([o,In(S,[1,0],[S.shape[0]-1,S.shape[1]])],0);const C=qn(At(pn(y,v),g)),_=In(i,[c,0],[t-c,s]),A=oe(C,a),k=sn(a);if(c===0)i=Nt(_,pn(A,pn(k,_)));else{const M=Nt(_,pn(A,pn(k,_)));i=xr([In(i,[0,0],[c,s]),M],0)}const N=sn(A),D=In(r,[0,c],[t,r.shape[1]-c]);if(c===0)r=Nt(D,pn(pn(D,a),N));else{const M=Nt(D,pn(pn(D,a),N));r=xr([In(r,[0,0],[t,c]),M],1)}return[a,i,r]}),Yt([h,d,p])}return!e&&t>s&&(r=In(r,[0,0],[t,s]),i=In(i,[0,0],[s,s])),[r,i]})}const b9=me({qr_:y9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bo={flipLeftRight:P7,grayscaleToRGB:U7,resizeNearestNeighbor:Lk,resizeBilinear:Fk,rgbToGrayscale:B7,rotateWithOffset:G7,cropAndResize:F7,nonMaxSuppression:H7,nonMaxSuppressionAsync:J7,nonMaxSuppressionWithScore:t9,nonMaxSuppressionWithScoreAsync:s9,nonMaxSuppressionPadded:i9,nonMaxSuppressionPaddedAsync:a9,threshold:d9,transform:p9},S9={bandPart:g9,gramSchmidt:v9,qr:b9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w9=new Map,_9=new Map;class Hu{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class ui{constructor(){this.classNameMap={}}static getMap(){return ui.instance==null&&(ui.instance=new ui),ui.instance}static register(e){ui.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Ue(n,e,t){W(n.className!=null,()=>"Class being registered does not have the static className property defined."),W(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),W(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return ui.register(n),w9.set(r,n),_9.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class el extends Hu{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return Yt(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return IX(e,t)}dispose(){this.iterations_!=null&&Yt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:en(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(el,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pk extends el{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ae.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ae.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:be(()=>rn(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:be(()=>rn(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;be(()=>{const h=je(oe(l,this.rho),oe(kn(a),1-this.rho)),d=oe(At(Bs(je(c,this.epsilon)),Bs(je(l,this.epsilon))),a),p=je(oe(c,this.rho),oe(kn(d),1-this.rho));l.assign(h),c.assign(p);const m=je(oe(d,-this.learningRate),i);i.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Yt(this.accumulatedGrads.map(e=>e.variable)),Yt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ok extends el{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ae.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:be(()=>Q0(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=this.accumulatedGrads[r].variable;be(()=>{const l=je(a,kn(o));a.assign(l);const c=je(oe(At(o,Bs(je(l,ae.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Yt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uk extends el{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],be(()=>{this.accBeta1=en(t).variable(),this.accBeta2=en(s).variable()}),r==null&&(this.epsilon=ae.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);be(()=>{const s=Nt(1,this.accBeta1),r=Nt(1,this.accBeta2);t.forEach((i,o)=>{const a=ae.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:be(()=>rn(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:be(()=>rn(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const h=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,p=je(oe(h,this.beta1),oe(c,1-this.beta1)),m=je(oe(d,this.beta2),oe(kn(c),1-this.beta2)),g=At(p,s),b=At(m,r);h.assign(p),d.assign(m);const y=je(oe(At(g,je(Bs(b),this.epsilon)),-this.learningRate),a);a.assign(y)}),this.accBeta1.assign(oe(this.accBeta1,this.beta1)),this.accBeta2.assign(oe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Yt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Yt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),be(()=>{this.accBeta1.assign(Ql(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ql(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zk extends el{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],be(()=>{this.iteration=en(0).variable(),this.accBeta1=en(t).variable()}),r==null&&(this.epsilon=ae.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);be(()=>{const s=Nt(1,this.accBeta1),r=At(-this.learningRate,je(oe(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=ae.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:rn(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:rn(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const h=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,p=je(oe(h,this.beta1),oe(c,1-this.beta1)),m=oe(d,this.beta2),g=er(c),b=Qa(m,g);h.assign(p),d.assign(b);const y=je(oe(At(r,s),At(p,je(b,this.epsilon))),a);a.assign(y)}),this.iteration.assign(je(this.iteration,1)),this.accBeta1.assign(oe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Yt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Yt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zw extends el{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=ae.registeredVariables[s];be(()=>{const a=je(oe(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=co(en(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bk extends zw{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=en(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ae.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:be(()=>rn(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&be(()=>{let l;const c=je(oe(this.m,o),a);this.useNesterov?l=je(oe(this.c,je(a,oe(c,this.m))),i):l=je(oe(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Yt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vk extends el{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=ae.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=ae.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:be(()=>rn(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:be(()=>rn(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:be(()=>rn(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;be(()=>{const h=je(oe(l,this.decay),oe(kn(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,p=je(oe(d,this.decay),oe(a,1-this.decay)),m=At(oe(a,this.learningRate),Bs(Nt(h,je(kn(p),this.epsilon)))),g=je(oe(c,this.momentum),m);l.assign(h),d.assign(p),c.assign(g);const b=Nt(i,g);i.assign(b)}else{const d=je(oe(l,this.decay),oe(kn(a),1-this.decay)),p=je(oe(c,this.momentum),At(oe(a,this.learningRate),Bs(je(d,this.epsilon))));l.assign(d),c.assign(p);const m=Nt(i,p);i.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Yt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Yt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Yt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C9=[Pk,Ok,Uk,zk,Bk,Vk,zw];function E9(){for(const n of C9)Ue(n)}function Bw(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(Ne(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let d=0;d<r.length-1;++d)o*=r[d];const a=n.shape,l=r.slice();l.pop();let c=1;for(let d=i;d<t;++d)c*=a[d],l.push(a[d]);const h=[...Ct(n.shape).map(d=>d/c),1].slice(0,i);return[l,o,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yb=-2,T9=-1;function Vw(n,e,t){const s=n.shape.length;W(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),W(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)W(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function I9(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Gw(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function Gk(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Wk(n,e,t){return t<=n?t:t-(e-1)}function Hk(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function A9(n,e,t,s,r,i,o,a,l){const c=n.length;let h=new Array(c),d=new Array(c),p=new Array(c);if(e.length&&t>0){const m=e[0],g=t+1;h=Xk(o,m,g,s,n),d=jk(a,m,g,r,n),p=Gk(i,m,g,n)}else for(let m=0;m<c;m++)h[m]=Kk(o,s,i,n,m,l),d[m]=Yk(a,r,i,n,m,l),p[m]=qk(i,m,l);return{begin:h,end:d,strides:p}}function Xk(n,e,t,s,r){const i=[...r],o=Hk(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=Wk(e,t,a);let c=s[l];n&1<<l&&(c=0),i[a]=c}return i}function jk(n,e,t,s,r){const i=[...r],o=Hk(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=Wk(e,t,a);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=r[a];i[a]<0&&(i[a]+=l),i[a]=Hl(0,i[a],r[a])}return i}function qk(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function Kk(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=Hl(0,o,l-1),o}function Yk(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),a>0?o=Hl(0,o,l):o=Hl(-1,o,l-1),o}function Ww(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function Hw(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function nx(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{W(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(W(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,i]}function Xw(n,e,t,s,r,i,o,a,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let C=0;C<d.dims;C++)h&&(1<<C&a)!==0&&d.numAddAxisAfterEllipsis++,1<<C&o&&(h=!0);h||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};M9(d,p);let m=!0,g=!0,b=!0;const y=[],v=[];for(let C=0;C<n.length;++C){if(p.strides[C]===0)throw Error(`strides[${C}] must be non-zero`);const _=!!(p.shrinkAxisMask&1<<C),A=n[C];if(A===-1){y.push(_?1:-1);continue}const k=[p.beginMask&1<<C,p.endMask&1<<C],N=[p.strides[C]>0?0:-1,p.strides[C]>0?A:A-1];if(_&&p.strides[C]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&p.strides[C]===1;const D=!!(p.beginMask&1<<C&&p.endMask&1<<C);if(p.beginValid&&p.endValid){if(_){const $=p.begin[C]<0?A+p.begin[C]:p.begin[C];if(p.begin[C]=$,p.end[C]=p.begin[C]+1,$<0||$>=A)throw Error(`slice index ${p.begin[C]} of dimension ${C} out of bounds.`)}else p.begin[C]=x2(p.begin[C],0,p.strides[C],A,k,N),p.end[C]=x2(p.end[C],1,p.strides[C],A,k,N);const I=p.strides[C]===1&&p.begin[C]===0&&p.end[C]===A;m=m&&I,g=g&&(C===0&&p.strides[C]===1||I)}else m=m&&p.strides[C]===1&&D,g=g&&(C===0&&p.strides[C]===1||D);let M,T=!1;if(p.beginValid&&p.endValid?(M=p.end[C]-p.begin[C],T=!0):_?(M=1,T=!0):D&&A>=0&&(p.strides[C]<0?M=-A:M=A,T=!0),T){let I;M===0||M<0!=p.strides[C]<0?I=0:I=Math.trunc(M/p.strides[C])+(M%p.strides[C]!==0?1:0),y.push(I)}else y.push(-1)}for(let C=0;C<p.finalShapeGatherIndices.length;++C){const _=p.finalShapeGatherIndices[C];_>=0?v.push(y[_]):_===yb&&v.push(1)}return{finalShapeSparse:v.filter((C,_)=>p.finalShapeGatherIndices[_]!==yb),finalShape:v,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:p.begin,end:p.end,strides:p.strides}}function M9(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(yb),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(T9),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function x2(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const R9=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Vw,computeFlatOffset:Hw,computeOutShape:Gw,getNormalizedAxes:A9,isSliceContinous:Ww,maskToAxes:I9,parseSliceParams:nx,sliceInfo:Xw,startForAxis:Kk,startIndicesWithElidedDims:Xk,stopForAxis:Yk,stopIndicesWithElidedDims:jk,stridesForAxis:qk,stridesWithElidedDims:Gk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k9{static sgd(e){return new zw(e)}static momentum(e,t,s=!1){return new Bk(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new Vk(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new Uk(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new Pk(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new zk(e,t,s,r,i)}static adagrad(e,t=.1){return new Ok(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nu=k9;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N9=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function Zk(){return new Promise(n=>N9(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n,e){const t=n[0].length;n.forEach((r,i)=>{W(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),W(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<t;o++)W(o===e||r[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function uo(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ki;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(ki||(ki={}));function Qk(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],o=s[s.length-t.length+r],a=s[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${a}`)}else s[o]=i}return s}function Jk(n){const e={FIRST_DIM_SIZE:ki.FIRST_DIM_SIZE,VALUE_ROWIDS:ki.VALUE_ROWIDS,ROW_LENGTHS:ki.ROW_LENGTHS,ROW_SPLITS:ki.ROW_SPLITS,ROW_LIMITS:ki.ROW_LIMITS,ROW_STARTS:ki.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function eN(n){return n.length===0?0:n[0]===ki.FIRST_DIM_SIZE?n.length-1:n.length}function tN(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],o=e[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qw=30;function sx(n){return n<=qw?n:nb(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kw(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function If(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(i+1))}return r}function Af(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function Mf(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function Yw(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Zw(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rx=1.7580993408473768,ix=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qw=.3275911,Jw=.254829592,e_=-.284496736,t_=1.421413741,n_=-1.453152027,s_=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jo(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function nN(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function sN(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function rN(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function r_(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function iN(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function oN(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function aN(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ky="->",D9=/->/g,v2=",",y2="...";function i_(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(D9,"").length)/Ky.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Ky}").`);const[s,r]=n.split(Ky);W(s.indexOf(y2)===-1,()=>`The ellipsis notation ("${y2}") is not supported yet.`);const i=s.split(v2),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let p=0;p<r.length;++p){const m=r[p];if(!i.some(g=>g.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);a.indexOf(m)===-1&&a.push(m)}for(let p=0;p<s.length;++p){const m=s[p];a.indexOf(m)===-1&&m!==v2&&a.push(m)}const l=new Array(i.length);for(let p=0;p<o;++p){if(new Set(i[p].split("")).size!==i[p].length)throw new Error(`Found duplicate axes in input component ${i[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let m=0;m<i[p].length;++m)l[p].push(a.indexOf(i[p][m]))}const c=a.length,h=r.length,d=[];for(let p=h;p<c;++p)d.push(p);return{allDims:a,summedDims:d,idDims:l}}function o_(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function a_(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=i[o]:W(s[e[r][o]]===i[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function l_(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],l=$9(e,a);for(const c of l)i.indexOf(c)===-1&&(s[o].push(c),i.push(c))}return{path:t,steps:s}}function c_(n){return n.every((e,t)=>e===t)}function $9(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function u_(n,e,t=0){let s=[];if(typeof e=="number")W(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);W(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=n.shape[t]-o}W(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lN(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function cN(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function uN(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function dN(n,e){return`size ${n} must be non-negative, not ${e}`}function fN(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function pN(n,e){const t=Ne(n),s=Ne(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function mN(n,e){const t=Ne(n),s=Ne(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bb(){return"segment ids must be >= 0"}function gN(){return"segment ids are not increasing"}function xN(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function vN(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(n,e){let t=!1,s;for(n<=qw?(s=n,t=!0):s=nb(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=nb(n,s+1);return s}function bN(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function h_(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let d=0;d<s;++d)if(n.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const o=n.shape[t],a=[];let l=1,c=1,h=1;for(let d=0;d<s;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<t;d++)a.push(n.shape[d]),c*=n.shape[d];for(let d=s;d<r;d++)a.push(e.shape[d]);for(let d=t+1;d<i;d++)a.push(n.shape[d]),h*=n.shape[d];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:o,outputShape:a}}const F9=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:h_,computeOutShape:bN,segOpComputeOptimalWindowSize:yN},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qo(n){try{return n.map(e=>Ba(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function SN(n){return n.map(e=>La(e))}const L9=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Jw,ERF_A2:e_,ERF_A3:t_,ERF_A4:n_,ERF_A5:s_,ERF_P:Qw,PARALLELIZE_THRESHOLD:qw,get RowPartitionType(){return ki},SELU_SCALE:ix,SELU_SCALEALPHA:rx,applyActivation:$w,assertAndGetBroadcastShape:Ut,assertAxesAreInnerMostDims:Ds,assertParamsConsistent:jw,assignToTypedArray:iN,axesAreInnerMostDims:xw,calculateShapes:uc,checkEinsumDimSizes:a_,checkPadOnDimRoundingMode:wr,combineLocations:fk,combineRaggedTensorToTensorShapes:Qk,complexWithEvenIndex:sN,complexWithOddIndex:rN,computeConv2DInfo:Ns,computeConv3DInfo:Ya,computeDefaultPad:hw,computeDilation2DInfo:wf,computeOptimalWindowSize:sx,computeOutAndReduceShapes:ws,computeOutShape:uo,computePool2DInfo:gi,computePool3DInfo:Yo,convertConv2DDataFormat:Zo,decodeEinsumEquation:i_,eitherStridesOrDilationsAreOne:Vs,expandShapeToKeepDim:rs,exponent:aN,exponents:oN,fromStringArrayToUint8:SN,fromUint8ToStringArray:qo,getAxesPermutation:zn,getBroadcastDims:Cu,getComplexWithIndex:r_,getEinsumComputePath:l_,getEinsumPermutation:o_,getFusedBiasGradient:Dw,getFusedDyActivation:Nw,getImageCenter:Kw,getInnerMostAxes:Yn,getPermuted:Af,getRaggedRank:eN,getReductionAxes:fs,getReshaped:If,getReshapedPermuted:Mf,getRowPartitionTypesHelper:Jk,getSliceBeginCoords:Yw,getSliceSize:Zw,getSparseFillEmptyRowsIndicesDenseShapeMismatch:lN,getSparseFillEmptyRowsNegativeIndexErrorMessage:cN,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:uN,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:fN,getSparseReshapeInputOutputMismatchErrorMessage:mN,getSparseReshapeInputOutputMultipleErrorMessage:pN,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:hN,getSparseReshapeNegativeOutputDimErrorMessage:dN,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:vN,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:bb,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:gN,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:xN,getUndoAxesPermutation:Za,isIdentityPermutation:c_,log:x5,mergeRealAndImagArrays:jo,prepareAndValidate:Bw,prepareSplitSize:u_,segment_util:F9,shouldFuse:Fw,slice_util:R9,splitRealAndImagArrays:nN,stridesOrDilationsArePositive:Yl,tupleValuesAreOne:Kl,upcastType:$r,validateDefaultValueShape:tN,validateInput:f7,validateUpdateShape:kk,warn:Wr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */E9();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wN={kernelName:Kg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(n,Tf(at(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P9={kernelName:Td,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=kn(at(t,"float32")),r=Bs(Nt(en(1),s));return qn(At(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O9={kernelName:Id,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Bs(Nt(kn(at(t,"float32")),1));return At(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U9={kernelName:Ou,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ut(t.shape,s.shape);return{a:()=>{let a=n;const l=fs(t.shape,r);return l.length>0&&(a=It(a,l)),fe(a,t.shape)},b:()=>{let a=n;const l=fs(s.shape,r);return l.length>0&&(a=It(a,l)),fe(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z9={kernelName:wS,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B9={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>rn(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V9={kernelName:Zg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>rn(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G9={kernelName:Ad,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,Bs(Nt(en(1),kn(at(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W9={kernelName:Md,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Bs(je(en(1),kn(at(t,"float32"))));return At(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H9={kernelName:Nd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ut(t.shape,s.shape);return{a:()=>{const a=je(kn(t),kn(s));let l=oe(n,At(s,a));const c=fs(t.shape,r);return c.length>0&&(l=It(l,c)),fe(l,t.shape)},b:()=>{const a=je(kn(t),kn(s));let l=qn(oe(n,At(t,a)));const c=fs(s.shape,r);return c.length>0&&(l=It(l,c)),fe(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X9={kernelName:Rd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,je(kn(at(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j9={kernelName:kd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,Nt(en(1),kn(at(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q9(n,e,t,s,r,i){const o=ee(n,"dy","avgPool3dGrad"),a=ee(e,"input","avgPool3dGrad");let l=o,c=a,h=!1;a.rank===4&&(h=!0,l=fe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=fe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),W(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),W(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),wr("avgPool3dGrad",r,i);const d={dy:l,input:c},p={filterSize:t,strides:s,pad:r,dimRoundingMode:i},m=ae.runKernel(TS,d,p);return h?fe(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const K9=me({avgPool3dGrad_:q9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y9={kernelName:Jg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=t;return{x:()=>K9(n,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z9(n,e,t,s,r){const i=ee(n,"dy","avgPoolGrad"),o=ee(e,"input","avgPoolGrad");W(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=fe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=fe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),W(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h={dy:l,input:a},d={filterSize:t,strides:s,pad:r},p=ae.runKernel(ES,h,d);return c?fe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Q9=me({avgPoolGrad_:Z9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J9={kernelName:Qg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o}=t;return{x:()=>Q9(n,s,r,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eq={kernelName:e0,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>pn(n,r,!1,!0),b:()=>pn(s,n,!0,!1)}:!i&&o?{a:()=>pn(n,r,!1,!1),b:()=>pn(n,s,!0,!1)}:i&&!o?{a:()=>pn(r,n,!1,!0),b:()=>pn(s,n,!1,!1)}:{a:()=>pn(r,n,!0,!0),b:()=>pn(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tq={kernelName:t0,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>Ew(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nq={kernelName:f5,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>It(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sq={kernelName:Dd,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rq={kernelName:$d,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq={kernelName:Fd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>ir(Ho(lc(s,r),Gu(s,i)),n,rn(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oq={kernelName:n0,inputsToSave:["x"],gradFunc:wN.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aq={kernelName:s0,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,i=qt(r,e[0].shape)[0],o=s.map(l=>l[i]);return jr(n,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lq={kernelName:r0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=t;return W(Kl(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>pw(s.shape,n,r,o,a,l),filter:()=>kw(s,n,r.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cq={kernelName:i0,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>Zl(n,r,i,o,a,1,l),filter:()=>kw(n,s,r.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(n,e,t,s,r){let i=n;n.rank===4&&(i=fe(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=fe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),W(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),W(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),W(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),W(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),W(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:i,dy:o},l={strides:s,pad:r,filterShape:t};return ae.runKernel(kS,a,l)}const hq=me({conv3DBackpropFilter_:uq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dq={kernelName:o0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;W(Kl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>ck(o.shape,n,a,r,i),filter:()=>hq(o,n,a.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fq={kernelName:Ld,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(qn(Ik(at(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pq={kernelName:Pd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(Ak(at(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq={kernelName:a0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:o}=t;return{x:()=>{const a=zn([r],s.rank);let l=hk(n,r,i,!o);return a!=null&&(l=sn(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gq={kernelName:l0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=t,a=s??[1,1];W(Kl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return W(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),W(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),W(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),W(Vs(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),wr("depthwiseConv2d",i,o),{x:()=>N7(l.shape,n,c,r,i,a,o),filter:()=>R7(l,n,c.shape,r,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq={kernelName:c0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>ae.runKernel(sb,i,t),filter:()=>ae.runKernel(rb,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vq={kernelName:Ud,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>ae.runKernel(zS,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yq={kernelName:zd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=oe(go(qn(kn(t))),2/Math.sqrt(Math.PI));return{x:()=>oe(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bq={kernelName:Bd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sq={kernelName:h0,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>fe(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wq={kernelName:Vd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(n,go(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _q={kernelName:Gd,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cq={kernelName:Wd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ut(t.shape,s.shape);return{a:()=>{const a=At(n,at(s,"float32")),l=fs(t.shape,r);return l.length>0?fe(It(a,l),t.shape):a},b:()=>{let a=oe(n,at(t,"float32"));const l=fs(s.shape,r);l.length>0&&(a=fe(It(a,l),s.shape));const c=kn(s);return qn(At(a,at(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eq={kernelName:d0,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,o,a]=e,l=a??en(1),c=fs(i.shape,r.shape),h=[];if(i.rank===1){for(let _=0;_<r.shape.length-1;++_)h.push(r.shape[_]);h.push(1)}const d=Nt(r,i),p=oe(n,l),m=Ck(je(o,en(s))),g=oe(oe(oe(m,m),m),en(-.5));return{x:()=>i.rank===1?fe(oe(oe(n,Di(fe(m,[1,1,1,i.shape[0]]),h)),l),r.shape):fe(oe(oe(n,m),l),r.shape),mean:()=>{let _=oe(oe(m,en(-1)),p);return i.rank===1&&(_=It(_,c)),fe(_,i.shape)},variance:()=>{let _=oe(oe(g,d),p);return i.rank===1&&(_=It(_,c)),fe(_,i.shape)},scale:()=>{const _=oe(d,m);let A=oe(n,_);return i.rank===1&&(A=It(A,c)),fe(A,i.shape)},offset:()=>{let _=n;return i.rank===1&&(_=It(_,c)),fe(_,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tq={kernelName:f0,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:o}=t,a=qt(i,s.shape)[0],l=(c,h,d)=>()=>{const p=c.shape,m=h.size,g=p.slice(0,a),b=g.length,y=p.slice(i,p.length).slice(1),v=y.length,S=b2(0,b),C=b2(b+1,b+1+v),_=S2([g,[m],y]),A=fe(d,_),k=fe(h,[m]),N=S2([[b],S,C]),D=sn(A,N);let M=Dk(D,k,c.shape[a]);const T=Za(N);return M=sn(M,T),M};if(o===1){const c=s.shape[0],h=s.split(c,0);return{x:()=>Xo(h.map((m,g)=>l(m,r.slice(g,1),n.slice(g,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function b2(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function S2(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iq={kernelName:Hd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>rn(t),b:()=>rn(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aq={kernelName:Xd,gradFunc:n=>({x:()=>at(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mq={kernelName:jd,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rq={kernelName:qd,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kq={kernelName:Kd,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nq={kernelName:m0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=Kr(s,0);return{x:()=>ir(i,n,oe(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dq={kernelName:Zd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,je(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $q={kernelName:Yd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,at(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fq={kernelName:m5,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const o=go(s);return Nt(n,oe(It(n,r,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(n,e,t,s=5,r=1,i=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:i,beta:o};return ae.runKernel(XS,a,l)}const Pq=me({localResponseNormalizationBackprop_:Lq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oq={kernelName:S0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=t;return{x:()=>Pq(s,r,n,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(n,e,t,s){return e.rank<t.rank&&(e=fe(e,rs(e.shape,s))),n.rank<t.rank&&(n=fe(n,rs(n.shape,s))),{x:()=>oe(n,at(mo(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2={kernelName:w0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],o=e[1],a=qt(r,i.shape),l=_N(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uq={kernelName:Qd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>oe(n,at(lc(t,s),"float32")),b:()=>oe(n,at(mg(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(n,e,t,s,r,i,o){const a=ee(n,"dy","maxPool3dGrad"),l=ee(e,"input","maxPool3dGrad"),c=ee(t,"output","maxPool3dGrad");let h=a,d=l,p=c,m=!1;l.rank===4&&(m=!0,h=fe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=fe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=fe(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),W(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),W(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),W(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),wr("maxPool3dGrad",i,o);const g={dy:h,input:d,output:p},b={filterSize:s,strides:r,pad:i,dimRoundingMode:o},y=ae.runKernel(qS,g,b);return m?fe(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const Bq=me({maxPool3dGrad_:zq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vq={kernelName:C0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>Bq(n,s,r,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gq(n,e,t,s,r,i,o){const a=ee(n,"dy","maxPoolGrad"),l=ee(e,"input","maxPoolGrad"),c=ee(t,"output","maxPoolGrad");W(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),W(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),W(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),wr("maxPoolGrad",i,o);const h={dy:a,input:l,output:c},d={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return ae.runKernel(jS,h,d)}const Wq=me({maxPoolGrad_:Gq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hq={kernelName:_0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a}=t;return{x:()=>Wq(n,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xq={kernelName:E0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=qt(r,s.shape),a=ws(s.shape,i)[1],l=Ne(a);return{x:()=>{const h=s.shape.slice();i.forEach(m=>{h[m]=1});const d=fe(n,h);return At(oe(d,Ja(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jq={kernelName:T0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,o]=e,a=qt(r,i.shape),l=_N(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qq={kernelName:Jd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>oe(n,at(Gu(t,s),"float32")),b:()=>oe(n,at(Kr(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kq={kernelName:I0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>In(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yq={kernelName:ef,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ut(t.shape,s.shape);return{a:()=>{const a=fs(t.shape,r);return a.length>0?fe(It(n,a),t.shape):n},b:()=>{const a=oe(n,qn(tx(At(t,s)))),l=fs(s.shape,r);return l.length>0?fe(It(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zq={kernelName:tf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ut(t.shape,s.shape);return{a:()=>{const a=oe(n,at(s,"float32")),l=fs(t.shape,r);return l.length>0?fe(It(a,l),t.shape):a},b:()=>{const a=oe(n,at(t,"float32")),l=fs(s.shape,r);return l.length>0?fe(It(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qq={kernelName:A0,gradFunc:n=>({x:()=>qn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jq={kernelName:k0,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>ls(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eK={kernelName:R0,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tK={kernelName:N0,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return ec(n,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2={kernelName:D0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>In(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nK={kernelName:nf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,o=s,a=Ut(i.shape,o.shape);return{a:()=>{const h=at(o,"float32");let d=oe(n,oe(h,Ql(i,Nt(h,en(1)))));const p=fs(i.shape,a);return p.length>0&&(d=It(d,p)),fe(d,i.shape)},b:()=>{const h=Kr(i,0),d=ir(h,xo(i),rn(i));let p=oe(n,oe(r,d));const m=fs(o.shape,a);return m.length>0&&(p=It(p,m)),fe(p,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sK={kernelName:$0,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=Kr(t,0);return{x:()=>ir(r,n,oe(n,s)),alpha:()=>{let i=ir(r,rn(n),oe(n,t));const o=fs(s.shape,n.shape);return o.length>0&&(i=It(i,o)),fe(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rK(n,e,t){const s=n.shape.slice();s[t]=1;const r=fe(e,s),i=xb(n,t,!0,!1),o=xb(n,t,!0,!0),a=oe(i,o);return oe(r,a)}function iK(n,e,t){const s=n.shape.length,r=s-t.length,i=zn(t,s);let o=n;i!=null&&(o=sn(n,i));const a=o.shape.slice(),c=a.splice(s-t.length,t.length).reduce((p,m)=>p*m,1);a.push(c);const h=o.reshape(a);let d=rK(h,e,r);if(d=d.reshape(o.shape),i!=null){const p=Za(i);d=sn(d,p)}return d}const oK={kernelName:F0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>iK(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aK={kernelName:Od,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ut(t.shape,s.shape);return{a:()=>{const a=At(n,at(s,"float32")),l=fs(t.shape,r);return l.length>0?fe(It(a,l),t.shape):a},b:()=>{let a=oe(n,at(t,"float32"));const l=fs(s.shape,r);l.length>0&&(a=fe(It(a,l),s.shape));const c=kn(s);return qn(At(a,at(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lK={kernelName:sf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,qn(kn(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cK={kernelName:of,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=oe(Gu(t,6),Tf(t));return{x:()=>oe(n,at(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uK={kernelName:rf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(n,at(Tf(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hK={kernelName:L0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dK={kernelName:O0,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>ae.runKernel(tw,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fK={kernelName:P0,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>ae.runKernel(ew,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pK={kernelName:U0,gradFunc:(n,e,t)=>{const{dims:s}=t,r=qt(s,n.shape);return{x:()=>Jl(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mK={kernelName:af,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gK={kernelName:lf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>qn(At(n,oe(Ql(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xK={kernelName:z0,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>at(rn(t),"float32"),t:()=>oe(n,at(t,n.dtype)),e:()=>oe(n,at(Sw(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vK={kernelName:cf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Kr(t,en(0)),r=en(rx),i=en(ix),o=oe(n,i),a=oe(oe(n,r),go(at(t,"float32")));return ir(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yK={kernelName:ff,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(n,oe(t,Nt(en(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bK={kernelName:df,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SK={kernelName:uf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(mw(at(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wK={kernelName:hf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(uk(at(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _K={kernelName:B0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,o=s.shape,[a,l]=nx(s,r,i),c=[];for(let h=0;h<n.rank;h++)c.push([a[h],o[h]-a[h]-l[h]]);return{x:()=>Cw(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CK={kernelName:H0,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,o=oe(n,s);return{logits:()=>Nt(o,oe(It(o,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EK={kernelName:pf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(n,Vu(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C2={kernelName:G0,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>fw(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E2={kernelName:W0,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>xr(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TK={kernelName:mf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,oe(Bs(at(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IK={kernelName:nw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(n,oe(at(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AK={kernelName:gf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=en(2);return{a:()=>oe(n,oe(r,Nt(t,s))),b:()=>oe(n,oe(r,Nt(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MK={kernelName:Sf,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RK={kernelName:xf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ut(t.shape,s.shape);return{a:()=>{let a=n;const l=fs(t.shape,r);return l.length>0&&(a=It(a,l)),fe(a,t.shape)},b:()=>{let a=n;const l=fs(s.shape,r);return l.length>0&&(a=It(a,l)),fe(qn(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kK={kernelName:V0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;qt(i,s.shape).forEach(c=>{r[c]=1});const a=fe(n,r),l=oe(a,Ja(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NK={kernelName:vf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,kn(mw(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DK={kernelName:yf,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>oe(Nt(en(1),kn(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $K={kernelName:bf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let o=rn(s);if(s.rank===1)for(let a=0;a<r[0];++a)o=je(o,In(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=je(o,In(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)o=je(o,In(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let h=0;h<r[3];++h)o=je(o,In(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2],h*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FK={kernelName:du,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=Za(r);return{x:()=>sn(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LK={kernelName:X0,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>Xo(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PK={kernelName:j0,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>OK(n,t)}}};function OK(n,e){const t=Qa(e,rn(e)),s=vw(n,t);let r=lc(e,en(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=fr(r,a+1);r=Ho(r,Ja(s.shape,"bool"));const o=rn(s);return ir(r,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UK={kernelName:q0,gradFunc:n=>({x:()=>rn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zK=[wN,P9,O9,U9,z9,B9,V9,G9,W9,H9,X9,j9,Y9,J9,eq,tq,nq,sq,rq,iq,oq,aq,cq,lq,dq,fq,pq,mq,gq,xq,aK,vq,yq,bq,Sq,wq,Cq,_q,Eq,Tq,Iq,Aq,Mq,Rq,kq,Nq,Dq,$q,Fq,Oq,w2,w2,Uq,Vq,Hq,Xq,jq,qq,Kq,Yq,Zq,Qq,Jq,eK,tK,_2,_2,nK,sK,oK,lK,cK,uK,hK,dK,fK,pK,mK,gK,xK,vK,yK,bK,SK,wK,_K,CK,EK,C2,C2,E2,E2,TK,AK,IK,MK,RK,kK,NK,DK,$K,FK,LK,PK,UK];for(const n of zK)v5(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.abs=function(){return this.throwIfDisposed(),er(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.acos=function(){return this.throwIfDisposed(),b6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.acosh=function(){return this.throwIfDisposed(),w6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.add=function(n){return this.throwIfDisposed(),je(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.all=function(n,e){return this.throwIfDisposed(),ok(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.any=function(n,e){return this.throwIfDisposed(),pb(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.argMax=function(n){return this.throwIfDisposed(),cd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.argMin=function(n){return this.throwIfDisposed(),I6(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.asScalar=function(){return this.throwIfDisposed(),W(this.size===1,()=>"The array must have only 1 element."),fe(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.asType=function(n){return this.throwIfDisposed(),at(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.as1D=function(){return this.throwIfDisposed(),fe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.as2D=function(n,e){return this.throwIfDisposed(),fe(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),fe(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),fe(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),fe(this,[n,e,t,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.asin=function(){return this.throwIfDisposed(),M6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.asinh=function(){return this.throwIfDisposed(),k6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.atan=function(){return this.throwIfDisposed(),D6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.atan2=function(n){return this.throwIfDisposed(),F6(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.atanh=function(){return this.throwIfDisposed(),P6(this)};Me().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),dw(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),fw(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Z0(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Jh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.cast=function(n){return this.throwIfDisposed(),at(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.ceil=function(){return this.throwIfDisposed(),u8(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),qr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof as&&(n=[n]),xr([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),ak(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),lk(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Zl(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.cos=function(){return this.throwIfDisposed(),mw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.cosh=function(){return this.throwIfDisposed(),uk(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),xb(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),hk(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),$8(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),gw(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),P8(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.divNoNan=function(n){return this.throwIfDisposed(),V8(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.div=function(n){return this.throwIfDisposed(),At(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.dot=function(n){return this.throwIfDisposed(),W8(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.elu=function(){return this.throwIfDisposed(),J0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.equal=function(n){return this.throwIfDisposed(),mo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.erf=function(){return this.throwIfDisposed(),dk(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),nX(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.exp=function(){return this.throwIfDisposed(),go(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.expandDims=function(n){return this.throwIfDisposed(),fr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.expm1=function(){return this.throwIfDisposed(),oX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.fft=function(){return this.throwIfDisposed(),Rk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.flatten=function(){return this.throwIfDisposed(),fe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.floor=function(){return this.throwIfDisposed(),tx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.floorDiv=function(n){return this.throwIfDisposed(),ik(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.gather=function(n,e,t){return this.throwIfDisposed(),vw(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.greaterEqual=function(n){return this.throwIfDisposed(),lc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.greater=function(n){return this.throwIfDisposed(),Kr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.ifft=function(){return this.throwIfDisposed(),vb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.irfft=function(){return this.throwIfDisposed(),Jj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.isFinite=function(){return this.throwIfDisposed(),mX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.isInf=function(){return this.throwIfDisposed(),xX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.isNaN=function(){return this.throwIfDisposed(),yX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.leakyRelu=function(n){return this.throwIfDisposed(),bw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.lessEqual=function(n){return this.throwIfDisposed(),Gu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.less=function(n){return this.throwIfDisposed(),mg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),CX(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.logSigmoid=function(){return this.throwIfDisposed(),kX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.logSoftmax=function(n){return this.throwIfDisposed(),xk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),vk(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.log=function(){return this.throwIfDisposed(),xo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.log1p=function(){return this.throwIfDisposed(),gk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ho(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.logicalNot=function(){return this.throwIfDisposed(),Sw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.logicalOr=function(n){return this.throwIfDisposed(),yk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.logicalXor=function(n){return this.throwIfDisposed(),UX(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),pn(this,n,e,t)};Me().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),ww(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.max=function(n,e){return this.throwIfDisposed(),Pi(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.maximum=function(n){return this.throwIfDisposed(),Qa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.mean=function(n,e){return this.throwIfDisposed(),ss(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.min=function(n,e){return this.throwIfDisposed(),pg(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.minimum=function(n){return this.throwIfDisposed(),dd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),jX(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.mod=function(n){return this.throwIfDisposed(),KX(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.mul=function(n){return this.throwIfDisposed(),oe(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.neg=function(){return this.throwIfDisposed(),qn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.norm=function(n,e,t){return this.throwIfDisposed(),ex(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.notEqual=function(n){return this.throwIfDisposed(),gg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),bk(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.onesLike=function(){return this.throwIfDisposed(),mi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.pad=function(n,e){return this.throwIfDisposed(),Cw(this,n,e)};Me().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),ij(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.pow=function(n){return this.throwIfDisposed(),Ql(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.prelu=function(n){return this.throwIfDisposed(),Tw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.prod=function(n,e){return this.throwIfDisposed(),lj(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.reciprocal=function(){return this.throwIfDisposed(),Dj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.relu=function(){return this.throwIfDisposed(),cc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.relu6=function(){return this.throwIfDisposed(),wk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.reshapeAs=function(n){return this.throwIfDisposed(),fe(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.reshape=function(n){return this.throwIfDisposed(),fe(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),Fk(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),Lk(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.reverse=function(n){return this.throwIfDisposed(),Jl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.rfft=function(){return this.throwIfDisposed(),n7(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.round=function(){return this.throwIfDisposed(),_k(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.rsqrt=function(){return this.throwIfDisposed(),Ck(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.selu=function(){return this.throwIfDisposed(),Ek(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Tk(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.sigmoid=function(){return this.throwIfDisposed(),Vu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.sign=function(){return this.throwIfDisposed(),Vj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.sin=function(){return this.throwIfDisposed(),Ik(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.sinh=function(){return this.throwIfDisposed(),Ak(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.slice=function(n,e){return this.throwIfDisposed(),In(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.softmax=function(n){return this.throwIfDisposed(),Rw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.softplus=function(){return this.throwIfDisposed(),_f(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),Ew(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.split=function(n,e){return this.throwIfDisposed(),jr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.sqrt=function(){return this.throwIfDisposed(),Bs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.square=function(){return this.throwIfDisposed(),kn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.squaredDifference=function(n){return this.throwIfDisposed(),r7(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.squeeze=function(n){return this.throwIfDisposed(),Ef(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof as?[this,n]:[this,...n];return Xo(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.step=function(n){return this.throwIfDisposed(),Tf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.stridedSlice=function(n,e,t,s,r,i,o,a){return this.throwIfDisposed(),c7(this,n,e,t,s,r,i,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.sub=function(n){return this.throwIfDisposed(),Nt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.sum=function(n,e){return this.throwIfDisposed(),It(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.tan=function(){return this.throwIfDisposed(),h7(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.tanh=function(){return this.throwIfDisposed(),Y0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.tile=function(n){return this.throwIfDisposed(),Di(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.toBool=function(){return this.throwIfDisposed(),at(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.toFloat=function(){return this.throwIfDisposed(),at(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.toInt=function(){return this.throwIfDisposed(),at(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.topk=function(n,e){return this.throwIfDisposed(),m7(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.transpose=function(n){return this.throwIfDisposed(),sn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.unique=function(n){return this.throwIfDisposed(),v7(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Dk(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.unstack=function(n){return this.throwIfDisposed(),ec(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.where=function(n,e){return this.throwIfDisposed(),ir(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Me().prototype.zerosLike=function(){return this.throwIfDisposed(),rn(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class to extends Error{constructor(e){super(e),Object.setPrototypeOf(this,to.prototype)}}class hi extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hi.prototype)}}class ie extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ie.prototype)}}class Wt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Wt.prototype)}}class d_ extends Error{constructor(e){super(e),Object.setPrototypeOf(this,d_.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class CN{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tc(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function no(n,e){if(!n)throw new d_(e)}function T2(n,e){let t=0;for(const s of n)s===e&&t++;return t}function pr(n){return n.length===1?n[0]:n}function vn(n){return Array.isArray(n)?n:[n]}function Po(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Dl(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let ii={};function f_(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function Sb(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>Sb(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:Sb(s))}}}function Rf(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in ii)o=ii[i];else if(o=e[i],o==null)throw new ie(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new ie(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in t?[a,l]=t[o]:o in ii?[a,l]=ii.className:o in e&&([a,l]=e[o]),a==null)throw new ie(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const m of Object.keys(ii))c[m]=ii[m];for(const m of Object.keys(t))c[m]=t[m];const h=i.config;h.customObjects=c;const d=Object.assign({},ii);for(const m of Object.keys(t))ii[m]=t[m];Sb(i.config);const p=l(a,i.config,t,r);return ii=Object.assign({},d),p}else{const c=Object.assign({},ii);for(const d of Object.keys(t))ii[d]=t[d];const h=new a(i.config);return ii=Object.assign({},c),h}}}function BK(n,e){return n<e?-1:n>e?1:0}function Am(n,e){return-1*BK(n,e)}function Pa(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function VK(n){if(n==null)throw new ie(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function hc(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new ie(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function p_(n,e,t=0,s=1/0){return no(t>=0),no(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function ys(n,e){Array.isArray(n)?(W(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>ys(t,`element ${s+1} of ${e}`))):W(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${EN(n)}.`)}function EN(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>EN(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function GK(n,e,t){let s=t!=null?t():dr(),r;return(...o)=>{const a=t!=null?t():dr();return a-s<e||(s=a,r=n(...o)),r}}function TN(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let WK=0;function IN(){return WK++}const Mm={};function ox(n=""){return n in Mm||(Mm[n]=0),Mm[n]+=1,n+Mm[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const HK=["channelsFirst","channelsLast"],XK=["nearest","bilinear"],jK=["valid","same","causal"],qK=["max","avg"],KK=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const su=new Map;function Zn(n){hc(HK,"DataFormat",n)}function YK(n){hc(XK,"InterpolationFormat",n)}function Yr(n){hc(jK,"PaddingMode",n)}function AN(n){hc(qK,"PoolMode",n)}const ed=[],I2="/";function Bl(n,e){ed.push(n);try{const t=e();return ed.pop(),t}catch(t){throw ed.pop(),t}}function ZK(){return ed.length===0?"":ed.join(I2)+I2}function MN(n){if(!kN(n))throw new Error("Not a valid tensor name: '"+n+"'");return ZK()+n}function RN(n){if(!kN(n))throw new Error("Not a valid tensor name: '"+n+"'");su.has(n)||su.set(n,0);const e=su.get(n);if(su.set(n,su.get(n)+1),e>0){const t=`${n}_${e}`;return su.set(t,1),t}else return n}const QK=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function kN(n){return!!n.match(QK)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function JK(n){return n===parseInt(n.toString(),10)}function Oa(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Tu(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Va(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function zi(n,e){if(e<n)throw new ie(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Yy;function cs(){return Yy==null&&(Yy=ZR().epsilon()),Yy}function Bi(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ho(n,e){return at(n,e)}function kf(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),fe(n,t)}function eY(n,e){return be(()=>{if(n.shape.length!==2)throw new ie(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=kf(n,1);return wb(t,[1,e,1])})}function tY(n){const e=[Oa(n.shape)];return fe(n,e)}function nY(n){if(n.rank<=1)throw new ie(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Oa(n.shape,1)];return fe(n,e)}function Vl(n,e,t){return be(()=>{switch(n.rank){case 1:return Aw(n,e,t);case 2:return Mk(n,[e,0],[t,n.shape[1]]);case 3:return Mw(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return vg(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return In(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return In(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ie(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Zy(n,e,t){return be(()=>{switch(n.rank){case 1:return Aw(n,e,t);case 2:return Mk(n,[0,e],[n.shape[0],t]);case 3:return Mw(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return vg(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new ie(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Rm(n,e,t,s){return be(()=>{switch(n.rank){case 1:return Aw(n,e,t);case 2:switch(s){case 1:return Vl(n,e,t);case 2:return Zy(n,e,t);default:throw new ie(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Vl(n,e,t);case 2:return Mw(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Zy(n,e,t);default:throw new ie(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Vl(n,e,t);case 2:return vg(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return vg(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Zy(n,e,t);default:throw new ie(`The axis is not within the rank of the tensor ${s}`)}default:throw new ie(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function m_(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),xr(n,e)}function A2(n,e){switch(n.rank){case 1:return f8([n,e]);case 2:return m8([n,e],0);case 3:return x8([n,e],0);case 4:return y8([n,e],0);default:throw new ie(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function wb(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new ie(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Di(n,e)}function ax(n,e=0,t=1,s,r){return Mj(n,e,t,s,r)}function fo(n,e,t,s){if(n.rank<2||e.rank<2)throw new Wt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new Wt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return p2({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?_b(n.rank,s,Bi()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=fe(n,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],h=Array.from({length:e.rank},(g,b)=>b===0?e.rank-2:b<=e.rank-2?b-1:b);e=fe(sn(e,h),[l,-1]);const d=[...r,...c];return fe(p2({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?_b(n.rank,s,Bi()):null,activation:t}),d)}}function NN(n,e,t){return be(()=>(Array.isArray(e)?e=Dr(e,"int32"):e=at(e,"int32"),vw(n,e,t)))}function Nf(n){return oe(n,n)}function _b(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new ie(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?fe(e,[1,s[0],1,1,1]):fe(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?fe(e,[1,1,1,1,s[0]]):fe(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?fe(e,[1,s[0],1,1]):fe(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?fe(e,[1,1,1,s[0]]):fe(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?fe(e,[1,s[0],1]):fe(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?fe(e,[1,1,s[0]]):fe(e,[1].concat(s))}else if(n<3)return e;throw new ie(`Unsupported input rank by biasAdd: ${e.rank}`)}function Gi(n,e,t){return be(()=>(t==null&&(t=Bi()),Zn(t),je(n,_b(n.rank,e,t))))}function sY(n,e=1){if(e!==1)throw new Wt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return J0(n)}function rY(n){return be(()=>At(n,je(er(n),1)))}function DN(n,e,t,s){return be(()=>E7(n,e,t,s))}function iY(n){return be(()=>{const e=je(.5,oe(.2,n));return qr(e,0,1)})}function Df(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const oY=["fanIn","fanOut","fanAvg"],aY=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lY(n){hc(oY,"FanMode",n)}function cY(n){hc(aY,"Distribution",n)}class xi extends Hu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class $N extends xi{apply(e,t){return ls(e,t)}}$N.className="Zeros";Ue($N);class g_ extends xi{apply(e,t){return Ja(e,t)}}g_.className="Ones";Ue(g_);class FN extends xi{constructor(e){if(super(),typeof e!="object")throw new ie(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ie(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return be(()=>oe(en(this.value),Ja(e,t)))}getConfig(){return{value:this.value}}}FN.className="Constant";Ue(FN);class LN extends xi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Cf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}LN.className="RandomUniform";Ue(LN);class PN extends xi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Wt(`randomNormal does not support dType ${t}.`);return ax(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}PN.className="RandomNormal";Ue(PN);class ON extends xi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Wt(`truncatedNormal does not support dType ${t}.`);return Nk(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ON.className="TruncatedNormal";Ue(ON);class UN extends xi{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return be(()=>{if(e.length!==2||e[0]!==e[1])throw new ie("Identity matrix initializer can only be used for 2D square matrices.");return oe(this.gain,mk(e[0]))})}getConfig(){return{gain:this.gain}}}UN.className="Identity";Ue(UN);function uY(n,e="channelsLast"){let t,s;if(Zn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Oa(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Oa(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Oa(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class Fr extends xi{constructor(e){if(super(),e.scale<0)throw new ie(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,lY(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,cY(this.distribution),this.seed=e.seed}apply(e,t){const s=uY(e),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Wt(`${this.getClassName()} does not support dType ${t}.`);return Nk(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return Cf(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Fr.className="VarianceScaling";Ue(Fr);class x_ extends Fr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Fr.className}}x_.className="GlorotUniform";Ue(x_);class v_ extends Fr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Fr.className}}v_.className="GlorotNormal";Ue(v_);class y_ extends Fr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Fr.className}}y_.className="HeNormal";Ue(y_);class b_ extends Fr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Fr.className}}b_.className="HeUniform";Ue(b_);class S_ extends Fr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Fr.className}}S_.className="LeCunNormal";Ue(S_);class w_ extends Fr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Fr.className}}w_.className="LeCunUniform";Ue(w_);class zN extends xi{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return be(()=>{if(e.length<2)throw new Wt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=Ne(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],a=ax(o,0,1,t,this.seed),l=S9.qr(a,!1);let c=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return c=oe(c,d.sign()),s<r&&(c=c.transpose()),oe(en(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}zN.className="Orthogonal";Ue(zN);const M2={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function R2(n,e={}){return Rf(n,ui.getMap().classNameMap,e,"initializer")}function Un(n){return f_(n)}function $n(n){if(typeof n=="string"){const e=n in M2?M2[n]:n;if(e==="GlorotNormal")return new v_;if(e==="GlorotUniform")return new x_;if(e==="HeNormal")return new y_;if(e==="HeUniform")return new b_;if(e==="LeCunNormal")return new S_;if(e==="LeCunUniform")return new w_;{const t={};return t.className=e,t.config={},R2(t)}}else return n instanceof xi?n:R2(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Cb(n){return Array.isArray(n)&&Array.isArray(n[0])}function yg(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Dt(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new ie(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function ln(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new ie(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bg(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const k2="Variable";class hY{constructor(e,t="float32",s=k2,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=IN(),s=s??k2,this.originalName=MN(s),this.name=RN(this.originalName),this.trainable_=r,this.constraint=i,this.val=S7(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),dY(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function dY(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function Eb(n){return n.map(e=>e.read())}function __(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class us{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class vo{constructor(e,t,s,r,i,o,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=IN(),o!=null&&(this.originalName=MN(o),this.name=RN(this.originalName)),this.rank=t.length}}let fY=0;class lx{constructor(e,t){this.callArgs=t,this.id=fY++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let pY=0;class Kt extends Hu{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=pY++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=Po(s)+"_"+ox(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new hi(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ie(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return pr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return pr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new to(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new to(`Layer ${this.name} is not connected, no input to return.`);return pr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new to(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new to(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return pr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=vn(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=vn(this.inputSpec);if(t.length!==s.length)throw new ie(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],o=s[r];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new ie(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new ie(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new ie(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new ie(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const c in o.axes){const h=Number(c),d=o.axes[c],p=h>=0?l[h]:l[l.length+h];if(d!=null&&[d,null].indexOf(p)===-1)throw new ie(`Input ${r} is incompatible with layer ${this.name}: expected axis ${h} of input shape to have value ${d} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],h=i.shape[l];if(c!=null&&h!=null&&c!==h)throw new ie(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=vn(e),r=xY(e),i=vY(e);if(r===i)throw new ie("Arguments to apply() must be all SymbolicTensors or all Tensors");return Bl(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of vn(e))o.push(a.shape);this.build(pr(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=vn(o),l=[];for(let c of a)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=pr(l),this.activityRegularizer!=null)throw new Wt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=mY(e),a=this.computeOutputShape(o);let l;const c=gY(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((h,d)=>new vo(c,h,this,vn(e),t,this.name,d)):l=new vo(c,a,this,vn(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Wt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new to(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new to(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new hi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return bg(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Eb(e?this.trainableWeights:this.weights)}setWeights(e){be(()=>{const t=this.weights;if(t.length!==e.length)throw new ie(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=Eb(t);for(let i=0;i<r.length;++i){const o=r[i],a=t[i],l=e[i];if(!mn(o.shape,l.shape))throw new ie(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}__(s)})}addWeight(e,t,s,r,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ie(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():$n("zeros"));const c=r.apply(t,s),h=new hY(c,s,e,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(h.read())),o==null&&(o=!0),o?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=vn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=vn(t),o=vn(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(e,t,s,r,i,o,a=null){const l=vn(e);t=vn(t),s=vn(s),r=vn(r),i=yg(i),o=yg(o);const c=[],h=[],d=[];for(const p of l)c.push(p.sourceLayer),h.push(p.nodeIndex),d.push(p.tensorIndex);new lx({outboundLayer:this,inboundLayers:c,nodeIndices:h,tensorIndices:d,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function mY(n){n=vn(n);const e=[];for(const t of n)e.push(t.shape);return pr(e)}function gY(n){return"float32"}function BN(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],a=s.inboundLayers[i],l=s.nodeIndices[i],c=BN(o,a,l);for(const h of c)r.indexOf(h)===-1&&r.push(h)}return r}}}function xY(n){let e=!0;for(const t of vn(n))if(!(t instanceof vo)){e=!1;break}return e}function vY(n){let e=!0;for(const t of vn(n))if(t instanceof vo){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $f extends Kt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:ox("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ie("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ie("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ie("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new vo(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new lx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ie(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}$f.className="InputLayer";Ue($f);function yY(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new ie("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new $f({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bY(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return at(e,n.dtype)}catch{throw new ie(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Ra{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Ra)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=bY(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ie(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof vo){if(this.id2Value[e.id]==null)throw new ie(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ie(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof vo){if(this.id2Value[e.id]==null)throw new ie(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ie(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Yt(this.id2Mask)}}const Sg=new CN,wg=new CN;function SY(n){Sg!=null&&Sg.setMaxEntries(n),wg!=null&&wg.setMaxEntries(n)}function Kh(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],a=o.map(g=>g.name),l=[],c=e.names();for(const g of a)c.indexOf(g)!==-1?l.push(e.getValue(g)):l.push(null);const h=a.join(",")+"|"+e.names().sort().join(",");let d=Sg.get(h),p;if(d==null){const g=wY(o,e);d=g.sorted,p=g.recipientCounts,Sg.put(h,d),wg.put(h,p)}p={},r||Object.assign(p,wg.get(h));const m=new Ra(e);for(let g=0;g<d.length;++g){const b=d[g],y=b.sourceLayer;if(y instanceof $f)continue;const v=[],S=[],C=[];let _=!1;for(const M of b.inputs){const T=m.getValue(M),I=m.getMask(M);v.push(T),S.push(I),I!=null&&(_=!0),r||(p[M.name]--,p[M.name]===0&&!e.hasKey(M)&&a.indexOf(M.name)===-1&&!T.isDisposed&&M.sourceLayer.stateful!==!0&&C.push(T))}_&&(t=t||{},t.mask=S[0]);const A=vn(y.apply(v,t));let k=null;y.supportsMasking&&(k=y.computeMask(v,S));const N=CY(b),D=Array.isArray(N)?N:[N];for(let M=0;M<D.length;++M){m.hasKey(D[M])||m.add(D[M],A[M],Array.isArray(k)?k[0]:k);const T=a.indexOf(D[M].name);T!==-1&&(l[T]=A[M])}r||Yt(C)}return m.disposeMasks(),i?l:l[0]}function wY(n,e){W(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=N2(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:a}=N2(i,e);for(const l of o)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(c=>s[l].add(c))}}return{sorted:t,recipientCounts:_Y(s)}}function _Y(n){const e={};for(const t in n)e[t]=n[t].size;return e}function N2(n,e){const t=new Set,s=[],r={};for(const a of e.names())t.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(t.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),s.push(a),t.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(a.name),!t.has(c.name)&&i.push(c)}}return{sorted:s,recipientMap:r}}function CY(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EY=_e();EY.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,SY);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function C_(n,e){return be(()=>Bs(It(oe(n,n),e,!0)))}class Ff extends Hu{getConfig(){return{}}}class VN extends Ff{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>{const t=C_(e,this.axis),s=qr(t,0,this.maxValue);return oe(e,At(s,je(cs(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}VN.className="MaxNorm";Ue(VN);class GN extends Ff{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>At(e,je(cs(),C_(e,this.axis))))}getConfig(){return{axis:this.axis}}}GN.className="UnitNorm";Ue(GN);class WN extends Ff{apply(e){return cc(e)}}WN.className="NonNeg";Ue(WN);class HN extends Ff{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>{const t=C_(e,this.axis),s=je(oe(this.rate,qr(t,this.minValue,this.maxValue)),oe(1-this.rate,t));return oe(e,At(s,je(cs(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}HN.className="MinMaxNorm";Ue(HN);const D2={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function hs(n){return f_(n)}function $2(n,e={}){return Rf(n,ui.getMap().classNameMap,e,"constraint")}function ds(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in D2?D2[n]:n,config:{}};return $2(t)}else return n instanceof Ff?n:$2(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function El(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(r),s.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];Yt(s)}}function XN(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var F2;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(F2||(F2={}));const TY=125;class pd{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class IY{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class AY extends pd{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=be(()=>je(this.totals[r],oe(i,s)));this.totals[r]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:be(()=>{const r=oe(At(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),co(t[s])}))}}class MY extends pd{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(i),s.push(a)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class RY extends pd{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Zk,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=TY),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");eb(this.yieldEvery)&&(this.maybeWait=GK(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await El(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await El(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await El(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await El(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await El(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):eb(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await El(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await El(e),await this.trainEnd(e))}}function jN(n,e){return n==null&&(n={}),n instanceof pd?[n]:Array.isArray(n)&&n[0]instanceof pd?n:vn(n).map(s=>new RY(s,e))}class ai{constructor(){}static registerCallbackConstructor(e,t){W(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ai.checkForDuplicate(t),ai.constructors[e]==null&&(ai.constructors[e]=[]),ai.constructors[e].push(t)}static checkForDuplicate(e){for(const t in ai.constructors)ai.constructors[+t].forEach(r=>{if(r===e)throw new ie("Duplicate callback constructor.")})}static clear(){ai.constructors={}}static createCallbacks(e){const t=[];for(const s in ai.constructors){const r=+s;e>=r&&t.push(...ai.constructors[r])}return t.map(s=>new s)}}ai.constructors={};function qN(n,e,t,s,r,i,o,a,l){const c=new MY,h=[new AY,...ai.createCallbacks(e)];n!=null&&h.push(...n),h.push(c);const d=new IY(h);return d.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:d,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Go(n,e={},t=!1){return Rf(n,ui.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _g(n,e){return be(()=>{n.dtype!=="float32"&&(n=at(n,"float32"));const t=It(Nf(n),e,!0),s=Q0(t.shape,cs()),r=Bs(Qa(t,s));return At(n,r)})}function cx(n,e){return be(()=>ss(Nf(Nt(e,n)),-1))}function E_(n,e){return be(()=>ss(er(Nt(e,n)),-1))}function T_(n,e){return be(()=>{const t=Nt(n,e),s=qr(er(n),cs(),Number.MAX_VALUE),r=er(At(t,s));return oe(100,ss(r,-1))})}function kY(n,e){return be(()=>{const t=qr(e,cs(),Number.MAX_VALUE),s=xo(je(1,t)),r=qr(n,cs(),Number.MAX_VALUE),i=xo(je(1,r));return ss(Nf(Nt(s,i)),-1)})}function NY(n,e){return be(()=>{const t=Qa(0,Nt(1,oe(n,e)));return ss(Nf(t),-1)})}function DY(n,e){return be(()=>{const t=Qa(0,Nt(1,oe(n,e)));return ss(t,-1)})}function $Y(n,e){return be(()=>{const t=It(oe(n,e),-1),s=Pi(oe(Nt(1,n),e),-1);return Qa(0,je(1,Nt(s,t)))})}function FY(n,e){return be(()=>{const t=Math.log(2),s=Nt(e,n),r=Nt(je(s,_f(oe(-2,s))),t);return ss(r,-1)})}function md(n,e,t=!1){return be(()=>{if(t)e=Rw(e);else{const s=It(e,e.shape.length-1,!0);e=At(e,s)}return e=qr(e,cs(),1-cs()),qn(It(oe(at(n,"float32"),xo(e)),e.shape.length-1))})}function Cg(n,e,t=!1){return be(()=>{const s=at(tx(tY(n)),"int32");e=qr(e,cs(),1-cs());const r=e.shape,i=fe(bk(s,r[r.length-1]),r);return md(i,e,t)})}function LY(n,e){if(!mn(n.shape,e.shape))throw new ie(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return be(()=>{const t=cc(e),s=qn(er(e));return je(Nt(t,oe(e,n)),gk(go(s)))})}function ux(n,e){return be(()=>{let t;return t=qr(e,cs(),1-cs()),t=xo(At(t,Nt(1,t))),ss(LY(n,t),-1)})}function PY(n,e){return be(()=>{const t=qr(n,cs(),1),s=qr(e,cs(),1);return It(oe(n,xo(At(t,s))),-1)})}function OY(n,e){return be(()=>{const t=xo(je(cs(),e));return ss(Nt(e,oe(n,t)),-1)})}function KN(n,e){return be(()=>{const t=_g(n,-1),s=_g(e,-1),r=oe(t,s);return qn(It(r,-1))})}const Eg={meanSquaredError:cx,meanAbsoluteError:E_,meanAbsolutePercentageError:T_,meanSquaredLogarithmicError:kY,squaredHinge:NY,hinge:DY,categoricalHinge:$Y,logcosh:FY,categoricalCrossentropy:md,sparseCategoricalCrossentropy:Cg,binaryCrossentropy:ux,kullbackLeiblerDivergence:PY,poisson:OY,cosineProximity:KN};function Qy(n){if(typeof n=="string"){if(n in Eg)return Eg[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ie(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function YN(n,e){return be(()=>{const t=oe(.5,mi(e)),s=ho(Kr(e,t),n.dtype);return ss(mo(n,s),-1)})}function ZN(n,e){return be(()=>ho(mo(cd(n,-1),cd(e,-1)),"float32"))}function UY(n,e){return be(()=>at(It(Ho(mo(n,1),mo(e,1))),"float32"))}function zY(n,e){return be(()=>at(It(Ho(mo(n,0),mo(e,1))),"float32"))}function BY(n,e){return be(()=>{const t=UY(n,e),s=zY(n,e),r=je(t,s);return at(ir(Kr(r,0),At(t,r),0),"float32")})}function VY(n,e){return ux(n,e)}function GY(n,e){return n.rank===e.rank&&(n=Ef(n,[n.rank-1])),e=cd(e,-1),e.dtype!==n.dtype&&(e=at(e,n.dtype)),at(mo(n,e),"float32")}const WY=cx,HY=cx,XY=E_,jY=E_,qY=T_,KY=T_,QN=md,YY=KN,JN=Cg,Tg={binaryAccuracy:YN,categoricalAccuracy:ZN,precision:BY,categoricalCrossentropy:QN,sparseCategoricalCrossentropy:JN,mse:WY,MSE:HY,mae:XY,MAE:jY,mape:qY,MAPE:KY,cosine:YY};function ZY(n){if(typeof n=="string"&&n in Tg)return Tg[n];if(typeof n!="string"&&n!=null)return n;throw new ie(`Unknown metric ${n}`)}function km(n){if(no(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Eg))if(Eg[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Tg))if(Tg[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function QY(n){const e={Adagrad:()=>nu.adagrad(.01),Adadelta:()=>nu.adadelta(1,.95,cs()),Adam:()=>nu.adam(.001,.9,.999,cs()),Adamax:()=>nu.adamax(.002,.9,.999,cs(),0),RMSProp:()=>nu.rmsprop(.001,.9,0,cs()),SGD:()=>nu.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new ie(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const L2=1*1024*1024;function P2(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!Tb(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>L2&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${L2}.`)}}function Tb(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!Tb(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!Tb(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function JY(n,e,t,s=console.log){const r=tZ(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(h=>Math.floor(e*h)));let o;if(!r){i.push("Receives inputs"),o=[];for(const h in n.nodesByDepth)o.push(...n.nodesByDepth[h])}s("_".repeat(e)),Ig(i,t,s),s("=".repeat(e));const a=n.layers;for(let h=0;h<a.length;++h)r?nZ(a[h],t,s):sZ(a[h],t,o,s),s((h===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=eZ(n),c=bg(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function eZ(n){let e;return n.collectedTrainableWeights!=null?e=bg(n.collectedTrainableWeights):e=bg(n.trainableWeights),e}function tZ(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function Ig(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function nZ(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,r,s,n.countParams().toString()];Ig(a,e,t)}function sZ(n,e,t,s){let r,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const d of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(d)===-1))for(let p=0;p<d.inboundLayers.length;++p){const m=d.inboundLayers[p].name,g=d.nodeIndices[p],b=d.tensorIndices[p];o.push(`${m}[${g}][${b}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],h=[`${a} (${l})`,i,r,n.countParams().toString(),c];Ig(h,e,s);for(let d=1;d<o.length;++d)Ig(["","","","",o[d]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eD(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Ib(n,e){if(n===null)return null;if(typeof n=="string")return Dl(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];eD(e,r,i)?t.push(i):t.push(Ib(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=Dl(s);t[i]=Ib(r,i)}}return t}}function Ab(n,e){if(n==null)return null;if(typeof n=="string")return Po(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];eD(e,r,i)?t.push(i):t.push(Ab(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=Po(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=Ab(r,s)}return t}}/** @license See the LICENSE file. */const tD="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const rZ=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Mi extends Kt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const S=this.getClassName().toLowerCase();this.name=ox(S)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Pa(this.inputs).length!==this.inputs.length)throw new ie(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(S=>S.name)}`);Pa(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(S=>S.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const S of this.outputs){const C=S.sourceLayer,_=S.nodeIndex,A=S.tensorIndex;this.outputLayers.push(C),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push(A)}for(const S of this.inputs){const C=S.sourceLayer,_=S.nodeIndex,A=S.tensorIndex;no(_===0,"input layer has >1 nodes"),no(A===0,"input layer has >1 tensors"),this.inputLayers.push(C),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push(A)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let S=0;S<this.inputLayers.length;S++){const C=this.inputLayers[S];if(!(C instanceof $f))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${S} (0-based) originates from layer type ${C.getClassName()}.`);this.inputNames.push(C.name),this.feedInputShapes.push(C.batchInputShape),this.feedInputNames.push(C.name)}for(const S of this.outputLayers)this.outputNames.push(S.name);this.internalInputShapes=this.inputs.map(S=>S.shape),this.internalOutputShapes=this.outputs.map(S=>S.shape);const t={},s={},r={},i={},o={},a=[],l=(S,C,_,A,k,N)=>{(A==null||k==null||N==null)&&(A=S.sourceLayer,k=S.nodeIndex,N=S.tensorIndex);const D=A.inboundNodes[k];if(_.indexOf(D)!==-1)throw new hi(`The tensor ${S.name} at layer "${A.name}" is part of a cycle.`);if(C.indexOf(D)!==-1)return;this.containerNodes.add(Mi.nodeKey(A,k)),A.id in o||(o[A.id]=Object.keys(o).length),_.indexOf(D)===-1&&_.push(D);const M=D.inboundLayers.length;for(let T=0;T<M;T++){const I=D.inputTensors[T],$=D.inboundLayers[T],O=D.nodeIndices[T],B=D.tensorIndices[T];l(I,C,_,$,O,B)}for(C.push(D);_.indexOf(D)>=0;)_.splice(_.indexOf(D),1);a.push(D)},c=[],h=[];for(const S of this.outputs)l(S,c,h);const d=a.slice().reverse();for(const S of d){s[S.id]=S,S.id in t||(t[S.id]=0);let C=t[S.id];const _=r[S.outboundLayer.id]==null?0:r[S.outboundLayer.id];C=Math.max(C,_),r[S.outboundLayer.id]=C,i[S.outboundLayer.id]=S.outboundLayer,t[S.id]=C;for(let A=0;A<S.inboundLayers.length;A++){const k=S.inboundLayers[A],N=S.nodeIndices[A],D=k.inboundNodes[N],M=t[D.id]==null?0:t[D.id];t[D.id]=Math.max(C+1,M),s[D.id]=D}}const p={};for(const S in t){const C=t[S];C in p||(p[C]=[]),p[C].push(s[S])}const m={};for(const S in r){const C=r[S];C in m||(m[C]=[]),m[C].push(i[S])}let g=Object.keys(m).map(S=>parseInt(S,10)).sort(Am);this.layers=[];for(const S of g){const C=m[S];C.sort((_,A)=>{const k=o[_.id],N=o[A.id];return k<N?-1:k>N?1:0});for(const _ of C)_ instanceof Mi&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=m,g=Object.keys(p).map(S=>parseInt(S,10)).sort(Am);const b=this.inputs.slice(),y=[];for(const S of g)for(const C of p[S]){const _=C.outboundLayer;if(_!=null){for(const A of C.inputTensors)if(b.indexOf(A)===-1)throw new hi(`Graph disconnected: cannot obtain value for tensor ${A} at layer "${_.name}". The following previous layers were accessed without issue: ${y}`);for(const A of C.outputTensors)b.push(A);y.push(_.name)}}this.nodesByDepth=p;const v=this.layers.map(S=>S.name);for(const S of v){const C=v.filter(_=>_===S).length;if(C!==1)throw new hi(`The name "${S}" is used ${C} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new lx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(S=>null),outputMasks:this.outputs.map(S=>null),inputShapes:this.inputs.map(S=>S.shape),outputShapes:this.outputs.map(S=>S.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ie("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=rZ(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const h=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[h]!=null)throw new ie(`Duplicate weight name: ${h}`);s[h]=c,r++}const o=[];for(const a in e){let l=a;if(s[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)o.push([s[l],e[a]]);else if(t)throw new ie(`Provided weight data has no target variable: ${a}`);delete s[l]}if(t){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new ie(`${a.length} of ${r} weights are not set: ${a}`)}__(o)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${tD}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=Ab(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return be(()=>{e=vn(e);const s=new Ra;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Kh(this.outputs,s,t)})}computeMask(e,t){return be(()=>{e=vn(e);let s;return t==null?s=tc(null,e.length):s=vn(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=yg(e);if(t.length!==this.inputLayers.length)throw new ie(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],h=l.name+"_0_0";s[h]=c}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Am);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const c of l){const h=c.outboundLayer;if(this.inputLayers.map(b=>b.id).indexOf(h.id)!==-1)continue;const d=[];for(let b=0;b<c.inboundLayers.length;b++){const y=c.inboundLayers[b],v=c.nodeIndices[b],S=c.tensorIndices[b],C=`${y.name}_${v}_${S}`,_=s[C];d.push(_)}const p=h.computeOutputShape(pr(d)),m=yg(p),g=h.inboundNodes.indexOf(c);for(let b=0;b<m.length;b++){const y=`${h.name}_${g}_${b}`;s[y]=m[b]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],h=this.outputLayersTensorIndices[a],d=`${l.name}_${c}_${h}`;o.push(d)}for(let a=0;a<o.length;a++){const l=o[a];no(l in s),i.push(s[l])}return pr(i)}runInternalGraph(e,t){t==null&&(t=tc(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],h=e[l],d=t[l];s[c.id]=[h,d]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Am);for(const l of r){const c=this.nodesByDepth[l];for(const h of c){const d=h.outboundLayer,p=h.inputTensors,m=h.outputTensors,g=new Array;for(const b of p)b.id in s&&g.push(s[b.id]);if(g.length===p.length){let b={},y,v,S,C;if(h.callArgs!=null&&(b=h.callArgs),g.length===1){const[_,A]=g[0];b.mask==null&&(b.mask=A),S=vn(d.call(_,b)),C=vn(d.computeMask(_,A)),y=[_],v=[A]}else y=g.map(_=>_[0]),v=g.map(_=>_[1]),b.mask==null&&(b.mask=v),S=vn(d.call(y,b)),C=vn(d.computeMask(y,v));if(d.activityRegularizer)throw new Wt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<m.length;++_){const A=m[_],k=S[_],N=C[_];s[A.id]=[k,N]}}}}const i=[],o=[],a=[];for(const l of this.outputs){no(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,h]=s[l.id];a.push(c.shape),i.push(c),o.push(h)}return[i,o,a]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof Mi?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=Mi.nodeKey(r,i);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new ie("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new ie(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new ie(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return be(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=Mi.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const p=o.inboundNodes[d],m=Mi.nodeKey(o,d);let g={};if(this.containerNodes.has(m)){if(p.callArgs)try{JSON.stringify(p.callArgs),g=p.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(p.inboundLayers.length>0){const b=[];for(let y=0;y<p.inboundLayers.length;y++){const v=p.inboundLayers[y],S=p.nodeIndices[y],C=p.tensorIndices[y],_=Mi.nodeKey(v,S);let A=t[_];A==null&&(A=0),b.push([v.name,A,C,g])}c.push(b)}}}const h={};h.name=o.name,h.className=a,h.config=l,h.inboundNodes=c,s.push(h)}e.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=Mi.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let h=t[c];h==null&&(h=0);const d=this.inputLayersTensorIndices[o];r.push([a.name,h,d])}e.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=Mi.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let h=t[c];h==null&&(h=0);const d=this.outputLayersTensorIndices[o];i.push([a.name,h,d])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},o={};function a(y,v){y.name in o?o[y.name].push(v):o[y.name]=[v]}function l(y,v){const S=[];let C;for(const _ of v){const A=_[0],k=_[1],N=_[2];if(C=_[3]==null?{}:_[3],!(A in i)){a(y,v);return}const D=i[A];if(D.inboundNodes.length<=k){a(y,v);return}const M=D.inboundNodes[k];S.push(M.outputTensors[N])}S.length>0&&y.apply(pr(S),C)}function c(y){const v=y.name,S=Go(y,t.customObjects!=null?t.customObjects:{});S.setFastWeightInitDuringBuild(r),i[v]=S,y.inboundNodes.forEach(_=>{if(!(_ instanceof Array))throw new ie(`Corrupted configuration, expected array for nodeData: ${_}`);a(S,_)})}const h=t.name,d=t.layers;for(const y of d)c(y);for(;!VK(o);)for(const y of d){const v=i[y.name];if(v.name in o){const S=o[v.name];delete o[v.name];for(const C of S)l(v,C)}}const p=[],m=[],g=t.inputLayers;for(const y of g){const v=y[0],S=y[1],C=y[2];no(v in i);const A=i[v].inboundNodes[S].outputTensors;p.push(A[C])}const b=t.outputLayers;for(const y of b){const v=y[0],S=y[1],C=y[2];no(v in i);const A=i[v].inboundNodes[S].outputTensors;m.push(A[C])}return new e({inputs:p,outputs:m,name:h})}get stateful(){if(this._stateful)throw new ie("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){be(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function iZ(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function nD(n,e){return iZ(n,e,"classWeight")}async function sD(n,e,t,s){if(t!=null){const r=be(()=>{if(n.shape.length===1)return zl(n);if(n.shape.length===2){if(n.shape[1]>1)return cd(n,1);if(n.shape[1]===1)return fe(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Yt(r);const o=[];return i.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),Dr(o,"float32")}else return null}function oZ(n,e){return oe(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const aZ=32;function rD(n,e){let t,s;const r=e;t=r.xs,s=r.ys,W(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=O2("input",n.inputNames,t),o=O2("output",n.outputNames,s),a=i[0].shape[0];W(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),W(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)W(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)W(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function O2(n,e,t){if(t instanceof as)return[t];if(Array.isArray(t))return W(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new ie(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function lZ(n){if(n.length===3)throw new Wt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function cZ(n,e,t){const s=t.batchesPerEpoch!=null;if(W(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),W(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),W(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),W(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),W(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,o;if(r)if(U2(t.validationData))W(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const y=lZ(t.validationData);i=y.xs,o=y.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;r?c=l.slice().concat(l.map(y=>"val_"+y)):c=l.slice();const h=jN(t.callbacks,t.yieldEvery),d=t.verbose==null?1:t.verbose,{callbackList:p,history:m}=qN(h,d,t.epochs,null,null,uZ(e,t),null,r,c);p.setModel(n),n.history=m,await p.onTrainBegin(),n.stopTraining_=!1;let g=t.initialEpoch==null?0:t.initialEpoch,b=await e.iterator();for(;g<t.epochs;){const y={};await p.onEpochBegin(g);let v=0,S=0;for(s||(b=await e.iterator());!s||v<t.batchesPerEpoch;){const C=await b.next();if(s&&C.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(C.value!=null){const{xs:_,ys:A}=rD(n,C.value),k={};k.batch=S,k.size=_[0].shape[0],await p.onBatchBegin(S,k);const N=[];if(t.classWeight!=null){const T=nD(t.classWeight,n.outputNames);for(let I=0;I<T.length;++I)N.push(await sD(A[I],null,T[I]))}const D=_.concat(A).concat(N),M=a(D);Yt(D);for(let T=0;T<l.length;++T){const I=l[T],$=M[T];k[I]=$,co($)}await p.onBatchEnd(S,k),XN(k),S++,v++}if(s?v>=t.batchesPerEpoch:C.done){if(r){let _;U2(t.validationData)?_=vn(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):_=vn(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?aZ:t.validationBatchSize,verbose:0}));for(let A=0;A<n.metricsNames.length;++A)y[`val_${n.metricsNames[A]}`]=_[A]}break}if(n.stopTraining_)break}if(await p.onEpochEnd(g,y),g++,n.stopTraining_)break}return await p.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function uZ(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function U2(n){return typeof n.iterator=="function"}function hZ(n){return typeof n.next=="function"}async function dZ(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new Wt("Verbose mode is not implemented yet.");W(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=hZ(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<t.batches;){const c=await o.next();if(i=be(()=>{if(c.value){const{xs:h,ys:d}=rD(n,c.value),p=h.concat(d),m=be(()=>r(p));if(Yt(p),l===0)for(let b=0;b<m.length;++b)i.push(en(0));const g=p[0].shape[0];for(let b=0;b<m.length;++b){const y=m[b],v=i[b];i[b]=be(()=>je(i[b],oe(g,y))),l>0&&Yt(v)}Yt(m),a+=g,++l}return i}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const h=i[c];i[c]=At(i[c],a),Yt(h)}return pr(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jy(n){W(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Wh(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Vl(s,e,t-e)):Vl(n,e,t-e)}function Mb(n,e){return be(()=>n==null?null:Array.isArray(n)?n.map(t=>Mb(t,e)):NN(n,e.dtype==="int32"?e:at(e,"int32")))}function e1(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function iD(n){const e=[];n instanceof as&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(kf(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Ai(n,e){if(n==null)return;const t=[];if(e instanceof as)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof as)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fZ(n){return n instanceof as}function Rb(n){return Array.isArray(n)}function z2(n){return!fZ(n)&&!Rb(n)}function B2(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(Rb(n)&&n.length>0)o=!0;else if(z2(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new ie(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(z2(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new ie(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(Rb(n)){if(n=n,n.length!==e.length)throw new ie(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new ie(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=iD(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new ie(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],h=t[o][l];if(h!=null&&h>=0&&c!==h)throw new ie(`${r} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function pZ(n,e,t){const s=Pa(n.map(i=>i.shape[0]));s.sort();const r=Pa(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new ie(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new ie(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!mn(s,r))throw new ie(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function mZ(n,e,t){const s=[cx,ux,md];for(let r=0;r<n.length;++r){const i=n[r],o=e[r],a=t[r];if(o!=null){if(o===md&&i.shape[i.shape.length-1]===1)throw new ie(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let h=0;h<l.length;++h){const d=l[h],p=c[h];if(p!=null&&d!==p)throw new ie(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function V2(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new ie(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new ie(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new ie(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],h=t[o][l];if(h!=null&&h!==c)throw new ie(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function gZ(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const xZ="layers-model";class pu extends Mi{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new ie("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");JY(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=QY(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof el))throw new ie("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new ie(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(Qy(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ie(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>Qy(a))}else{const o=Qy(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Bl("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=gZ(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Bl("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=r[o];(c=>{const h="";let d,p,m;for(const g of c){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){const y=this.internalOutputShapes[o];y[y.length-1]===1||this.lossFunctions[o]===ux?["accuracy","acc"].indexOf(g)!==-1?p=YN:["crossentropy","ce"].indexOf(g)!==-1&&(p=VY):this.lossFunctions[o]===Cg?["accuracy","acc"].indexOf(g)!==-1?p=GY:["crossentropy","ce"].indexOf(g)!==-1&&(p=JN):["accuracy","acc"].indexOf(g)!==-1?p=ZN:["crossentropy","ce"].indexOf(g)!==-1&&(p=QN);let v;["accuracy","acc"].indexOf(g)!==-1?v="acc":["crossentropy","ce"].indexOf(g)!==-1&&(v="ce"),m=p,d=h+v}else m=ZY(g),d=h+km(g);let b;Bl(d,()=>{b=m}),i(o,d,b)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;Jy(r);const o=this.standardizeUserDataXY(e,t,!0,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,r,s.verbose,s.steps);return pr(c)}finally{Ai(o[0],e),Ai(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),dZ(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new ie(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new ie(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ie("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),o=new Ra;if(e instanceof as&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ie(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new ie(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=Kh(i,o);return s?a:a[0]}retrieveSymbolicTensors(e){const t=tc(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,o)=>{i==null&&r.push(e[o])}),new ie(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return be(()=>{const r=this.checkNumSamples(e);if(s)throw new Wt("Verbose predictLoop() is not implemented yet.");const i=e1(r,t),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)be(()=>{const c=i[a][0],h=i[a][1],d=Wh(e,c,h),p=[];if(Array.isArray(d))for(let g=0;g<d.length;++g)p.push({key:this.inputs[g],value:d[g]});else p.push({key:this.inputs[0],value:d});const m=new Ra(p);return Kh(this.outputs,m)}).forEach((c,h)=>o[h].push(c));return pr(o.map(a=>xr(a,0)))})}predict(e,t={}){const s=iD(e);V2(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return Jy(r),this.predictLoop(s,r)}finally{Ai(s,e)}}predictOnBatch(e){V2(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new hi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===Cg?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=B2(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=B2(t,this.feedOutputNames,i,!1,"target"),pZ(e,t),mZ(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new ie(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const h=nD(r,this.outputNames);c=[];for(let d=0;d<h.length;++d)c.push(await sD(l[d],null,h[d]))}return[a,l,c]}testLoop(e,t,s,r=0,i){return be(()=>{const o=this.checkNumSamples(t,s,i,"steps"),a=[];if(r>0)throw new Wt("Verbose mode is not implemented yet.");if(i!=null)throw new Wt("steps mode in testLoop() is not implemented yet");{const l=e1(o,s),c=Dr(zi(0,o));for(let h=0;h<l.length;++h){const d=l[h][0],p=l[h][1],m=Vl(c,d,p-d),g=Mb(t,m),b=e(g);if(h===0)for(let y=0;y<b.length;++y)a.push(en(0));for(let y=0;y<b.length;++y){const v=b[y];a[y]=je(a[y],oe(p-d,v))}}for(let h=0;h<a.length;++h)a[h]=At(a[h],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(T2(e,r)>1){const o=T2(e.slice(0,s),r);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const d=[];for(let b=0;b<this.inputs.length;++b)d.push({key:this.inputs[b],value:s[b]});const p=new Ra(d),m=Kh(this.outputs,p,{training:!0});let g;for(let b=0;b<this.lossFunctions.length;++b){const y=this.lossFunctions[b];let v=y(r[b],m[b]);i[b]!=null&&(v=oZ(v,i[b]));const S=ss(v);t.push(S),b===0?g=v:g=je(g,v)}for(let b=0;b<this.metricsTensors.length;++b){let y;if(this.outputs.length>1&&b<this.outputs.length)y=t[b];else{const v=this.metricsTensors[b][0],S=this.metricsTensors[b][1];y=ss(v(r[S],m[S]))}co(y),o.push(y)}return g=ss(g),this.calculateLosses().forEach(b=>{g=je(g,b)}),g},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>be(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:r[c]});const a=new Ra(o),l=Kh(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const h=this.lossFunctions[c],d=ss(h(i[c],l[c]));c===0?s=d:s=je(s,d),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][0],d=this.metricsTensors[c][1],p=ss(h(i[d],l[d]));t.push(p)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,a,l,c,h,d,p;try{const m=s.batchSize==null?32:s.batchSize;Jy(m);const b=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,m);r=b[0],i=b[1],p=b[2];let y=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(y=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new Wt("validationData including sample weights is not supported yet."):new ie(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const T=await this.standardizeUserData(l,c,null,null,!0,m);h=T[0],d=T[1],v=h.concat(d)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){y=!0;const M=Math.floor(r[0].shape[0]*(1-s.validationSplit)),T=r[0].shape[0];h=Wh(r,M,T),o=r,r=Wh(r,0,M),d=Wh(i,M,T),a=i,i=Wh(i,0,M),v=h.concat(d)}else s.validationSteps!=null&&(y=!0);const S=r.concat(i).concat(p);this.checkTrainableWeightsConsistency();const C=this.makeTrainFunction(),_=this.getDedupedMetricsNames();let A,k;y?(this.makeTestFunction(),A=this.testFunction,k=_.slice().concat(_.map(M=>"val_"+M))):(A=null,v=[],k=_.slice());const N=jN(s.callbacks,s.yieldEvery);return await this.fitLoop(C,S,_,m,s.epochs,s.verbose,N,A,v,s.shuffle,k,s.initialEpoch,null,null)}finally{this.isTraining=!1,Ai(r,e),Ai(i,t),Ai(o,e),Ai(a,t),Ai(h,l),Ai(d,c),p!=null&&Yt(p)}}async fitLoop(e,t,s,r,i,o,a,l,c,h,d,p,m,g){r==null&&(r=32),i==null&&(i=1),h==null&&(h=!0),p==null&&(p=0);let b=!1;if(l!=null&&c!=null&&(b=!0),g!=null&&(b=!0,m==null))throw new ie("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const y=this.checkNumSamples(t,r,m,"steps_per_epoch");let v;y!=null&&(v=zi(0,y)),o==null&&(o=1);const{callbackList:S,history:C}=qN(a,o,i,p,y,m,r,b,d);S.setModel(this),this.history=C,await S.onTrainBegin(),this.stopTraining_=!1;for(let _=p;_<i;++_){await S.onEpochBegin(_);const A={};if(m!=null)throw new Wt("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new Wt("batch shuffling is not implemneted yet");h&&e5(v);const k=Dr(v),N=e1(y,r);for(let D=0;D<N.length;++D){const M={};if(await S.onBatchBegin(D,M),be(()=>{const T=N[D][0],I=N[D][1],$=Vl(k,T,I-T);M.batch=D,M.size=I-T;const O=Mb(t,$),B=e(O);for(let V=0;V<s.length;++V){const H=s[V],q=B[V];M[H]=q,co(q)}if(D===N.length-1&&b){const V=this.testLoop(l,c,r);for(let H=0;H<s.length;++H){const q=s[H],P=V[H];co(P),A["val_"+q]=P}}}),await S.onBatchEnd(D,M),XN(M),this.stopTraining_)break}k.dispose()}if(await S.onEpochEnd(_,A),this.stopTraining_)break}return await S.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return cZ(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],a=this.makeTrainFunction()(r.concat(i)),l=[];for(const c of a){const h=await c.data();l.push(h[0])}return Yt(a),Ai(s[0],e),Ai(s[1],t),pr(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||t.push({name:r[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=JI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-JI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Po(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Po(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=Po(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Po(km(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Po(km(e)));{const e={};for(const t in this.metrics)e[t]=Po(km(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Ib(e.optimizer_config),s=Go(t);let r;if(typeof e.loss=="string")r=Dl(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>Dl(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=Dl(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Dl(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Dl(e.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const c=K5(e);if(c.length===0)throw new ie(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new ie(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new ie("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await t2(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:xZ,generatedBy:`TensorFlow.js tfjs-layers v${tD}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:h,specs:d}=await t2(await this.optimizer.getWeights(),c);s.specs.push(...d),s.data=q5([s.data,h])}return this.userDefinedMetadata!=null&&(P2(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){P2(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}pu.className="Model";Ue(pu);class oD extends pu{}oD.className="Functional";Ue(oD);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class gd extends pu{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:ox("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ie(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof gd||e instanceof pu;let s;if(t){if(s=e,s.outputs.length!==1)throw new ie("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ie("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ie("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=yY({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ie(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ie("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=BN(this.outputs[0])}this.inboundNodes=[],new lx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:tc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(ln(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new pu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new ie("Legacy serialization format not supported yet.");i=t}else W(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof gd))throw new Wt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const h=Go(l,void 0,r);r&&h.setFastWeightInitDuringBuild(!0),a.add(h)}return a}set stopTraining(e){if(this.model==null)throw new ie("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ie("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}gd.className="Sequential";Ue(gd);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Gs=class extends Hu{getConfig(){return{}}};class aD extends Gs{apply(e,t=1){return sY(e,t)}}aD.className="elu";Ue(aD);class lD extends Gs{apply(e){return Ek(e)}}lD.className="selu";Ue(lD);class cD extends Gs{apply(e){return cc(e)}}cD.className="relu";Ue(cD);class uD extends Gs{apply(e){return be(()=>dd(6,cc(e)))}}uD.className="relu6";Ue(uD);class hD extends Gs{apply(e){return e}}hD.className="linear";Ue(hD);class dD extends Gs{apply(e){return Vu(e)}}dD.className="sigmoid";Ue(dD);class fD extends Gs{apply(e){return iY(e)}}fD.className="hardSigmoid";Ue(fD);class pD extends Gs{apply(e){return _f(e)}}pD.className="softplus";Ue(pD);class mD extends Gs{apply(e){return rY(e)}}mD.className="softsign";Ue(mD);class gD extends Gs{apply(e){return Y0(e)}}gD.className="tanh";Ue(gD);let I_=class extends Gs{apply(e,t=-1){return Rw(e,t)}};I_.className="softmax";Ue(I_);class xD extends Gs{apply(e,t=-1){return xk(e,t)}}xD.className="logSoftmax";Ue(xD);class vD extends Gs{apply(e){return be(()=>be(()=>{const t=Math.sqrt(2),s=oe(.5,je(1,dk(At(e,t))));return oe(e,s)}))}}vD.className="gelu";Ue(vD);class yD extends Gs{apply(e){return be(()=>oe(.5,oe(e,je(1,Y0(oe(Bs(At(2,Math.PI)),je(e,oe(.044715,Ql(e,3)))))))))}}yD.className="gelu_new";Ue(yD);class bD extends Gs{apply(e){return be(()=>oe(e,Y0(_f(e))))}}bD.className="mish";Ue(bD);class SD extends Gs{apply(e,t=1){return be(()=>oe(Vu(oe(e,t)),e))}}SD.className="swish";Ue(SD);function Ga(n){return n.getClassName()}function t1(n,e={}){return Rf(n,ui.getMap().classNameMap,e,"activation")}function Wa(n){if(n==null){const e={};return e.className="linear",e.config={},t1(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},t1(e)}else return n instanceof Gs?n:t1(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vZ(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class wD extends Hu{}class _D extends wD{constructor(e){super(),vZ(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return be(()=>{let t=ls([1]);return this.hasL1&&(t=je(t,It(oe(this.l1,er(e))))),this.hasL2&&(t=je(t,It(oe(this.l2,Nf(e))))),fe(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}_D.className="L1L2";Ue(_D);const G2={l1l2:"L1L2"};function _n(n){return f_(n)}function W2(n,e={}){return Rf(n,ui.getMap().classNameMap,e,"regularizer")}function Fn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in G2?G2[n]:n,config:{}};return W2(t)}else return n instanceof wD?n:W2(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class CD extends Kt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Dt(e);let s=cc(e);return this.maxValue!=null&&(s=qr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}CD.className="ReLU";Ue(CD);class ED extends Kt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Dt(e);return bw(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}ED.className="LeakyReLU";Ue(ED);class TD extends Kt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=$n(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Fn(e.alphaRegularizer),this.alphaConstraint=ds(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ie(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=ln(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new us({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Dt(e),Tw(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Un(this.alphaInitializer),alphaRegularizer:_n(this.alphaRegularizer),alphaConstraint:hs(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}TD.className="PReLU";Ue(TD);let ID=class extends Kt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Wt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Dt(e);return J0(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};ID.className="ELU";Ue(ID);class AD extends Kt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Dt(e);return oe(s,at(Kr(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}AD.className="ThresholdedReLU";Ue(AD);class MD extends Kt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new I_().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return be(()=>{let s=Dt(e);const r=t.mask;if(r!=null){const i=oe(Nt(Ja(s.shape),at(r,s.dtype)),en(-1e9));s=je(s,i)}return this.axis instanceof Array?this.axis.length>1?go(Nt(s,vk(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}MD.className="Softmax";Ue(MD);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mu(n,e,t){if(typeof n=="number")return tc(n,e);if(n.length!==e)throw new ie(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!JK(r))throw new ie(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Oi(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function so(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Va([t-e,0]);else if(s==="same")n=n*e;else throw new ie(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function A_(n,e){return be(()=>(Zn(e),e==="channelsFirst"?sn(n,[0,2,3,1]):n))}function RD(n,e){return be(()=>(Zn(e),e==="channelsFirst"?sn(n,[0,2,3,4,1]):n))}function yZ(n,e,t,s=1,r="valid",i,o=1){return be(()=>{if(i==null&&(i=Bi()),Zn(i),n.shape.length!==3)throw new ie(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new ie(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new ie(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=sn(n,[0,2,1])),r==="causal")throw new Wt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=ak(n,e,s,r==="same"?"same":"valid","NWC",o);return t!=null&&(a=Gi(a,t)),a})}function H2(n,e,t,s=[1,1],r="valid",i,o,a=null){return be(()=>{if(i==null&&(i=Bi()),Zn(i),n.rank!==3&&n.rank!==4)throw new ie(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ie(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=A_(n,i);if(r==="causal")throw new Wt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=A7({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),i==="channelsFirst"&&(l=sn(l,[0,3,1,2])),l})}function bZ(n,e,t,s=[1,1,1],r="valid",i,o){return be(()=>{if(i==null&&(i=Bi()),Zn(i),n.rank!==4&&n.rank!==5)throw new ie(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ie(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=RD(n,i);if(r==="causal")throw new Wt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=gb(a,e,s,r==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Gi(a,t)),i==="channelsFirst"&&(a=sn(a,[0,4,1,2,3])),a})}class hx extends Kt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",hx.verifyArgs(t),this.rank=e,ys(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Wt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=mu(t.kernelSize,e,"kernelSize"),this.strides=mu(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Yr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Zn(this.dataFormat),this.activation=Wa(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=$n(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ds(t.biasConstraint),this.biasRegularizer=Fn(t.biasRegularizer),this.activityRegularizer=Fn(t.activityRegularizer),this.dilationRate=mu(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ie(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ie(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ie(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(no("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!p_(e.kernelSize,"number",1,3))throw new ie(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ga(this.activation),useBias:this.useBias,biasInitializer:Un(this.biasInitializer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),biasConstraint:hs(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Xu extends hx{constructor(e,t){super(e,t),this.kernel=null,Xu.verifyArgs(t),this.filters=t.filters,ys(this.filters,"filters"),this.kernelInitializer=$n(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ds(t.kernelConstraint),this.kernelRegularizer=Fn(t.kernelRegularizer)}build(e){e=ln(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ie(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return be(()=>{e=Dt(e);let s;const r=this.bias==null?null:this.bias.read(),i=TN(this.activation.getClassName());if(i!=null&&this.rank===2)s=H2(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=yZ(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=H2(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=bZ(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Wt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=ln(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const o=Oi(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Un(this.kernelInitializer),kernelRegularizer:_n(this.kernelRegularizer),kernelConstraint:hs(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ie(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Lf extends Xu{constructor(e){super(2,e),Lf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!p_(e.kernelSize,"number",1,2))throw new ie(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Lf.className="Conv2D";Ue(Lf);class Pf extends Xu{constructor(e){super(3,e),Pf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ie(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Pf.className="Conv3D";Ue(Pf);class kD extends Lf{constructor(e){if(super(e),this.inputSpec=[new us({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ie(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ln(e),e.length!==4)throw new ie("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ie("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new us({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return be(()=>{let s=Dt(e);if(s.shape.length!==4)throw new ie(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],c=r[a],h=this.kernelSize[0],d=this.kernelSize[1],p=this.strides[0],m=this.strides[1],g=so(l,p,h,this.padding),b=so(c,m,d,this.padding),y=[i,g,b,this.filters];this.dataFormat!=="channelsLast"&&(s=sn(s,[0,2,3,1]));let v=lk(s,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=sn(v,[0,3,1,2])),this.bias!=null&&(v=Gi(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=ln(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[r]=so(t[r],l,o,this.padding),t[i]=so(t[i],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}kD.className="Conv2DTranspose";Ue(kD);class ND extends Pf{constructor(e){if(super(e),this.inputSpec=[new us({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ie(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ln(e),e.length!==5)throw new ie("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ie("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new us({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return be(()=>{let s=Dt(e);if(s.shape.length!==5)throw new ie(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=r[l],h=r[o],d=r[a],p=this.kernelSize[0],m=this.kernelSize[1],g=this.kernelSize[2],b=this.strides[0],y=this.strides[1],v=this.strides[2],S=so(c,b,p,this.padding),C=so(h,y,m,this.padding),_=so(d,v,g,this.padding),A=[i,S,C,_,this.filters];this.dataFormat!=="channelsLast"&&(s=sn(s,[0,2,3,4,1]));let k=I8(s,this.kernel.read(),A,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=sn(k,[0,4,1,2,3])),this.bias!==null&&(k=Gi(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=ln(e);const t=e.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],h=this.strides[0],d=this.strides[1],p=this.strides[2];return t[s]=this.filters,t[r]=so(t[r],h,a,this.padding),t[i]=so(t[i],d,l,this.padding),t[o]=so(t[o],p,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}ND.className="Conv3DTranspose";Ue(ND);class DD extends Xu{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ie("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ie("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ie(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=$n(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Fn(t.depthwiseRegularizer),this.depthwiseConstraint=ds(t.depthwiseConstraint),this.pointwiseInitializer=$n(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Fn(t.pointwiseRegularizer),this.pointwiseConstraint=ds(t.pointwiseConstraint)}build(e){if(e=ln(e),e.length<this.rank+2)throw new ie(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ie(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new us({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return be(()=>{e=Dt(e);let s;if(this.rank===1)throw new Wt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=sn(e,[0,2,3,1])),s=Tk(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Gi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=sn(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Un(this.depthwiseInitializer),e.pointwiseInitializer=Un(this.pointwiseInitializer),e.depthwiseRegularizer=_n(this.depthwiseRegularizer),e.pointwiseRegularizer=_n(this.pointwiseRegularizer),e.depthwiseConstraint=hs(this.depthwiseConstraint),e.pointwiseConstraint=hs(this.pointwiseConstraint),e}}DD.className="SeparableConv";class $D extends DD{constructor(e){super(2,e)}}$D.className="SeparableConv2D";Ue($D);class dx extends Xu{constructor(e){super(1,e),dx.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!p_(e.kernelSize,"number",1,1))throw new ie(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}dx.className="Conv1D";Ue(dx);class FD extends Kt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return be(()=>{if(e=Dt(e),this.dataFormat==="channelsLast"){const s=Rm(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Rm(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Rm(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Rm(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}FD.className="Cropping2D";Ue(FD);class LD extends Kt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,YK(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return be(()=>{let s=Dt(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=sn(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?Bo.resizeNearestNeighbor(s,[i,o]):Bo.resizeBilinear(s,[i,o]);return sn(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Bo.resizeNearestNeighbor(s,[i,o]):Bo.resizeBilinear(s,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}LD.className="UpSampling2D";Ue(LD);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function SZ(n,e,t=[1,1],s="valid",r,i){return be(()=>{r==null&&(r=Bi()),Zn(r);let o=A_(n,r);if(n.rank!==4)throw new ie(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new ie(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=gw(o,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=sn(o,[0,3,1,2])),o})}class PD extends hx{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=$n(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ds(e.depthwiseConstraint),this.depthwiseRegularizer=Fn(e.depthwiseRegularizer)}build(e){if(e=ln(e),e.length<4)throw new ie(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ie(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{e=Dt(e);let s=SZ(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Gi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=ln(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Oi(t,this.kernelSize[0],this.padding,this.strides[0]),o=Oi(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,o]:[e[0],i,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Un(this.depthwiseInitializer),e.depthwiseRegularizer=_n(this.depthwiseRegularizer),e.depthwiseConstraint=hs(this.depthwiseRegularizer),e}}PD.className="DepthwiseConv2D";Ue(PD);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function OD(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new ie("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function UD(n,e,t,s=!1,r,i,o=!1,a=!1){return be(()=>{const l=e.shape.length;if(l<3)throw new ie(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(zi(2,l));e=sn(e,c),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=at(at(r,"bool"),"float32"),r.rank===l-1&&(r=fr(r,-1)),r=sn(r,c)),s&&(e=Jl(e,0),r!=null&&(r=Jl(r,0)));const h=[];let d,p=t;const m=e.shape[0],g=ec(e);let b;r!=null&&(b=ec(r));for(let v=0;v<m;++v){const S=g[v],C=be(()=>n(S,p));if(r==null)d=C[0],p=C[1];else{const _=be(()=>{const A=b[v],k=Nt(mi(A),A),N=je(oe(C[0],A),oe(p[0],k)),D=p.map((M,T)=>je(oe(C[1][T],A),oe(M,k)));return{output:N,newStates:D}});d=_.output,p=_.newStates}a&&h.push(d)}let y;return a&&(y=Xo(h,1)),[d,y,p]})}class tl extends Kt{constructor(e){super(e);let t;if(e.cell==null)throw new ie("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new k_({cells:e.cell}):t=e.cell,t.stateSize==null)throw new ie("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new us({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return zi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Cb(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[r].concat(i)}else return r}computeMask(e,t){return be(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Wt("Constants support is not implemented in RNN yet.");Cb(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new us({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!mn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new ie(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new us({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){be(()=>{if(!this.stateful)throw new to("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ie("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>ls([s,r])):this.states_=[ls([s,this.cell.stateSize])];else if(e==null)Yt(this.states_),this.keptStates!=null&&(Yt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>ls([s,r])):this.states_[0]=ls([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ie(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Yt(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,o];if(!mn(i.shape,a))throw new ie(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>co(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=OD(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let o=[],a=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new us({shape:c.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof vo){const c=[e].concat(o),h=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=h;const p=super.apply(c,t);return this.inputSpec=d,p}else return super.apply(e,t)}call(e,t){return be(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=Dt(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new ie(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},c=UD((g,b)=>{const y=this.cell.call([g].concat(b),a);return[y[0],y.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),h=c[0],d=c[1],p=c[2];this.stateful&&this.resetStates(p,r);const m=this.returnSequences?d:h;return this.returnState?[m].concat(p):m})}getInitialState(e){return be(()=>{let t=ls(e.shape);return t=It(t,[1,2]),t=kf(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?wb(t,[1,s]):t):this.cell.stateSize>1?[wb(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===tl.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=Go(r,s);return new e(Object.assign(t,{cell:i}))}}tl.className="RNN";Ue(tl);class fx extends Kt{}class M_ extends fx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ys(this.units,"units"),this.activation=Wa(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Fn(e.kernelRegularizer),this.recurrentRegularizer=Fn(e.recurrentRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.kernelConstraint=ds(e.kernelConstraint),this.recurrentConstraint=ds(e.recurrentConstraint),this.biasConstraint=ds(e.biasConstraint),this.dropout=Tu([1,Va([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Tu([1,Va([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ln(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{if(e=e,e.length!==2)throw new ie(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ha({ones:()=>mi(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ha({ones:()=>mi(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=fo(oe(e,o),this.kernel.read()):i=fo(e,this.kernel.read()),this.bias!=null&&(i=Gi(i,this.bias.read())),a!=null&&(s=oe(s,a));let l=je(i,fo(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ga(this.activation),useBias:this.useBias,kernelInitializer:Un(this.kernelInitializer),recurrentInitializer:Un(this.recurrentInitializer),biasInitializer:Un(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:hs(this.kernelConstraint),recurrentConstraint:hs(this.recurrentConstraint),biasConstraint:hs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}M_.className="SimpleRNNCell";Ue(M_);class zD extends tl{constructor(e){e.cell=new M_(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}zD.className="SimpleRNN";Ue(zD);class R_ extends fx{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ie("GRUCell does not support reset_after parameter set to true.");this.units=e.units,ys(this.units,"units"),this.activation=Wa(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Wa(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Fn(e.kernelRegularizer),this.recurrentRegularizer=Fn(e.recurrentRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.kernelConstraint=ds(e.kernelConstraint),this.recurrentConstraint=ds(e.recurrentConstraint),this.biasConstraint=ds(e.biasConstraint),this.dropout=Tu([1,Va([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Tu([1,Va([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ln(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{if(e=e,e.length!==2)throw new ie(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ha({ones:()=>mi(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ha({ones:()=>mi(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=oe(e,i[0]));let h=fo(e,this.kernel.read());this.useBias&&(h=Gi(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oe(r,o[0]));const d=this.recurrentKernel.read(),[p,m]=jr(d,[2*this.units,this.units],d.rank-1),g=fo(r,p),[b,y,v]=jr(h,3,h.rank-1),[S,C]=jr(g,2,g.rank-1);a=this.recurrentActivation.apply(je(b,S)),l=this.recurrentActivation.apply(je(y,C));const _=fo(oe(l,r),m);c=this.activation.apply(je(v,_));const A=je(oe(a,r),oe(je(1,qn(a)),c));return[A,A]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ga(this.activation),recurrentActivation:Ga(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Un(this.kernelInitializer),recurrentInitializer:Un(this.recurrentInitializer),biasInitializer:Un(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:hs(this.kernelConstraint),recurrentConstraint:hs(this.recurrentConstraint),biasConstraint:hs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}R_.className="GRUCell";Ue(R_);class BD extends tl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new R_(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}BD.className="GRU";Ue(BD);class px extends fx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ys(this.units,"units"),this.activation=Wa(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Wa(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Fn(e.kernelRegularizer),this.recurrentRegularizer=Fn(e.recurrentRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.kernelConstraint=ds(e.kernelConstraint),this.recurrentConstraint=ds(e.recurrentConstraint),this.biasConstraint=ds(e.biasConstraint),this.dropout=Tu([1,Va([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Tu([1,Va([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=ln(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(t=class extends xi{apply(l,c){const h=i.apply([o]),d=new g_().apply([o]),p=i.apply([o*2]);return A2(A2(h,d),p)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return be(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ie(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ha({ones:()=>mi(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ha({ones:()=>mi(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,h,d;0<this.dropout&&this.dropout<1&&(e=oe(e,o[0]));let p=fo(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oe(r,a[0])),p=je(p,fo(r,this.recurrentKernel.read())),this.useBias&&(p=Gi(p,this.bias.read()));const[m,g,b,y]=jr(p,4,p.rank-1);l=this.recurrentActivation.apply(m),c=this.recurrentActivation.apply(g),h=je(oe(c,i),oe(l,this.activation.apply(b))),d=this.recurrentActivation.apply(y);const v=oe(d,this.activation.apply(h));return[v,v,h]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Ga(this.activation),recurrentActivation:Ga(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Un(this.kernelInitializer),recurrentInitializer:Un(this.recurrentInitializer),biasInitializer:Un(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:hs(this.kernelConstraint),recurrentConstraint:hs(this.recurrentConstraint),biasConstraint:hs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}px.className="LSTMCell";Ue(px);class VD extends tl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new px(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}VD.className="LSTM";Ue(VD);class k_ extends fx{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return be(()=>{e=e;let s=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,t),i.push(o.slice(1))}s=[];for(const a of i.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(e){Cb(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Bl(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(Go(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Eb(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],i[o]])}__(t)}}k_.className="StackedRNNCells";Ue(k_);function Ha(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):DN(e(),t),a=()=>Df(o,e,s);return!r||r<=1?co(a().clone()):Array(r).fill(void 0).map(a).map(c=>co(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var wZ=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class GD extends tl{constructor(e){if(e.unroll)throw new Wt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Wt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new us({ndim:5})]}call(e,t){return be(()=>{if(this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ie("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return be(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=ls(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){be(()=>{if(!this.stateful)throw new to("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new ie("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ls(i)):this.states_=[ls(i)];else if(e==null)Yt(this.states_),this.keptStates!=null&&(Yt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ls(i)):this.states_[0]=ls(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ie(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Yt(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=i;if(!mn(l.shape,c))throw new ie(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>co(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],h=e[l?4:3],d=Oi(c,r[0],i,o[0],a[0]),p=Oi(h,r[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[s,d,p]:[d,p,s]]}}GD.className="ConvRNN2D";class N_ extends px{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,ys(this.filters,"filters"),this.kernelSize=mu(s,2,"kernelSize"),this.kernelSize.forEach(l=>ys(l,"kernelSize")),this.strides=mu(r||1,2,"strides"),this.strides.forEach(l=>ys(l,"strides")),this.padding=i||"valid",Yr(this.padding),this.dataFormat=o||"channelsLast",Zn(this.dataFormat),this.dilationRate=mu(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>ys(l,"dilationRate"))}build(e){var t;e=ln(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ie(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,h=this.filters;l=new(t=class extends xi{apply(p,m){const g=c.apply([h]),b=Ja([h]),y=c.apply([h*2]);return m_([g,b,y])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return be(()=>{if(e.length!==3)throw new ie(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ha({ones:()=>mi(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(Z,U,z)=>!U||!U[z]?Z:oe(U[z],Z);let h=c(r,l,0),d=c(r,l,1),p=c(r,l,2),m=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ha({ones:()=>mi(i),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let b=c(i,g,0),y=c(i,g,1),v=c(i,g,2),S=c(i,g,3);const C=3,[_,A,k,N]=jr(this.kernel.read(),a,C),[D,M,T,I]=this.useBias?jr(this.bias.read(),a):[null,null,null,null];h=this.inputConv(h,_,D,this.padding),d=this.inputConv(d,A,M,this.padding),p=this.inputConv(p,k,T,this.padding),m=this.inputConv(m,N,I,this.padding);const[$,O,B,V]=jr(this.recurrentKernel.read(),a,C);b=this.recurrentConv(b,$),y=this.recurrentConv(y,O),v=this.recurrentConv(v,B),S=this.recurrentConv(S,V);const H=this.recurrentActivation.apply(je(h,b)),q=this.recurrentActivation.apply(je(d,y)),P=je(oe(q,o),oe(H,this.activation.apply(je(p,v)))),K=oe(this.recurrentActivation.apply(je(m,S)),this.activation.apply(P));return[K,K,P]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=wZ(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=Zl(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Gi(i,s,this.dataFormat):i}recurrentConv(e,t){return Zl(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}N_.className="ConvLSTM2DCell";Ue(N_);class WD extends GD{constructor(e){const t=new N_(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}WD.className="ConvLSTM2D";Ue(WD);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class D_ extends Kt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=Dt(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return Df(()=>DN(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}D_.className="Dropout";Ue(D_);class HD extends D_{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}HD.className="SpatialDropout1D";Ue(HD);class XD extends Kt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,ys(this.units,"units"),this.activation=Wa(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ds(e.kernelConstraint),this.biasConstraint=ds(e.biasConstraint),this.kernelRegularizer=Fn(e.kernelRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.activityRegularizer=Fn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=ln(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=ln(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=Dt(e),r=TN(this.activation.getClassName());let i;return r!=null?i=fo(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=fo(s,this.kernel.read()),this.bias!=null&&(i=Gi(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Ga(this.activation),useBias:this.useBias,kernelInitializer:Un(this.kernelInitializer),biasInitializer:Un(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:hs(this.kernelConstraint),biasConstraint:hs(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}XD.className="Dense";Ue(XD);class jD extends Kt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=ln(e);for(const t of e.slice(1))if(t==null)throw new ie(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Oa(e,1)]}call(e,t){return be(()=>{this.invokeCallHook(e,t);let s=Dt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=sn(s,r)}return nY(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}jD.className="Flatten";Ue(jD);class qD extends Kt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Wa(e.activation)}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=Dt(e);return this.activation.apply(s)})}getConfig(){const e={activation:Ga(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}qD.className="Activation";Ue(qD);class KD extends Kt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return be(()=>(e=Dt(e),eY(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}KD.className="RepeatVector";Ue(KD);class YD extends Kt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,o=null;for(let l=0;l<r.length;++l){const c=r[l];if(this.isUnknown(c))if(o===null)o=l;else throw new ie("Can only specifiy one unknown dimension.");else i*=c}const a=Oa(e);if(o!==null){if(i===0||a%i!==0)throw new ie(s);r[o]=a/i}else if(a!==i)throw new ie(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=Dt(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return fe(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}YD.className="Reshape";Ue(YD);class ZD extends Kt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=zi(1,e.dims.length+1);if(!mn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new us({ndim:this.dims.length+1})]}computeOutputShape(e){e=ln(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return sn(Dt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}ZD.className="Permute";Ue(ZD);class QD extends Kt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Dt(e);return pb(gg(s,this.maskValue),-1)}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=Dt(e),o=pb(gg(s,this.maskValue),-1,!0);return oe(s,at(o,s.dtype))})}}QD.className="Masking";Ue(QD);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class JD extends Kt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(vn(e.inputLength))}this.inputDim=e.inputDim,ys(this.inputDim,"inputDim"),this.outputDim=e.outputDim,ys(this.outputDim,"outputDim"),this.embeddingsInitializer=$n(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Fn(e.embeddingsRegularizer),this.activityRegularizer=Fn(e.activityRegularizer),this.embeddingsConstraint=ds(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return be(()=>this.maskZero?(e=Dt(e),gg(e,rn(e))):null)}computeOutputShape(e){if(e=ln(e),this.inputLength==null)return[...e,this.outputDim];const t=vn(this.inputLength);if(t.length!==e.length-1)throw new ie(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],o=e[r+1];if(i!=null&&o!=null&&i!==o)throw new ie(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return be(()=>{this.invokeCallHook(e,t);let s=Dt(e);s.dtype!=="int32"&&(s=ho(s,"int32"));const r=NN(this.embeddings.read(),fe(s,[s.size]));return fe(r,ln(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Un(this.embeddingsInitializer),embeddingsRegularizer:_n(this.embeddingsRegularizer),activityRegularizer:_n(this.activityRegularizer),embeddingsConstraint:hs(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}JD.className="Embedding";Ue(JD);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class dc extends Kt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Wt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],o=t[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new ie("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[ln(e)]),e=e,e.length<2)throw new ie(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Pa(t),t.length>1)throw new ie(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&Pa(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return be(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Va(r);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=kf(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const l of e){const c=l.rank;if(c==null){const h=l.shape,d=h[0],p=h.slice(1).concat([d]);let m=fe(l,[d].concat(Oa(h.slice(1))));m=sn(m,[1,0]),m=fe(m,p),s.push(m),i=!0}else if(c>1){const h=zi(1,c).concat([0]);s.push(sn(l,h)),i=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,h=l[c-1],d=[h].concat(l.slice(0,l.length-1));o=fe(sn(fe(o,[-1,h]),[1,0]),d)}else if(a>1){const l=[a-1].concat(zi(0,a-1));o=sn(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Pa(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return be(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ie("`mask` should be an Array");if(!Array.isArray(e))throw new ie("`inputs` should be an Array");if(t.length!==e.length)throw new ie(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:fr(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=Ho(s,t[r]);return s})}}class e$ extends dc{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=je(t,e[s]);return t})}}e$.className="Add";Ue(e$);class t$ extends dc{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=oe(t,e[s]);return t})}}t$.className="Multiply";Ue(t$);class n$ extends dc{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=je(t,e[s]);return oe(1/e.length,t)})}}n$.className="Average";Ue(n$);class s$ extends dc{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Qa(t,e[s]);return t})}}s$.className="Maximum";Ue(s$);class r$ extends dc{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=dd(t,e[s]);return t})}}r$.className="Minimum";Ue(r$);class i$ extends dc{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ie("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let o=!1;for(const a of s)if(mn(a,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new ie("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return be(()=>m_(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ie("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ie("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ie("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ie(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return be(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(at(mi(e[o]),"bool")):t[o].rank<e[o].rank?r.push(fr(t[o],-1)):r.push(t[o]);const i=xr(r,this.axis);return ok(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}i$.className="Concatenate";Ue(i$);function Hh(n,e){for(;n<0;)n+=e;return n}function _Z(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Wt("batchDot is not implemented for tensors of 4D or higher rank yet");if(W(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),W(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Wt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return be(()=>{let o;if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);e=fe(e,e.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);n=fe(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=It(oe(n,e),i[0]):a=It(oe(sn(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,c=i[1]===e.shape.length-1;a=pn(n,e,l,c)}if(o>0){let l;s>r?l=s+r-3:l=s-1;const c=[];for(let h=l;h<l+o;++h)c.push(h);a=Ef(a,c)}return a.shape.length===1&&(a=fr(a,1)),a})}class o$ extends dc{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){W(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new Wt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new ie(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ie(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>Hh(i,e[o].shape.length)):r=[Hh(this.axes,t.shape.length),Hh(this.axes,s.shape.length)],this.normalize&&(t=_g(t,r[0]),s=_g(s,r[1])),_Z(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Hh(this.axes,e.length),Hh(this.axes,t.length)],s}computeOutputShape(e){W(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new Wt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}o$.className="Dot";Ue(o$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class a$ extends Kt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=Dt(e);return Df(()=>je(ax(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}a$.className="GaussianNoise";Ue(a$);class l$ extends Kt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=Dt(e);return this.rate>0&&this.rate<1?Df(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return oe(s,ax(s.shape,1,i))},()=>s,t.training||!1):s})}}l$.className="GaussianDropout";Ue(l$);class c$ extends Kt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Dt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return be(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Df(()=>{const i=Dt(e),a=-1.6732632423543772*1.0507009873554805;let l=lc(Cf(s),this.rate);l=ho(l,"float32");const c=((1-this.rate)*(1+this.rate*a**2))**-.5,h=-c*a*this.rate,d=je(oe(i,l),oe(je(l,-1),a));return je(oe(d,c),h)},()=>Dt(e),t.training||!1)}return e})}}c$.className="AlphaDropout";Ue(c$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xd(n,e,t,s,r,i=.001){let o;if(n.rank===2)o=t8(n,e,t,s,r,i);else if(n.rank===3)o=s8(n,e,t,s,r,i);else if(n.rank===4)o=i8(n,e,t,s,r,i);else throw new Wt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function CZ(n,e,t,s,r=.001){return be(()=>{const i=_w(n,s),o=i.mean,a=i.variance;return[xd(n,o,a,t,e,r),o,a]})}function EZ(n,e,t,s,r=.001){return be(()=>{const i=_w(n,s),o=i.mean,a=i.variance,l=[];for(const g of zi(0,n.rank))s.indexOf(g)!==-1?l.push(1):l.push(n.shape[g]);const c=fe(o,l),h=fe(a,l),d=e==null?null:fe(e,l),p=t==null?null:fe(t,l);return[xd(n,c,h,p,d,r),o,a]})}function TZ(n,e,t,s,r=.001){return mn(s.slice().sort(),zi(0,n.rank-1))?CZ(n,e,t,s,r):EZ(n,e,t,s,r)}class u$ extends Kt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=$n(e.betaInitializer||"zeros"),this.gammaInitializer=$n(e.gammaInitializer||"ones"),this.movingMeanInitializer=$n(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=$n(e.movingVarianceInitializer||"ones"),this.betaConstraint=ds(e.betaConstraint),this.gammaConstraint=ds(e.gammaConstraint),this.betaRegularizer=Fn(e.betaRegularizer),this.gammaRegularizer=Fn(e.gammaRegularizer)}build(e){e=ln(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new ie(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new us({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return be(()=>{const s=t.training==null?!1:t.training,r=Dt(e),i=r.shape,o=i.length,a=zi(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=tc(1,o);c[l]=i[l];const h=a.slice();h.sort();const d=!mn(h,zi(0,o).slice(0,o-1)),p=()=>{if(d){const S=fe(this.movingMean.read(),c),C=fe(this.movingVariance.read(),c),_=this.center?fe(this.beta.read(),c):null,A=this.scale?fe(this.gamma.read(),c):null;return xd(r,S,C,_,A,this.epsilon)}else return xd(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return p();const[m,g,b]=TZ(r,this.gamma.read(),this.beta.read(),a,this.epsilon),y=(S,C,_)=>{be(()=>{const A=1-_,k=S.read(),N=oe(Nt(k,C),A);S.write(Nt(k,N))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,b,this.momentum)})(),m})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Un(this.betaInitializer),gammaInitializer:Un(this.gammaInitializer),movingMeanInitializer:Un(this.movingMeanInitializer),movingVarianceInitializer:Un(this.movingVarianceInitializer),betaRegularizer:_n(this.betaRegularizer),gammaRegularizer:_n(this.gammaRegularizer),betaConstraint:hs(this.betaConstraint),gammaConstraint:hs(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}u$.className="BatchNormalization";Ue(u$);class h$ extends Kt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=$n(e.betaInitializer||"zeros"),this.gammaInitializer=$n(e.gammaInitializer||"ones"),this.betaRegularizer=Fn(e.betaRegularizer),this.gammaRegularizer=Fn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=ln(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Pa(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=Dt(e),r=s.shape,i=r.length;return be(()=>{let{mean:a,variance:l}=_w(s,this.axis,!0);const c=tc(1,i);for(const b of this.axis)c[b]=r[b];const h=b=>b!=null&&b.shape.length!==i?fe(b,c):b;let d=this.scale?h(this.gamma.read()):null,p=this.center?h(this.beta.read()):null;const m=[],g=[];for(let b=0;b<i;++b)this.axis.indexOf(b)!==-1?(m.push(r[b]),g.push(1)):(m.push(1),g.push(r[b]));return a=Di(a,m),l=Di(l,m),d!=null&&(d=Di(d,g)),p!=null&&(p=Di(p,g)),xd(s,a,l,p,d,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Un(this.betaInitializer),gammaInitializer:Un(this.gammaInitializer),betaRegularizer:_n(this.betaRegularizer),gammaRegularizer:_n(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}h$.className="LayerNormalization";Ue(h$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function IZ(n,e,t){return be(()=>{if(n.rank!==4)throw new ie(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ie("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Bi()),t!=="channelsLast"&&t!=="channelsFirst")throw new ie(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],Cw(n,s)})}class d$ extends Kt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Bi():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ie(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ie(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ie(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new us({ndim:4})]}computeOutputShape(e){e=ln(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return be(()=>IZ(Dt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}d$.className="ZeroPadding2D";Ue(d$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mx(n,e,t,s,r,i){return be(()=>{Zn(r),AN(i),Yr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=Bi()),i==null&&(i="max"),n=A_(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=ww(n,e,t,a):o=dw(n,e,t,a),r==="channelsFirst"&&(o=sn(o,[0,3,1,2])),o})}function f$(n,e,t,s,r,i){return be(()=>{Zn(r),AN(i),Yr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Bi()),i==null&&(i="max"),n=RD(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=VX(n,e,t,a):o=H6(n,e,t,a),r==="channelsFirst"&&(o=sn(o,[0,4,1,2,3])),o})}class p$ extends Kt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ie(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(ys(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ie(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);ys(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Yr(this.padding),this.inputSpec=[new us({ndim:3})]}computeOutputShape(e){e=ln(e);const t=Oi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return be(()=>{this.invokeCallHook(e,t),e=kf(Dt(e),2);const s=this.poolingFunction(Dt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ef(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class m$ extends p${constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zn(i),Yr(r),mx(e,t,s,r,i,"max")}}m$.className="MaxPooling1D";Ue(m$);class g$ extends p${constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zn(i),Yr(r),mx(e,t,s,r,i,"avg")}}g$.className="AveragePooling1D";Ue(g$);class x$ extends Kt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ie(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];ys(this.poolSize,"poolSize"),ys(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zn(this.dataFormat),Yr(this.padding),this.inputSpec=[new us({ndim:4})]}computeOutputShape(e){e=ln(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Oi(t,this.poolSize[0],this.padding,this.strides[0]),s=Oi(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return be(()=>(this.invokeCallHook(e,t),this.poolingFunction(Dt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class v$ extends x${constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zn(i),Yr(r),mx(e,t,s,r,i,"max")}}v$.className="MaxPooling2D";Ue(v$);class y$ extends x${constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zn(i),Yr(r),mx(e,t,s,r,i,"avg")}}y$.className="AveragePooling2D";Ue(y$);class b$ extends Kt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ie(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];ys(this.poolSize,"poolSize"),ys(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zn(this.dataFormat),Yr(this.padding),this.inputSpec=[new us({ndim:5})]}computeOutputShape(e){e=ln(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Oi(t,this.poolSize[0],this.padding,this.strides[0]),s=Oi(s,this.poolSize[1],this.padding,this.strides[1]),r=Oi(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return be(()=>(this.invokeCallHook(e,t),this.poolingFunction(Dt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class S$ extends b${constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zn(i),Yr(r),f$(e,t,s,r,i,"max")}}S$.className="MaxPooling3D";Ue(S$);class w$ extends b${constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Zn(i),Yr(r),f$(e,t,s,r,i,"avg")}}w$.className="AveragePooling3D";Ue(w$);class _$ extends Kt{constructor(e){super(e),this.inputSpec=[new us({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Wt}}class C$ extends _${constructor(e){super(e||{})}call(e,t){return be(()=>{const s=Dt(e);return ss(s,1)})}}C$.className="GlobalAveragePooling1D";Ue(C$);class E$ extends _${constructor(e){super(e||{})}call(e,t){return be(()=>{const s=Dt(e);return Pi(s,1)})}}E$.className="GlobalMaxPooling1D";Ue(E$);class T$ extends Kt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zn(this.dataFormat),this.inputSpec=[new us({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Wt}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class I$ extends T${call(e,t){return be(()=>{const s=Dt(e);return this.dataFormat==="channelsLast"?ss(s,[1,2]):ss(s,[2,3])})}}I$.className="GlobalAveragePooling2D";Ue(I$);class A$ extends T${call(e,t){return be(()=>{const s=Dt(e);return this.dataFormat==="channelsLast"?Pi(s,[1,2]):Pi(s,[2,3])})}}A$.className="GlobalMaxPooling2D";Ue(A$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class M$ extends Kt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=Go(r,s);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class R$ extends M${constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=ln(e),e.length<3)throw new ie(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=ln(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return be(()=>(e=Dt(e),UD((o,a)=>[Dt(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}R$.className="TimeDistributed";Ue(R$);function AZ(n){hc(KK,"BidirectionalMergeMode",n)}const MZ="concat";class k$ extends M${constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=Go(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Go(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?MZ:e.mergeMode,AZ(this.mergeMode),e.weights)throw new Wt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):pr(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=OD(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const o=[],a=[];if(s!=null){const c=s.length;if(c%2>0)throw new ie("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const h=s.map(d=>new us({shape:d.shape}));this.forwardLayer.stateSpec=h.slice(0,c/2),this.backwardLayer.stateSpec=h.slice(c/2),a.push(...h)}if(r!=null)throw new Wt("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof vo;for(const c of o)if(c instanceof vo!==l)throw new ie("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),h=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=h;const p=super.apply(c,t);return this.inputSpec=d,p}else return super.apply(e,t)}call(e,t){return be(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Jl(i,1));let a;return this.mergeMode==="concat"?a=m_([r,i]):this.mergeMode==="sum"?a=je(r,i):this.mergeMode==="ave"?a=oe(.5,je(r,i)):this.mergeMode==="mul"?a=oe(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Bl(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Bl(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=Go(t.layer);if(delete t.layer,t.numConstants!=null)throw new Wt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}k$.className="Bidirectional";Ue(k$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class N$ extends Kt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return be(()=>(e=Dt(e),e.dtype!=="float32"&&(e=ho(e,"float32")),je(oe(e,this.scale),this.offset)))}}N$.className="Rescaling";Ue(N$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:RZ,cropAndResize:kZ}=Bo;class D$ extends Kt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,o,a,l){return be(()=>{let c,h=!1;const d=t/o,p=s/a,m=(r+t)/o,g=(i+s)/a,b=[d,p,m,g],y=[];e.rank===3?(h=!0,c=Xo([e])):c=e;for(let A=0;A<c.shape[0];A++)y.push(b);const v=KR(y,[y.length,4]),S=fd(0,y.length,1,"int32"),_=kZ(c,v,S,[r,i],"nearest");return ho(h?Dt(ec(_)):_,l)})}upsize(e,t,s,r){return be(()=>{const i=RZ(e,[t,s]);return ho(i,r)})}call(e,t){return be(()=>{const s=Dt(e),r=s.dtype,i=s.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,o,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=ln(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}D$.className="CenterCrop";Ue(D$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function NZ(n,e,t,s){let r=Dt(n);if(r.dtype!=="int32"&&(r=ho(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=fr(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=fr(r,-1)),r.rank>2)throw new ie(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),a=r;let l;if(typeof s<"u"&&e==="count"?l=r2(a,s,t,o):l=r2(a,[],t,o),e!=="tfIdf")return l;if(s)return oe(l,s);throw new ie("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $$ extends Kt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=ln(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return be(()=>{e=Dt(e),e.dtype!=="int32"&&(e=ho(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ie(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Dt(t.countWeights)}const r=Pi(e),i=pg(e),o=Kr(this.numTokens,r).bufferSync().get(0),a=lc(i,0).bufferSync().get(0);if(!(o&&a))throw new ie(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return NZ(e,this.outputMode,this.numTokens,s)})}}$$.className="CategoryEncoding";Ue($$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const DZ=["bilinear","nearest"],X2=new Set(DZ);class F$ extends Kt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(X2.has(e.interpolation))this.interpolation=e.interpolation;else throw new ie(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=ln(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return be(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Bo.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Bo.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...X2]} are supported`)})}}F$.className="Resizing";Ue(F$);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class L${constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}L$.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class P$ extends Kt{constructor(e){super(e),this.randomGenerator=new L$(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}P$.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $Z=["bilinear","nearest"],j2=new Set($Z);class O$ extends P${constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ie(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ie(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ie(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(j2.has(s))this.interpolation=s;else throw new ie(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=ln(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return be(()=>{const s=Dt(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Cf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Bo.resizeBilinear(e,o);case"nearest":return Bo.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...j2]} are supported`)}})}}O$.className="RandomWidth";Ue(O$);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FZ=_e();FZ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var q2;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(q2||(q2={}));var K2;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(K2||(K2={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Y2;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Y2||(Y2={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&W(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LZ=$k;class gx extends gS{nextDataId(){return gx.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new rR(this,Zi())}write(e,t,s){this.firstUse&&(this.firstUse=!1,_e().get("IS_NODE")&&Wr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ed(s[0])){const i=s.map(o=>La(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return jo(r,i)}return o5(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ba(r));return jt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return jt(e.shape,e.dtype,t)}makeOutput(e,t,s){return Zi().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=dr();return e(),{kernelMs:dr()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){gt([e],"where");const t=this.readSync(e.dataId);return LZ(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}gx.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const PZ=n=>{const{x:e}=n.inputs,t=n.backend;gt(e,"abs");let s=new Float32Array(Ne(e.shape));const r=t.data.get(e.dataId).values;return s=U$(r),t.makeOutput(s,e.shape,e.dtype)},OZ={kernelName:Kg,backendName:"cpu",kernelFunc:PZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(n){return(e,t,s,r,i)=>{const o=Ut(e,t),a=o.length,l=Ct(o),c=Ne(o),h=Us(i,c),d=e.length,p=t.length,m=Ct(e),g=Ct(t),b=Cu(e,o),y=Cu(t,o);if(b.length+y.length===0)for(let v=0;v<h.length;++v)h[v]=n(s[v%s.length],r[v%r.length]);else for(let v=0;v<h.length;++v){const S=Pu(v,a,l),C=S.slice(-d);b.forEach(N=>C[N]=0);const _=lo(C,d,m),A=S.slice(-p);y.forEach(N=>A[N]=0);const k=lo(A,p,g);h[v]=n(s[_],r[k])}return[h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nr(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",o)},a}const UZ={kernelName:MS,backendName:"cpu",kernelFunc:Nr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ag(n,e,t="float32"){if(t==="complex64"){const r=Ag(n,e,"float32"),i=Ag(n,e,"float32");return Nr({inputs:{real:r,imag:i},backend:n})}const s=zs(Ne(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yo(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const zZ={kernelName:Xd,backendName:"cpu",kernelFunc:yo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nc(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const BZ={kernelName:JS,backendName:"cpu",kernelFunc:nc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=ac([0],t),[i,o]=Qn((a,l)=>a!==l?1:0)(e,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Xa(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return yo({inputs:{x:r},backend:t});const h=Ag(t,r.shape,r.dtype),d=Xa({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),p=Nr({inputs:{real:d,imag:h},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),p}if(r.dtype==="complex64"){const h=nc({inputs:{input:r},backend:t}),d=Xa({inputs:{x:h},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(h),d}if(!oR(r.dtype,i)){const h=yo({inputs:{x:r},backend:t});return{dataId:h.dataId,shape:h.shape,dtype:i}}const o=t.data.get(r.dataId).values,[a,l,c]=z$(o,r.shape,r.dtype,i);return t.makeTensorInfo(a,l,c)}const VZ={kernelName:Dd,backendName:"cpu",kernelFunc:Xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;gt([o,a],n);const c=l.data.get(o.dataId).values,h=l.data.get(a.dataId).values,d=o.dtype==="string"?qo(c):c,p=o.dtype==="string"?qo(h):h,m=s||o.dtype,[g,b]=e(o.shape,a.shape,d,p,m);return l.makeTensorInfo(b,m,g)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=Xa({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,m=l.data.get(d.dataId).values,g=l.data.get(p.dataId).values,b=Xa({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(b.dataId),v=y.complexTensorInfos.real,S=y.complexTensorInfos.imag,C=l.data.get(v.dataId).values,_=l.data.get(S.dataId).values,[A,k,N]=t(o.shape,a.shape,m,g,C,_),D=l.makeTensorInfo(N,"float32",A),M=l.makeTensorInfo(N,"float32",k),T=Nr({inputs:{real:D,imag:M},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(b),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(M),T}else{const c=l.data.get(o.dataId).values,h=l.data.get(a.dataId).values,d=s||o.dtype,[p,m]=e(o.shape,a.shape,c,h,d);return l.makeTensorInfo(m,d,p)}}}function $_(n){return(e,t,s,r,i,o)=>{const a=Ut(e,t),l=Ne(a),c=a.length,h=Ct(a),d=Us("float32",l),p=Us("float32",l),m=Cu(e,a),g=Cu(t,a),b=jo(s,r),y=jo(i,o),v=e.length,S=Ct(e),C=t.length,_=Ct(t);if(m.length+g.length===0)for(let A=0;A<d.length;A++){const k=A%b.length,N=A%y.length,D=n(b[k*2],b[k*2+1],y[N*2],y[N*2+1]);d[A]=D.real,p[A]=D.imag}else for(let A=0;A<d.length;A++){const k=Pu(A,c,h),N=k.slice(-v);m.forEach($=>N[$]=0);const D=lo(N,v,S),M=k.slice(-C);g.forEach($=>M[$]=0);const T=lo(M,C,_),I=n(b[D*2],b[D*2+1],y[T*2],y[T*2+1]);d[A]=I.real,p[A]=I.imag}return[d,p,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B$=Qn((n,e)=>n+e),GZ=$_((n,e,t,s)=>({real:n+t,imag:e+s})),Iu=ms(Ou,B$,GZ),WZ={kernelName:Ou,backendName:"cpu",kernelFunc:Iu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(n,e,t,s,r){const i=Ne(s),o=zs(r,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function V$(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],o=jt([r,t],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G$=Qn((n,e)=>n&e),HZ=ms(AS,G$),XZ={kernelName:AS,backendName:"cpu",kernelFunc:HZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bo(n){return(e,t,s)=>{const r=jn(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(n,e,t){const s=bo(e);return nl(n,s,t)}function nl(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;gt(o,n);const a=i,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=qo(l)}else c=l;const h=t||o.dtype,d=e(c,h,r);return a.makeTensorInfo(o.shape,h,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$=bo(n=>Math.ceil(n)),jZ=nl($d,W$),qZ={kernelName:$d,backendName:"cpu",kernelFunc:jZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(n,e,t,s){const r=jn(t,Ne(e));if(s&&t!=="string"){let i=0;n.forEach(o=>{const a=Ne(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?qo(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const h=c*e[1]+i;for(let d=0;d<o.shape[1];++d)r[h+d]=a[l++]}i+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X$=Qn((n,e)=>n===e?1:0),j$=ms(u0,X$,null,"bool"),KZ={kernelName:u0,backendName:"cpu",kernelFunc:j$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q$=bo(n=>Math.exp(n)),K$=nl(Bd,q$,"float32"),YZ={kernelName:Bd,backendName:"cpu",kernelFunc:K$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y$=bo(n=>Math.expm1(n)),ZZ=nl(Vd,Y$),QZ={kernelName:Vd,backendName:"cpu",kernelFunc:ZZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z$=bo(n=>Math.floor(n)),JZ=nl(Gd,Z$),eQ={kernelName:Gd,backendName:"cpu",kernelFunc:JZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q$=Qn((n,e)=>Math.floor(n/e)),tQ=ms(Wd,Q$,null,"int32"),nQ={kernelName:Wd,backendName:"cpu",kernelFunc:tQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n,e,t,s,r,i,o,a,l){const c=jt([s,i],t);for(let h=0;h<s;h++){const d=[];let p=0;for(let m=0;m<r;m++){const g=n[h*r+m];p+=g*o[m],d.push(g)}if(p<0||p>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let m=0;m<i;m++)c.values[h*i+m]=e.get(...e.indexToLoc(p*i+m))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e3(n,e,t){const s=jt(t,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const h=n.locToIndex(o);0<=h&&h<n.values.length&&(s.values[r]=n.values[h])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t3=Qn((n,e)=>n>e?1:0),sQ=ms(p0,t3,null,"bool"),rQ={kernelName:p0,backendName:"cpu",kernelFunc:sQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n3=Qn((n,e)=>n>=e?1:0),iQ=ms(Hd,n3,null,"bool"),oQ={kernelName:Hd,backendName:"cpu",kernelFunc:iQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s3=Qn((n,e)=>n<e?1:0),aQ=ms(g0,s3,null,"bool"),lQ={kernelName:g0,backendName:"cpu",kernelFunc:aQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3=Qn((n,e)=>n<=e?1:0),cQ=ms(x0,r3,null,"bool"),uQ={kernelName:x0,backendName:"cpu",kernelFunc:cQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i3(n,e,t){const s=(e-n)/(t-1),r=zs(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o3=bo(n=>Math.log(n)),hQ=nl(Yd,o3),dQ={kernelName:Yd,backendName:"cpu",kernelFunc:hQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a3(n,e,t,s){const r=Us(s,Ne(t));for(let i=0;i<r.length;++i){const o=i*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}r[i]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l3=Qn((n,e)=>Math.max(n,e)),fQ=ms(Qd,l3),pQ={kernelName:Qd,backendName:"cpu",kernelFunc:fQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c3=Qn((n,e)=>Math.min(n,e)),mQ=ms(Jd,c3),gQ={kernelName:Jd,backendName:"cpu",kernelFunc:mQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L_=Qn((n,e)=>n*e),xQ=$_((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),xx=ms(tf,L_,xQ),vQ={kernelName:tf,backendName:"cpu",kernelFunc:xx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3(n,e,t){const s=Ka(-1,t);return L_([],e,s,n,t)}function yQ(n){const{inputs:e,backend:t}=n,{x:s}=e;gt(s,"neg");const r=t.data.get(s.dataId).values,[i,o]=u3(r,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,i)}const bQ={kernelName:A0,backendName:"cpu",kernelFunc:yQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h3=Qn((n,e)=>n!==e?1:0),SQ=ms(M0,h3,null,"bool"),wQ={kernelName:M0,backendName:"cpu",kernelFunc:SQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(n,e,t,s,r){const i=e.length,o=Ne(e),a=Ct(e),l=Ct(r),c=Us(t,Ne(r));for(let h=0;h<o;++h){const d=Pu(h,i,a),p=new Array(d.length);for(let g=0;g<p.length;g++)p[g]=d[s[g]];const m=lo(p,i,l);c[m]=n[h]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;gt(r,"transpose");const o=r.shape.length,a=new Array(o);for(let d=0;d<a.length;d++)a[d]=r.shape[i[d]];const l=s.data.get(r.dataId).values,c=P_(l,r.shape,r.dtype,i,a);return{dataId:s.write(c,a,r.dtype),shape:a,dtype:r.dtype}}const _Q={kernelName:du,backendName:"cpu",kernelFunc:yr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(n,e,t,s){const[r,i]=ws(n,s),o=$r(e,"int32"),a=zs(Ne(r),o),l=Ne(i);for(let c=0;c<a.length;++c){const h=c*l;let d=1;for(let p=0;p<l;++p)d*=t[h+p];a[c]=d}return{outVals:a,outShape:r,outDtype:o}}function CQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;gt(r,"prod");const a=r.shape.length,l=qt(i,r.shape),c=zn(l,a);let h=l,d=r;const p=[];c!=null&&(d=yr({inputs:{x:r},backend:t,attrs:{perm:c}}),p.push(d),h=Yn(h.length,a));const m=t.data.get(d.dataId).values,{outVals:g,outShape:b,outDtype:y}=d3(d.shape,d.dtype,m,h);let v=b;return o&&(v=rs(b,l)),p.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(v,y,g)}const EQ={kernelName:F0,backendName:"cpu",kernelFunc:CQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=Pu(r,e.length,Ct(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function IQ(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function AQ(n,e,t,s){const r=[];let i=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);IQ(t,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const h=e[c+1];for(let d=1;d<l+1;++d)a[c].push(d*h)}for(let c=0;c<n.length;++c){let h=n[c],d=n[c]+1;for(let p=0;p<t.length;++p){const m=t[p],g=p+e.length-1;if(g>=0){const b=a[g],y=b[b.length-1]-m[h];for(let v=h;v<d;++v)a[g].push(m[v+1]+y)}h=m[h],d=m[d]}d!==h&&(r.push([h,d]),i+=d-h)}return{outSplits:a,valueSlices:r,numValues:i}}function MQ(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=jn("int32",s);e.push(r),n[t].forEach((i,o)=>r[o]=i)}return e}function Z2(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function RQ(n,e,t,s,r,i){const o=Z2(e,2)[1],a=Z2(i,2)[1];let l=0;for(const c of t)for(let h=c[0];h<c[1];++h){for(let d=0;d<s;++d)r[l*a+d]=n[h*o+d];++l}}function kQ(n,e,t,s,r){const i=e.slice();i[0]=r;const o=jn(t,Ne(i)),a=n.length,l=a===0?0:a/e[0];return RQ(n,e,s,l,o,i),[o,i]}function f3(n,e,t,s,r,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(TQ(i,o,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:h,valueSlices:d,numValues:p}=AQ(i,o,n,c),m=MQ(h),g=kQ(t,s,r,d,p);return[m,g[0],g[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q2=2147483647;function p3(n,e,t,s,r,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=r.length===0,c=o.length===0,h=[];a||h.push(e[0]),l||h.push(r[0]),c||h.push(o[0]);for(let y=1;y<h.length;++y)if(h[y]!==h[y-1])throw new Error("starts, limits, and deltas must have the same shape");const d=h.length===0?1:h[0],p=jn("int32",d+1);p[0]=0;for(let y=0;y<d;++y){const v=a?n[0]:n[y],S=l?s[0]:s[y],C=c?i[0]:i[y];if(C===0)throw new Error("Requires delta != 0");let _;if(C>0&&S<v||C<0&&S>v)_=0;else if(_=Math.ceil(Math.abs((S-v)/C)),_>Q2)throw new Error(`Requires ((limit - start) / delta) <= ${Q2}`);p[y+1]=p[y]+_}const m=p[d],g=jn(t,m);let b=0;for(let y=0;y<d;++y){const v=p[y+1]-p[y];let S=a?n[0]:n[y];const C=c?i[0]:i[y];for(let _=0;_<v;++_)g[b++]=S,S+=C}return[p,g]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oi=ki;class Mg{constructor(e,t,s,r,i,o,a,l,c,h){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Jk(h),this.raggedRank=eN(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===oi.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===oi.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case oi.VALUE_ROWIDS:return Mg.getMaxWidthValueRowID(t);case oi.ROW_SPLITS:return Mg.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${oi[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let o=1;o<t;++o){const a=e[o];a!==r&&(r=a,i=Math.max(o-s,i),s=o)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return eA(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;tN(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=Qk(this.raggedRank,r,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let o=0;for(let a=0;a<r;++a,o+=t)i.push(o);for(let a=r;a<e;++a)i.push(-1);return W(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let c=Math.min(r,l),h=t[a];h===-1&&(c=0);for(let d=0;d<c;++d)o.push(h),h+=s;for(let d=0;d<l-c;++d)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let h=1;h<i;++h){const d=e[h];if(d===l)c>=0&&(++a,a<r?c+=s:c=-1);else{if(a=0,l=d,d>=t.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${t.length}`);c=t[d]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case oi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case oi.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${oi[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case oi.FIRST_DIM_SIZE:return e[0];case oi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case oi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${oi[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=eA(s,!1),o=jn(this.valuesDType,Ne(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,r[c],s[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,o=s;let a=r.slice();a=a.slice(e+1);const l=Ne(a),c=t.length;let h=this.defaultValue;if(h.length!==l&&h.length!==1){const g=this.defaultValueShape;be(()=>{const b=fe(h,g);h=Jh(b,a).dataSync()})}let d=0,p=0,m=0;for(let g=0;g<=c;++g){let b=g<c?t[g]:-1;if(b===m){++m;continue}if(p<m){const y=i.subarray(d*l),v=o.subarray(p*l),S=(m-p)*l;J2(v,y,S)}if(g>=c){const y=s.length;b=Math.floor(y/l)}if(b>m)if(this.defaultValue.length===1)o.subarray(m*l,b*l).fill(this.defaultValue[0]),m=b;else for(;b>m;){const y=o.slice(m*l);J2(y,h,l),++m}b<0?(d=g+1,p=m):(d=g,p=m,m=p+1)}}}function J2(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function eA(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function m3(n,e,t,s,r,i,o,a,l,c){return new Mg(n,e,t,s,r,i,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3(n,e,t,s){const r=n===e,i=n<e&&t<0,o=e<n&&t>1;if(r||i||o)return zs(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=zs(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x3=bo(n=>1/Math.sqrt(n)),NQ=nl(lf,x3),DQ={kernelName:lf,backendName:"cpu",kernelFunc:NQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ol(n,e,t,s,r,i,o,a,l,c){const h=[s/r,r],d=n.values,p=e.values;if(s===0)return jt(t,e.dtype);const m=l instanceof ks?l:jt(h,e.dtype);typeof l=="string"||typeof l=="number"?m.values.fill(l):typeof l=="boolean"&&m.values.fill(+l);for(let g=0;g<i;g++){const b=[];let y=0;for(let v=0;v<o;v++){const S=d[g*o+v];b.push(S),y+=S*a[v]}if(y<0||y>=s/r)throw new Error(`Invalid indices: ${b} does not index into ${t}`);for(let v=0;v<r;v++)c?m.values[y*r+v]+=p[g*r+v]:m.values[y*r+v]=e.rank===0?p[0]:p[g*r+v]}return m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Q=bo(n=>1/(1+Math.exp(-n))),v3=yn(ff,n=>1/(1+Math.exp(-n))),FQ={kernelName:ff,backendName:"cpu",kernelFunc:v3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3(n,e,t,s,r){const i=Ww(s,e,t),o=Ne(t),a=Ct(s);if(i){const d=Hw(e,a);return r==="string"?n.slice(d,d+o):n.subarray(d,d+o)}const l=r==="string"?qo(n):n,c=jt(s,r,l),h=jt(t,r);for(let d=0;d<h.size;++d){const p=h.indexToLoc(d),m=p.map((g,b)=>g+e[b]);h.set(c.get(...m),...p)}return r==="string"?SN(h.values):h.values}function sc(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s;gt(r,"slice");const[a,l]=nx(r,i,o);Vw(r,a,l);const c=t.data.get(r.dataId).values,h=y3(c,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,h)}const LQ={kernelName:B0,backendName:"cpu",kernelFunc:sc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b3(n,e,t,s,r,i,o){const a=e[0],l=i[0],c=new Array(l),h=new Array(a),d=e[1];if(l===0){if(a!==0)throw new Error(lN(a));const y=jn(t,0),v=jn(r,0);return[y,[0,d],v,c,h]}let p=!0,m=0;const g=new Array(l).fill(0);for(let y=0;y<a;++y){const v=n[y*d];if(v<0)throw new Error(cN(y,v));if(v>=l)throw new Error(uN(y,v,l));++g[v],p=p&&v>=m,m=v}let b=!0;for(let y=0;y<l;++y){const v=g[y]===0;c[y]=v,b=b&&!v,g[y]=Math.max(g[y],1),y>0&&(g[y]+=g[y-1])}if(b&&p){const y=n,v=s;for(let S=0;S<a;++S)h[S]=S;return[y,[a,d],v,c,h]}else{const y=g[l-1],v=jn(t,y*d),S=jn(r,y),C=new Array(l).fill(0);for(let _=0;_<a;++_){const A=n[_*d],k=C[A],N=(A===0?0:g[A-1])+k;C[A]++;for(let D=0;D<d;++D)v[N*d+D]=n[_*d+D];S[N]=s[_],h[_]=N}for(let _=0;_<l;++_)if(C[_]===0){const k=_===0?0:g[_-1];v[k*d+0]=_;for(let N=1;N<d;++N)v[k*d+N]=0;S[k]=o}return[v,[y,d],S,c,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(n,e,t,s,r){const i=Ne(s),o=e[0],a=r.length,l=[];let c=1,h=-1;for(let y=0;y<a;++y){const v=r[y];if(v===-1){if(h!==-1)throw new Error(hN(h,y));h=y,l.push(1)}else{if(v<0)throw new Error(dN(y,v));c*=v,l.push(v)}}if(h!==-1){if(c<=0)throw new Error(fN());const y=Math.trunc(i/c);if(c*y!==i)throw new Error(pN(s,l));l[h]=y}if(Ne(l)!==i)throw new Error(mN(s,l));const p=s.length,m=[];if(p>0){m[p-1]=1;for(let y=p-2;y>=0;--y)m[y]=m[y+1]*s[y+1]}const g=[];if(a>0){g[a-1]=1;for(let y=a-2;y>=0;--y)g[y]=g[y+1]*l[y+1]}const b=jn(t,o*a);for(let y=0;y<o;++y){let v=0;for(let S=0;S<p;++S)v+=n[y*p+S]*m[S];for(let S=0;S<a;++S)b[y*a+S]=Math.trunc(v/g[S]),v%=g[S]}return[b,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O_(n,e,t,s,r,i=!1,o=0){const a=s.length,l=[e[0],n.length/e[0]],c=l[1],d=a>0?r[a-1]+1:0;if(d<0)throw new Error(bb());const p=e.slice();p[0]=d;const m=p.reduce((C,_)=>C*_,1),g=jn(t,m);if(a===0)return d>0&&g.fill(o),[g,p];if(d<=0)throw new Error(bb());let b=0,y=1,v=0,S=r[b];for(;;){let C=0;if(y<a){if(C=r[y],S===C){++y;continue}if(S>=C)throw new Error(gN())}if(S<0||S>=d)throw new Error(xN(S,d));S>v&&g.fill(o,v*c,S*c);for(let _=b;_<y;++_){const A=s[_];if(A<0||A>=l[0])throw new Error(vN(_,s[_],l[0]));for(let k=0;k<c;k++)g[S*c+k]+=n[A*c+k]}if(i)for(let _=0;_<c;_++)g[S*c+_]/=y-b;if(b=y,++y,v=S+1,S=C,y>a)break}return v<d&&g.fill(o,v*c,d*c),[g,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PQ=bo(n=>Math.sqrt(n)),OQ=yn(mf,n=>Math.sqrt(n)),UQ={kernelName:mf,backendName:"cpu",kernelFunc:OQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w3=Qn((n,e)=>{const t=n-e;return t*t}),zQ=ms(gf,w3),BQ={kernelName:gf,backendName:"cpu",kernelFunc:zQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _3=bo((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),VQ=nl(sw,_3),GQ={kernelName:sw,backendName:"cpu",kernelFunc:VQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3(n,e,t,s){const r=jt(n,e.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+s[l];r.set(e.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WQ{constructor(e,t,s,r,i,o){this.separator=La(e),this.nGramWidths=t,this.leftPad=La(s),this.rightPad=La(r),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),h=Math.max(0,l-(i-(a+1))),d=o-(c+h),p=t+(c>0?0:a-l);let m=0;m+=c*this.leftPad.length;for(let S=0;S<d;++S)m+=e[p+S].length;m+=h*this.rightPad.length;const g=c+h+d-1;m+=g*this.separator.length,s[r+a]=new Uint8Array(m);const b=s[r+a];let y=0;const v=S=>S.forEach(C=>b[y++]=C);for(let S=0;S<c;++S)v(this.leftPad),v(this.separator);for(let S=0;S<d-1;++S)v(e[p+S]),v(this.separator);if(d>0){v(e[p+d-1]);for(let S=0;S<h;++S)v(this.separator),v(this.rightPad)}else{for(let S=0;S<h-1;++S)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let h=t[c]>=l;if(h=h&&t[c]<=s,!h)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,o=jn("int32",r);if(s===0||r===0){const l=new Array(s);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=t[l]-t[l-1];let h=0;this.nGramWidths.forEach(d=>{h+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&h===0&&(h=1),o[l]=o[l-1]+h}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=t[l];let h=o[l];if(this.nGramWidths.forEach(d=>{const p=t[l+1]-t[l],m=this.getNumNGrams(p,d);this.createNGrams(e,c,a,h,m,d),h+=m}),this.preserveShort&&h===o[l]){const d=t[l+1]-t[l];if(d===0)continue;const p=d+2*this.padWidth;this.createNGrams(e,c,a,h,1,p)}}return[a,o]}}function E3(n,e,t,s,r,i,o,a){return new WQ(t,s,r,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQ(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!t||o.length!==0)&&s.push(o),r=i+1}}function T3(n,e,t){const s=n.length,r=[];let i=0,o=0;const a=new Array(s);for(let p=0;p<s;++p){const m=r.length;HQ(n[p],e,t,r);const g=r.length-m;a[p]=g,i+=g,o=Math.max(o,g)}const l=jn("int32",i*2),c=new Array(i),h=[s,o];let d=0;for(let p=0;p<s;++p)for(let m=0;m<a[p];++m)l[d*2]=p,l[d*2+1]=m,c[d]=r[d],++d;return[l,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(n,e){const t=jn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=E5(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A3=Qn((n,e)=>n-e),XQ=$_((n,e,t,s)=>({real:n-t,imag:e-s})),U_=ms(xf,A3,XQ),jQ={kernelName:xf,backendName:"cpu",kernelFunc:U_};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=jt(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);s.values[r]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yh=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function R3(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,c=Math.log(a),h=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*h*(a-h)/a)*Math.sign(l-a/2),p=Math.max(t,Math.floor(e-l*h/a+d)),m=Math.min(s,Math.floor(e+(a-l)*h/a+d));R3(n,e,p,m)}const r=n[e];let i=t,o=s;for(iu(n,t,e),Yh(n[s],r)>0&&iu(n,t,s);i<o;){for(iu(n,i,o),i++,o--;Yh(n[i],r)<0;)i=i+1;for(;Yh(n[o],r)>0;)o=o-1}Yh(n[t],r)===0?iu(n,t,o):(o=o+1,iu(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function k3(n,e,t,s,r){const i=e[e.length-1],[o,a]=[n.length/i,i],l=Us(t,o*s),c=Us("int32",o*s);for(let d=0;d<o;d++){const p=d*a,m=n.subarray(p,p+a);let g=new Array(m.length);m.forEach((S,C)=>g[C]={value:S,index:C}),s<g.length&&(R3(g,s),g=g.slice(0,s)),r&&g.sort(Yh);const b=d*s,y=l.subarray(b,b+s),v=c.subarray(b,b+s);for(let S=0;S<s;S++)y[S]=g[S].value,v[S]=g[S].index}const h=e.slice();return h[h.length-1]=s,[jt(h,t,l),jt(h,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3(n,e,t,s){const r=qt(e,t)[0],i=[1,t[0],1];for(let g=0;g<r;g++)i[0]*=t[g];i[1]=t[r];for(let g=r+1;g<t.length;g++)i[2]*=t[g];const o=new Map,a=new Int32Array(t[r]),l=new ks(i,s,n),c=[],h=i[0]===1&&i[2]===1;for(let g=0;g<t[r];g++){let b;if(h)b=n[g].toString();else{const v=[];for(let S=0;S<i[0];S++)for(let C=0;C<i[2];C++)v.push(l.get(S,g,C));b=v.join(",")}const y=o.get(b);if(y!=null)a[g]=y;else{const v=o.size;o.set(b,v),a[g]=v,c.push(g)}}const d=i.slice();d[1]=o.size;const p=new ks(d,s);c.forEach((g,b)=>{for(let y=0;y<i[0];y++)for(let v=0;v<i[2];v++)p.set(l.get(y,g,v),y,b,v)});const m=t.slice();return m[r]=d[1],{outputValues:p.values,outputShape:m,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qQ=Object.freeze(Object.defineProperty({__proto__:null,addImpl:B$,bincountImpl:F_,bincountReduceImpl:V$,bitwiseAndImpl:G$,castImpl:z$,ceilImpl:W$,concatImpl:H$,equalImpl:X$,expImpl:q$,expm1Impl:Y$,floorDivImpl:Q$,floorImpl:Z$,gatherNdImpl:J$,gatherV2Impl:e3,greaterEqualImpl:n3,greaterImpl:t3,lessEqualImpl:r3,lessImpl:s3,linSpaceImpl:i3,logImpl:o3,maxImpl:a3,maximumImpl:l3,minimumImpl:c3,multiplyImpl:L_,negImpl:u3,notEqualImpl:h3,prodImpl:d3,raggedGatherImpl:f3,raggedRangeImpl:p3,raggedTensorToTensorImpl:m3,rangeImpl:g3,rsqrtImpl:x3,scatterImpl:Ol,sigmoidImpl:$Q,simpleAbsImpl:U$,sliceImpl:y3,sparseFillEmptyRowsImpl:b3,sparseReshapeImpl:S3,sparseSegmentReductionImpl:O_,sqrtImpl:PQ,squaredDifferenceImpl:w3,staticRegexReplaceImpl:_3,stridedSliceImpl:C3,stringNGramsImpl:E3,stringSplitImpl:T3,stringToHashBucketFastImpl:I3,subImpl:A3,tileImpl:M3,topKImpl:k3,transposeImpl:P_,uniqueImpl:N3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */YR("cpu",()=>new gx,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D3=yn(Ud,n=>n>=0?n:Math.exp(n)-1),KQ={kernelName:Ud,backendName:"cpu",kernelFunc:D3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;gt([r],"leakyRelu");const o=Ne(r.shape),a=t.data.get(r.dataId).values,l=Us("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return t.makeTensorInfo(r.shape,"float32",l)}const YQ={kernelName:m0,backendName:"cpu",kernelFunc:$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZQ=Qn((n,e)=>n<0?e*n:n);function F3(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;gt([s,r],"prelu");const i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,[a,l]=ZQ(s.shape,r.shape,i,o,"float32");return t.makeTensorInfo(l,"float32",a)}const QQ={kernelName:$0,backendName:"cpu",kernelFunc:F3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3=yn(rf,n=>Math.max(0,n)),JQ={kernelName:rf,backendName:"cpu",kernelFunc:L3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P3=yn(of,n=>Math.min(Math.max(0,n),6)),eJ={kernelName:of,backendName:"cpu",kernelFunc:P3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rg(n,e,t,s,r){if(t==="linear")return yo({inputs:{x:e},backend:n});if(t==="relu")return L3({inputs:{x:e},backend:n});if(t==="elu")return D3({inputs:{x:e},backend:n});if(t==="relu6")return P3({inputs:{x:e},backend:n});if(t==="prelu")return F3({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return $3({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return v3({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=Ne(r.shape),a=iR(i,o),l=Ne(a);W(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const c=t.data.get(r.dataId);if(c.complexTensorInfos!=null){const h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;h.shape=a,d.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const tJ={kernelName:L0,backendName:"cpu",kernelFunc:Mn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;gt([r,i],"matMul");const l=r.shape.length,c=i.shape.length,h=o?r.shape[l-2]:r.shape[l-1],d=a?i.shape[c-1]:i.shape[c-2],p=o?r.shape[l-1]:r.shape[l-2],m=a?i.shape[c-2]:i.shape[c-1],g=r.shape.slice(0,-2),b=i.shape.slice(0,-2),y=Ne(g),v=Ne(b),C=Ut(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,m]);W(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const _=o?[y,h,p]:[y,p,h],A=a?[v,m,d]:[v,d,m],k=Mn({inputs:{x:r},backend:t,attrs:{shape:_}}),N=Mn({inputs:{x:i},backend:t,attrs:{shape:A}}),D=o?k.shape[1]:k.shape[2],M=o?k.shape[2]:k.shape[1],T=a?N.shape[1]:N.shape[2],I=Math.max(y,v),$=t.data.get(k.dataId).values,O=t.data.get(N.dataId).values,B=Ct(k.shape),V=Ct(N.shape),[H,q,P]=o?[B[0],1,B[1]]:[B[0],B[1],1],[K,Z,U]=a?[1,V[1],V[0]]:[V[1],1,V[0]],z=M*T,ne=jt([I,M,T],k.dtype),Y=ne.values,te=t.blockSize;for(let he=0;he<I;he++){const se=he%y,Q=he%v;for(let de=0;de<M;de+=te){const ce=Math.min(de+te,M);for(let De=0;De<T;De+=te){const He=Math.min(De+te,T);for(let Le=0;Le<D;Le+=te){const j=Math.min(Le+te,D);for(let ht=de;ht<ce;ht++)for(let We=De;We<He;We++){let Ke=0;for(let Oe=Le;Oe<j;Oe++){const yt=$[se*H+ht*q+Oe*P],Ve=O[Oe*K+We*Z+Q*U];Ke+=yt*Ve}Y[he*z+(ht*T+We)]+=Ke}}}}}return t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(N),t.makeTensorInfo(C,ne.dtype,ne.values)}const nJ={kernelName:e0,backendName:"cpu",kernelFunc:O3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sJ(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s;let p,m,g;const b=[];p=O3({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(m=Iu({inputs:{a:p,b:o},backend:t}),b.push(p),p=m),h&&(g=Rg(t,p,h,a,d),b.push(p),p=g);for(const v of b)t.disposeIntermediateTensorInfo(v);return p}const rJ={kernelName:ug,backendName:"cpu",kernelFunc:sJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iJ=yn(Td,n=>Math.acos(n)),oJ={kernelName:Td,backendName:"cpu",kernelFunc:iJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aJ=yn(Id,n=>Math.acosh(n)),lJ={kernelName:Id,backendName:"cpu",kernelFunc:aJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cJ(n){const{inputs:e,backend:t}=n,s=e;gt(e,"addN");const r=s.map(a=>t.data.get(a.dataId).values),i=jt(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const l=r[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const uJ={kernelName:wS,backendName:"cpu",kernelFunc:cJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;gt(r,"all");const a=qt(i,r.shape);let l=a;const c=zn(l,r.shape.length);let h=r;c!=null&&(h=yr({inputs:{x:r},backend:t,attrs:{perm:c}}),l=Yn(l.length,r.shape.length)),Ds("all",l,h.shape.length);const[d,p]=ws(h.shape,l),m=Ne(p),g=zs(Ne(d),h.dtype),b=t.data.get(h.dataId).values;for(let v=0;v<g.length;++v){const S=v*m;let C=b[S];for(let _=0;_<m;++_){const A=b[S+_];C=C&&A}g[v]=C}c!=null&&t.disposeIntermediateTensorInfo(h);const y=t.makeTensorInfo(d,h.dtype,g);if(o){const v=rs(d,a),S=Mn({inputs:{x:y},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(y),S}return y}const dJ={kernelName:_S,backendName:"cpu",kernelFunc:hJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;gt(r,"any");const a=qt(i,r.shape);let l=a;const c=zn(l,r.shape.length);let h=r;c!=null&&(h=yr({inputs:{x:r},backend:t,attrs:{perm:c}}),l=Yn(l.length,r.shape.length)),Ds("any",l,h.shape.length);const[d,p]=ws(h.shape,l),m=Ne(p),g=zs(Ne(d),h.dtype),b=t.data.get(h.dataId).values;for(let v=0;v<g.length;++v){const S=v*m;let C=b[S];for(let _=0;_<m;++_){const A=b[S+_];C=C||A}g[v]=C}c!=null&&t.disposeIntermediateTensorInfo(h);const y=t.makeTensorInfo(d,h.dtype,g);if(o){const v=rs(d,a),S=Mn({inputs:{x:y},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(y),S}return y}const pJ={kernelName:CS,backendName:"cpu",kernelFunc:fJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;gt(r,"argMax");let o=qt(i,r.shape);const a=zn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=yr({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=Yn(o.length,l.shape.length)),o=[o[0]],Ds("argMax",o,l.shape.length);const[h,d]=ws(l.shape,o),p=Ne(h),m=zs(p,"int32"),g=Ne(d),b=t.data.get(l.dataId).values;for(let y=0;y<m.length;++y){const v=y*g;let S=b[v],C=0;for(let _=0;_<g;++_){const A=b[v+_];A>S&&(S=A,C=_)}m[y]=C}return c.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(h,"int32",m)}const gJ={kernelName:Yg,backendName:"cpu",kernelFunc:mJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;gt(r,"argMin");let o=qt(i,r.shape);const a=zn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=yr({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=Yn(o.length,l.shape.length)),o=[o[0]],Ds("argMin",o,l.shape.length);const[h,d]=ws(l.shape,o),p=Ne(h),m=zs(p,"int32"),g=Ne(d),b=t.data.get(l.dataId).values;for(let y=0;y<m.length;++y){const v=y*g;let S=b[v],C=0;for(let _=0;_<g;++_){const A=b[v+_];A<S&&(S=A,C=_)}m[y]=C}return c.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(h,"int32",m)}const vJ={kernelName:Zg,backendName:"cpu",kernelFunc:xJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yJ=yn(Ad,n=>Math.asin(n)),bJ={kernelName:Ad,backendName:"cpu",kernelFunc:yJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SJ=yn(Md,n=>Math.asinh(n)),wJ={kernelName:Md,backendName:"cpu",kernelFunc:SJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _J=yn(Rd,n=>Math.atan(n)),CJ={kernelName:Rd,backendName:"cpu",kernelFunc:_J};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EJ=Qn((n,e)=>Math.atan2(n,e)),TJ=ms(Nd,EJ),IJ={kernelName:Nd,backendName:"cpu",kernelFunc:TJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AJ=yn(kd,n=>Math.atanh(n)),MJ={kernelName:kd,backendName:"cpu",kernelFunc:AJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z_(n,e,t,s,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,m=r.padInfo.left,g=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=jt(r.outShape,t),y=b.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3],S=r.outShape[2]*r.outShape[3],C=r.outShape[3];for(let _=0;_<r.batchSize;++_){const A=_*v,k=_*s[0];for(let N=0;N<r.inChannels;++N)for(let D=0;D<r.outHeight;++D){const M=D*o-p,T=Math.max(0,M),I=Math.min(r.inHeight,h+M),$=A+D*S;for(let O=0;O<r.outWidth;++O){const B=O*a-m,V=Math.max(0,B),H=Math.min(r.inWidth,d+B);let q=g,P=0,K=0;for(let U=T;U<I;U+=l){const z=k+U*s[1];for(let ne=V;ne<H;ne+=c){const Y=z+ne*s[2],te=n[Y+N];i==="max"&&te>q?q=te:i==="avg"&&(P+=te,K++)}if(isNaN(q))break}const Z=$+O*C+N;y[Z]=i==="avg"?P/K:q}}}return b}function U3(n,e,t,s,r=!1,i=!1){const o=jt(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.top,g=s.padInfo.left,b=jt(e,t,n);for(let y=0;y<s.batchSize;++y)for(let v=0;v<s.inChannels;++v)for(let S=0;S<s.outHeight;++S){const C=S*a-m;let _=C;for(;_<0;)_+=c;const A=Math.min(s.inHeight,d+C);for(let k=0;k<s.outWidth;++k){const N=k*l-g;let D=N;for(;D<0;)D+=h;const M=Math.min(s.inWidth,p+N);let T=Number.NEGATIVE_INFINITY,I=-1;for(let $=_;$<A;$+=c){const O=$-C;for(let B=D;B<M;B+=h){const V=B-N,H=b.get(y,$,B,v);H>T&&(T=H,r?I=i?((y*s.inHeight+$)*s.inWidth+B)*s.inChannels+v:($*s.inWidth+B)*s.inChannels+v:I=O*p+V)}}o.set(I,y,S,k,v)}}return o}function z3(n,e,t,s,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,h=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterDepth,m=r.effectiveFilterHeight,g=r.effectiveFilterWidth,b=r.padInfo.front,y=r.padInfo.top,v=r.padInfo.left,S=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=jt(r.outShape,t),_=C.values,A=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[3]*r.outShape[4],D=r.outShape[4];for(let M=0;M<r.batchSize;++M){const T=M*A,I=M*s[0];for(let $=0;$<r.inChannels;++$)for(let O=0;O<r.outDepth;++O){const B=O*o-b;let V=B;for(;V<0;)V+=c;const H=Math.min(r.inDepth,p+B),q=T+O*k;for(let P=0;P<r.outHeight;++P){const K=P*a-y;let Z=K;for(;Z<0;)Z+=h;const U=Math.min(r.inHeight,m+K),z=q+P*N;for(let ne=0;ne<r.outWidth;++ne){const Y=ne*l-v;let te=Y;for(;te<0;)te+=d;const he=Math.min(r.inWidth,g+Y),se=z+ne*D;let Q=S,de=0,ce=0;for(let He=V;He<H;He+=c){const Le=I+He*s[1];for(let j=Z;j<U;j+=h){const ht=Le+j*s[2];for(let We=te;We<he;We+=d){const Ke=ht+We*s[3],Oe=n[Ke+$];if(i==="max"&&Oe>Q?Q=Oe:i==="avg"&&(de+=Oe,ce++),isNaN(Q))break}if(isNaN(Q))break}if(isNaN(Q))break}const De=se+$;_[De]=i==="avg"?de/Math.max(ce,1):Q}}}}return C}function RJ(n,e){const t=jt(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.front,m=e.padInfo.top,g=e.padInfo.left;for(let b=0;b<e.batchSize;++b)for(let y=0;y<e.inChannels;++y)for(let v=0;v<e.outDepth;++v){const S=v*s-p;let C=S;for(;C<0;)C+=o;const _=Math.min(e.inDepth,c+S);for(let A=0;A<e.outHeight;++A){const k=A*r-m;let N=k;for(;N<0;)N+=a;const D=Math.min(e.inHeight,h+k);for(let M=0;M<e.outWidth;++M){const T=M*i-g;let I=T;for(;I<0;)I+=l;const $=Math.min(e.inWidth,d+T);let O=Number.NEGATIVE_INFINITY,B=-1;for(let V=C;V<_;V+=o){const H=V-S;for(let q=N;q<D;q+=a){const P=q-k;for(let K=I;K<$;K+=l){const Z=K-T,U=n.get(b,V,q,K,y);U>=O&&(O=U,B=H*h*d+P*h+Z)}}}t.set(B,b,v,A,M,y)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;gt(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(Vs(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=gi(r.shape,i,o,c,a,l);let d;if(h.filterWidth===1&&h.filterHeight===1&&mn(h.inShape,h.outShape))d=yo({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,m=Ct(r.shape),g=z_(p,r.shape,r.dtype,m,h,"avg");d=t.makeTensorInfo(h.outShape,r.dtype,g.values)}return d}const NJ={kernelName:Qg,backendName:"cpu",kernelFunc:kJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;gt(r,"avgPool3d");const h=Yo(r.shape,i,o,1,a,l,c),d=t.data.get(r.dataId).values,p=z3(d,r.shape,r.dtype,Ct(r.shape),h,"avg");return t.makeTensorInfo(p.shape,"float32",p.values)}const $J={kernelName:Jg,backendName:"cpu",kernelFunc:DJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;gt([r,i],"avgPool3DGrad");const h=Yo(i.shape,o,a,1,l,c),d=h.strideDepth,p=h.strideHeight,m=h.strideWidth,g=h.filterDepth,b=h.filterHeight,y=h.filterWidth,v=h.dilationDepth,S=h.dilationHeight,C=h.dilationWidth,_=h.effectiveFilterDepth,A=h.effectiveFilterHeight,k=h.effectiveFilterWidth,N=_-1-h.padInfo.front,D=k-1-h.padInfo.left,M=A-1-h.padInfo.top,T=jt(i.shape,"float32"),I=1/(g*b*y),$=t.bufferSync(r);for(let O=0;O<h.batchSize;++O)for(let B=0;B<h.inChannels;++B)for(let V=0;V<h.inDepth;++V)for(let H=0;H<h.inHeight;++H)for(let q=0;q<h.inWidth;++q){const P=V-N,K=H-M,Z=q-D;let U=0;for(let z=0;z<_;z+=v){const ne=(P+z)/d;if(!(ne<0||ne>=h.outDepth||Math.floor(ne)!==ne))for(let Y=0;Y<A;Y+=S){const te=(K+Y)/p;if(!(te<0||te>=h.outHeight||Math.floor(te)!==te))for(let he=0;he<k;he+=C){const se=(Z+he)/m;if(se<0||se>=h.outWidth||Math.floor(se)!==se)continue;const Q=$.get(O,ne,te,se,B);U+=Q}}}T.set(U*I,O,V,H,q,B)}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const LJ={kernelName:TS,backendName:"cpu",kernelFunc:FJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;gt([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,h=gi(o.shape,a,l,1,c),d=h.strideHeight,p=h.strideWidth,m=h.filterHeight,g=h.filterWidth,b=h.dilationHeight,y=h.dilationWidth,v=h.effectiveFilterHeight,S=h.effectiveFilterWidth,C=S-1-h.padInfo.left,_=v-1-h.padInfo.top,A=jt(o.shape,"float32"),k=1/(m*g),N=t.data.get(r.dataId).values,D=jt(r.shape,"float32",N);for(let M=0;M<h.batchSize;++M)for(let T=0;T<h.inChannels;++T)for(let I=0;I<h.inHeight;++I)for(let $=0;$<h.inWidth;++$){const O=I-_,B=$-C;let V=0;for(let H=0;H<v;H+=b){const q=(O+H)/d;if(!(q<0||q>=h.outHeight||Math.floor(q)!==q))for(let P=0;P<S;P+=y){const K=(B+P)/p;if(K<0||K>=h.outWidth||Math.floor(K)!==K)continue;const Z=D.get(M,q,K,T);V+=Z}}A.set(V*k,M,I,$,T)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const OJ={kernelName:ES,backendName:"cpu",kernelFunc:PJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:o,mean:a,variance:l}=e;W(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),gt([r,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const h=t.data.get(r.dataId).values,d=t.data.get(a.dataId).values,p=t.data.get(l.dataId).values,m=i?t.data.get(i.dataId).values:new Float32Array([1]),g=o?t.data.get(o.dataId).values:new Float32Array([0]),b=new Float32Array(h.length),y=g.length,v=m.length,S=p.length,C=d.length;let _=0,A=0,k=0,N=0;for(let D=0;D<h.length;++D)b[D]=g[_++]+(h[D]-d[A++])*m[k++]/Math.sqrt(p[N++]+c),_>=y&&(_=0),A>=C&&(A=0),k>=v&&(k=0),N>=S&&(N=0);return t.makeTensorInfo(r.shape,r.dtype,b)}const zJ={kernelName:d0,backendName:"cpu",kernelFunc:UJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;gt([r],"batchToSpaceND");const a=i.reduce((v,S)=>v*S),l=If(r.shape,i,a),c=Af(l.length,i.length),h=Mf(r.shape,i,a),d=Yw(o,i.length),p=Zw(h,o,i.length),m=Mn({inputs:{x:r},backend:t,attrs:{shape:l}}),g=yr({inputs:{x:m},backend:t,attrs:{perm:c}}),b=Mn({inputs:{x:g},backend:t,attrs:{shape:h}}),y=sc({inputs:{x:b},backend:t,attrs:{begin:d,size:p}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),y}const VJ={kernelName:t0,backendName:"cpu",kernelFunc:BJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=F_(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const WJ={kernelName:IS,backendName:"cpu",kernelFunc:GJ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HJ(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,a=Ut(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const XJ={kernelName:hR,backendName:"cpu",kernelFunc:HJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jJ=yn(Fd,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),qJ={kernelName:Fd,backendName:"cpu",kernelFunc:jJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJ=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(Ne(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const h=a[c],d=l[c];s[c]=Math.hypot(h,d)}return t.makeOutput(s,e.shape,"float32")},YJ={kernelName:n0,backendName:"cpu",kernelFunc:KJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Au(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const ZJ={kernelName:HS,backendName:"cpu",kernelFunc:Au};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mu(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=qt(r,e[0].shape)[0],o=e.map(b=>b.shape);jw(o,i);let a=uo(e.map(b=>b.shape),i);if(Ne(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(b=>Ne(b.shape)>0);if(l.length===1)return yo({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const b=l.map(_=>nc({inputs:{input:_},backend:t})),y=l.map(_=>Au({inputs:{input:_},backend:t})),v=Mu({inputs:b,backend:t,attrs:{axis:i}}),S=Mu({inputs:y,backend:t,attrs:{axis:i}}),C=Nr({inputs:{real:v,imag:S},backend:t});return b.forEach(_=>t.disposeIntermediateTensorInfo(_)),y.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(S),C}const c=l.map(b=>{const v=[-1,Ne(b.shape.slice(i))];return Mn({inputs:{x:b},backend:t,attrs:{shape:v}})}),h=c.map(b=>({vals:t.data.get(b.dataId).values,shape:b.shape}));a=uo(c.map(b=>b.shape),1);const d=c[0].shape[0]===1,p=H$(h,a,e[0].dtype,d),m=uo(l.map(b=>b.shape),i),g=t.makeTensorInfo(m,e[0].dtype,p);return c.forEach(b=>t.disposeIntermediateTensorInfo(b)),g}const QJ={kernelName:s0,backendName:"cpu",kernelFunc:Mu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:h}=s;gt([r,i],"conv2d");const d=Zo(l),p=Ns(r.shape,i.shape,o,c,a,h,!1,d),m=p.filterHeight,g=p.filterWidth,b=p.dilationHeight,y=p.dilationWidth,v=p.padInfo.left,S=p.padInfo.top,C=p.dataFormat==="channelsLast",_=new ks(p.outShape,r.dtype),A=Ct(r.shape),k=Ct(i.shape),N=A[0],D=C?A[1]:A[2],M=C?A[2]:1,T=C?1:A[1],I=_.strides[0],$=C?_.strides[1]:_.strides[2],O=C?_.strides[2]:1,B=C?1:_.strides[1],V=t.data.get(r.dataId).values,H=t.data.get(i.dataId).values,q=_.values;for(let P=0;P<p.batchSize;++P){const K=P*N,Z=P*I;for(let U=0;U<p.outHeight;++U){const z=Z+U*$,ne=U*p.strideHeight-S;for(let Y=0;Y<m;++Y){const te=ne+Y*b;if(te<0||te>=p.inHeight)continue;const he=Y*k[0],se=K+te*D;for(let Q=0;Q<p.outWidth;++Q){const de=z+Q*O,ce=Q*p.strideWidth-v;for(let De=0;De<g;++De){const He=ce+De*y;if(He<0||He>=p.inWidth)continue;const Le=he+De*k[1],j=se+He*M;let ht=Le;for(let We=0;We<p.inChannels;++We){const Ke=V[j+We*T];for(let Oe=0;Oe<p.outChannels;++Oe)q[de+Oe*B]+=Ke*H[ht+Oe];ht+=p.outChannels}}}}}}return t.makeTensorInfo(_.shape,_.dtype,q)}const JJ={kernelName:r0,backendName:"cpu",kernelFunc:B3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:h}=s;gt([r,i],"conv2dBackpropFilter");const d=Zo(l),p=Ns(r.shape,h,o,1,a,c,!1,d),{strideHeight:m,strideWidth:g,filterHeight:b,filterWidth:y}=p,v=p.dataFormat==="channelsLast",S=new ks(p.filterShape,"float32"),C=p.padInfo.left,_=p.padInfo.top,A=t.data.get(r.dataId).values,k=t.data.get(i.dataId).values,N=new ks(r.shape,r.dtype,A),D=new ks(i.shape,i.dtype,k);for(let M=0;M<b;++M){const T=Math.max(0,Math.ceil((_-M)/m)),I=Math.min(p.outHeight,(p.inHeight+_-M)/m);for(let $=0;$<y;++$){const O=Math.max(0,Math.ceil((C-$)/g)),B=Math.min(p.outWidth,(p.inWidth+C-$)/g);for(let V=0;V<p.inChannels;++V)for(let H=0;H<p.outChannels;++H){let q=0;for(let P=0;P<p.batchSize;++P)for(let K=T;K<I;++K){const Z=M+K*m-_;for(let U=O;U<B;++U){const z=$+U*g-C;v?q+=N.get(P,Z,z,V)*D.get(P,K,U,H):q+=N.get(P,V,Z,z)*D.get(P,H,K,U)}}S.set(q,M,$,V,H)}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const tee={kernelName:RS,backendName:"cpu",kernelFunc:eee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:h}=s;gt([r,i],"conv2dBackpropInput");const d=Ct(i.shape),p=Ct(r.shape);let m=Zo(c);const g=Ns(o,i.shape,a,1,l,h,!1,m),b=new ks(g.inShape,"float32"),y=b.values,v=t.data.get(r.dataId).values,S=t.data.get(i.dataId).values,[C,_,A]=d,{batchSize:k,filterHeight:N,filterWidth:D,inChannels:M,inHeight:T,inWidth:I,outChannels:$,outHeight:O,outWidth:B,strideHeight:V,strideWidth:H}=g;m=g.dataFormat;const q=N-1-g.padInfo.top,P=D-1-g.padInfo.left,K=m==="channelsLast",Z=b.strides[0],U=K?b.strides[1]:b.strides[2],z=K?b.strides[2]:1,ne=K?1:b.strides[1],Y=p[0],te=K?p[1]:p[2],he=K?p[2]:1,se=K?1:p[1];for(let Q=0;Q<k;++Q)for(let de=0;de<M;++de)for(let ce=0;ce<T;++ce){const De=ce-q,He=Math.max(0,Math.ceil(De/V)),Le=Math.min(O,(N+De)/V);for(let j=0;j<I;++j){const ht=j-P,We=Math.max(0,Math.ceil(ht/H)),Ke=Math.min(B,(D+ht)/H);let Oe=0;for(let Ve=He;Ve<Le;++Ve){const X=Ve*V-De;for(let L=We;L<Ke;++L){const ge=L*H-ht,Re=Y*Q+te*Ve+he*L,$e=C*(N-1-X)+_*(D-1-ge)+A*de;for(let Ie=0;Ie<$;++Ie){const Xe=v[Re+se*Ie],ze=S[$e+Ie];Oe+=Xe*ze}}}const yt=Z*Q+U*ce+z*j+ne*de;y[yt]=Oe}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const see={kernelName:i0,backendName:"cpu",kernelFunc:nee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ree(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s;gt([r,i],"conv3d");const c=Ya(r.shape,i.shape,o,l,a),{filterDepth:h,filterHeight:d,filterWidth:p,dilationDepth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=c,v=y.front,S=y.left,C=y.top,_=new ks(c.outShape,r.dtype),A=t.data.get(r.dataId).values,k=t.data.get(i.dataId).values,N=_.values,D=Ct(r.shape),M=Ct(i.shape);for(let T=0;T<c.batchSize;++T){const I=T*D[0],$=T*_.strides[0];for(let O=0;O<c.outDepth;++O){const B=$+O*_.strides[1],V=O*c.strideDepth-v;for(let H=0;H<h;++H){const q=V+H*m;if(q<0||q>=c.inDepth)continue;const P=H*M[0],K=I+q*D[1];for(let Z=0;Z<c.outHeight;++Z){const U=B+Z*_.strides[2],z=Z*c.strideHeight-C;for(let ne=0;ne<d;++ne){const Y=z+ne*g;if(Y<0||Y>=c.inHeight)continue;const te=P+ne*M[1],he=K+Y*D[2];for(let se=0;se<c.outWidth;++se){const Q=U+se*c.outChannels,de=se*c.strideWidth-S;for(let ce=0;ce<p;++ce){const De=de+ce*b;if(De<0||De>=c.inWidth)continue;const He=te+ce*M[2],Le=he+De*c.inChannels;let j=He;for(let ht=0;ht<c.inChannels;++ht){const We=A[Le+ht];for(let Ke=0;Ke<c.outChannels;++Ke)N[Q+Ke]+=We*k[j+Ke];j+=c.outChannels}}}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const iee={kernelName:o0,backendName:"cpu",kernelFunc:ree};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s;gt([r,i],"conv3dBackpropFilterV2");const c=Ct(r.shape),h=Ct(i.shape),d=Ya(r.shape,l,o,1,a),p=d.strideDepth,m=d.strideHeight,g=d.strideWidth,b=d.filterDepth,y=d.filterHeight,v=d.filterWidth,S=new ks(d.filterShape,"float32"),C=S.values,[_,A,k,N]=S.strides,D=t.data.get(i.dataId).values,[M,T,I,$]=h,O=t.data.get(r.dataId).values,[B,V,H,q]=c,P=d.padInfo.front,K=d.padInfo.left,Z=d.padInfo.top;for(let U=0;U<b;++U){const z=Math.max(0,Math.ceil((P-U)/p)),ne=Math.min(d.outDepth,(d.inDepth+P-U)/p),Y=U*_;for(let te=0;te<y;++te){const he=Math.max(0,Math.ceil((Z-te)/m)),se=Math.min(d.outHeight,(d.inHeight+Z-te)/m),Q=te*A+Y;for(let de=0;de<v;++de){const ce=Math.max(0,Math.ceil((K-de)/g)),De=Math.min(d.outWidth,(d.inWidth+K-de)/g),He=de*k+Q;for(let Le=0;Le<d.inChannels;++Le){const j=Le*N+He;for(let ht=0;ht<d.outChannels;++ht){let We=0;for(let Ke=0;Ke<d.batchSize;++Ke){const Oe=Ke*B,yt=Ke*M;for(let Ve=z;Ve<ne;++Ve){const L=(U+Ve*p-P)*V+Oe,ge=Ve*T+yt;for(let Re=he;Re<se;++Re){const Ie=(te+Re*m-Z)*H+L,Xe=Re*I+ge;for(let ze=ce;ze<De;++ze){const ut=(de+ze*g-K)*q+Ie,Pe=ze*$+Xe;We+=O[ut+Le]*D[Pe+ht]}}}}C[j+ht]=We}}}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const aee={kernelName:kS,backendName:"cpu",kernelFunc:oee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lee(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s;gt([r],"conv3dBackpropInputV2");const c=Ct(r.shape),h=Ct(i.shape),d=Ya(l,i.shape,a,1,o),p=new ks(d.inShape,"float32"),m=p.values,[g,b,y,v]=p.strides,S=t.data.get(r.dataId).values,[C,_,A,k]=c,N=t.data.get(i.dataId).values,[D,M,T,I]=h,{batchSize:$,filterDepth:O,filterHeight:B,filterWidth:V,inChannels:H,inDepth:q,inHeight:P,inWidth:K,outChannels:Z,outDepth:U,outHeight:z,outWidth:ne,strideDepth:Y,strideHeight:te,strideWidth:he}=d,se=O-1-d.padInfo.front,Q=B-1-d.padInfo.top,de=V-1-d.padInfo.left;for(let ce=0;ce<$;++ce)for(let De=0;De<H;++De)for(let He=0;He<q;++He){const Le=He-se,j=Math.max(0,Math.ceil(Le/Y)),ht=Math.min(U,(O+Le)/Y);for(let We=0;We<P;++We){const Ke=We-Q,Oe=Math.max(0,Math.ceil(Ke/te)),yt=Math.min(z,(B+Ke)/te);for(let Ve=0;Ve<K;++Ve){const X=Ve-de,L=Math.max(0,Math.ceil(X/he)),ge=Math.min(ne,(V+X)/he);let Re=0;for(let $e=j;$e<ht;++$e){const Ie=$e*Y-Le;for(let Xe=Oe;Xe<yt;++Xe){const ze=Xe*te-Ke;for(let et=L;et<ge;++et){const ut=et*he-X,Pe=C*ce+_*$e+A*Xe+k*et,lt=D*(O-1-Ie)+M*(B-1-ze)+T*(V-1-ut)+I*De;for(let wt=0;wt<Z;++wt){const Et=S[Pe+wt],ct=N[lt+wt];Re+=Et*ct}}}}m[g*ce+b*He+y*We+v*Ve+De]=Re}}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const cee={kernelName:NS,backendName:"cpu",kernelFunc:lee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uee=yn(Ld,n=>Math.cos(n)),hee={kernelName:Ld,backendName:"cpu",kernelFunc:uee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dee=yn(Pd,n=>Math.cosh(n)),fee={kernelName:Pd,backendName:"cpu",kernelFunc:dee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pee(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,[h,d,p,m]=r.shape,g=i.shape[0],[b,y]=a,v=jt([g,b,y,m],"float32"),S=t.data.get(i.dataId).values,C=t.data.get(o.dataId).values,_=t.data.get(r.dataId).values,A=Ct(r.shape),k=Ct(v.shape);for(let N=0;N<g;N++){const D=N*4,M=S[D],T=S[D+1],I=S[D+2],$=S[D+3],O=C[N];if(O>=h)continue;const B=b>1?(I-M)*(d-1)/(b-1):0,V=y>1?($-T)*(p-1)/(y-1):0;for(let H=0;H<b;H++){const q=b>1?M*(d-1)+H*B:.5*(M+I)*(d-1);if(q<0||q>d-1){for(let P=0;P<y;P++)for(let K=0;K<m;K++){const Z=K+P*k[2]+H*k[1]+N*k[0];v.values[Z]=c}continue}if(l==="bilinear"){const P=Math.floor(q),K=Math.ceil(q),Z=q-P;for(let U=0;U<y;U++){const z=y>1?T*(p-1)+U*V:.5*(T+$)*(p-1);if(z<0||z>p-1){for(let he=0;he<m;he++){const se=he+U*k[2]+H*k[1]+N*k[0];v.values[se]=c}continue}const ne=Math.floor(z),Y=Math.ceil(z),te=z-ne;for(let he=0;he<m;he++){let se=he+ne*A[2]+P*A[1]+O*A[0];const Q=_[se];se=he+Y*A[2]+P*A[1]+O*A[0];const de=_[se];se=he+ne*A[2]+K*A[1]+O*A[0];const ce=_[se];se=he+Y*A[2]+K*A[1]+O*A[0];const De=_[se],He=Q+(de-Q)*te,Le=ce+(De-ce)*te;se=he+U*k[2]+H*k[1]+N*k[0],v.values[se]=He+(Le-He)*Z}}}else for(let P=0;P<y;++P){const K=y>1?T*(p-1)+P*V:.5*(T+$)*(p-1);if(K<0||K>p-1){for(let z=0;z<m;z++){const ne=z+P*k[2]+H*k[1]+N*k[0];v.values[ne]=c}continue}const Z=Math.round(K),U=Math.round(q);for(let z=0;z<m;z++){const ne=z+Z*A[2]+U*A[1]+O*A[0],Y=z+P*k[2]+H*k[1]+N*k[0];v.values[Y]=_[ne]}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const mee={kernelName:$S,backendName:"cpu",kernelFunc:pee};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;gt(r,"cumprod");const l=zn([i],r.shape.length);let c=r;l!=null&&(c=yr({inputs:{x:r},backend:t,attrs:{perm:l}}));const h=Yn(1,r.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const d=$r(c.dtype,"int32"),p=yS(Ne(c.shape),d),m=t.data.get(c.dataId).values,g=c.shape[c.shape.length-1],b=a?(v,S)=>v+g-S-1:(v,S)=>v+S;for(let v=0;v<m.length;v+=g)for(let S=0;S<g;S++){const C=b(v,S);if(S===0)p[C]=o?1:m[C];else{const _=b(v,S-1);p[C]=o?m[_]*p[_]:m[C]*p[_]}}const y=t.makeTensorInfo(c.shape,d,p);if(l!=null){const v=Za(l),S=yr({inputs:{x:y},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(c),S}return y}const xee={kernelName:DS,backendName:"cpu",kernelFunc:gee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;gt(r,"cumsum");const l=zn([i],r.shape.length);let c=r;l!=null&&(c=yr({inputs:{x:r},backend:t,attrs:{perm:l}}));const h=Yn(1,r.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const d=$r(c.dtype,"int32"),p=zs(Ne(c.shape),d),m=t.data.get(c.dataId).values,g=c.shape[c.shape.length-1],b=a?(v,S)=>v+g-S-1:(v,S)=>v+S;for(let v=0;v<m.length;v+=g)for(let S=0;S<g;S++){const C=b(v,S);if(S===0)p[C]=o?0:m[C];else{const _=b(v,S-1);p[C]=o?m[_]+p[_]:m[C]+p[_]}}const y=t.makeTensorInfo(c.shape,d,p);if(l!=null){const v=Za(l),S=yr({inputs:{x:y},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(c),S}return y}const yee={kernelName:a0,backendName:"cpu",kernelFunc:vee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,h=F_(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const l=t.bufferSync(r),c=t.bufferSync(i),h=V$(l,c,o,a);return t.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const See={kernelName:FS,backendName:"cpu",kernelFunc:bee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s;W(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],c=r.shape[2],h=r.shape[3],d=l*i,p=c*i,m=h/(i*i),g=t.data.get(r.dataId).values,b=new Float32Array(a*d*p*m);let y=0;for(let v=0;v<a;++v)for(let S=0;S<d;++S){const C=Math.floor(S/i),_=S%i;for(let A=0;A<p;++A){const k=Math.floor(A/i),N=A%i,D=(_*i+N)*m;for(let M=0;M<m;++M){const I=M+D+h*(k+c*(C+l*v));b[y++]=g[I]}}}return t.makeTensorInfo([a,d,p,m],r.dtype,b)}const _ee={kernelName:LS,backendName:"cpu",kernelFunc:wee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;gt([r,i],"depthwiseConv2DNative");const h=Ct(r.shape),d=Ct(i.shape);let p=l;p==null&&(p=[1,1]),W(Vs(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);const m=Ns(r.shape,i.shape,o,p,a,c,!0),{filterHeight:g,filterWidth:b,dilationHeight:y,dilationWidth:v,padInfo:S}=m,C=S.left,_=S.top,A=m.outChannels/m.inChannels,k=new ks(m.outShape,r.dtype),N=t.data.get(r.dataId).values,D=t.data.get(i.dataId).values,M=k.values;for(let T=0;T<m.batchSize;++T){const I=T*h[0],$=T*k.strides[0];for(let O=0;O<m.outHeight;++O){const B=$+O*k.strides[1],V=O*m.strideHeight-_;for(let H=0;H<g;++H){const q=V+H*y;if(q<0||q>=m.inHeight)continue;const P=H*d[0],K=I+q*h[1];for(let Z=0;Z<m.outWidth;++Z){const U=B+Z*k.strides[2],z=Z*m.strideWidth-C;for(let ne=0;ne<b;++ne){const Y=z+ne*v;if(Y<0||Y>=m.inWidth)continue;const te=P+ne*d[1],he=K+Y*m.inChannels;let se=U,Q=te;for(let de=0;de<m.inChannels;++de){const ce=N[he+de];for(let De=0;De<A;++De)M[se+De]+=ce*D[Q+De];se+=A,Q+=A}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const Cee={kernelName:l0,backendName:"cpu",kernelFunc:V3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:h}=s;gt([r,i],"depthwiseConv2dNativeBackpropFilter");const d=Ns(r.shape,h,o,a,l,c,!0),{strideHeight:p,strideWidth:m,filterHeight:g,filterWidth:b}=d,y=new ks(d.filterShape,"float32"),v=d.padInfo.left,S=d.padInfo.top,C=d.outChannels/d.inChannels,_=t.data.get(r.dataId).values,A=new ks(r.shape,r.dtype,_),k=t.data.get(i.dataId).values,N=new ks(i.shape,i.dtype,k);for(let D=0;D<g;++D){const M=Math.max(0,Math.ceil((S-D)/p)),T=Math.min(d.outHeight,(d.inHeight+S-D)/p);for(let I=0;I<b;++I){const $=Math.max(0,Math.ceil((v-I)/m)),O=Math.min(d.outWidth,(d.inWidth+v-I)/m);for(let B=0;B<d.outChannels;++B){const V=Math.trunc(B/C),H=B%C;let q=0;for(let P=0;P<d.batchSize;++P)for(let K=M;K<T;++K){const Z=D+K*p-S;for(let U=$;U<O;++U){const z=I+U*m-v;q+=A.get(P,Z,z,V)*N.get(P,K,U,B)}}y.set(q,D,I,V,H)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const Tee={kernelName:PS,backendName:"cpu",kernelFunc:Eee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iee(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:h}=s;gt([r,i],"depthwiseConv2DNativeBackpropInput");const d=Ct(r.shape),p=Ct(i.shape),m=Ns(h,i.shape,o,a,l,c,!0),g=new ks(m.inShape,"float32"),b=g.values,[y,v,S]=g.strides,C=t.data.get(r.dataId).values,[_,A,k]=d,N=t.data.get(i.dataId).values,[D,M,T]=p,{batchSize:I,filterHeight:$,filterWidth:O,inChannels:B,inHeight:V,inWidth:H,outChannels:q,outHeight:P,outWidth:K,strideHeight:Z,strideWidth:U}=m,z=$-1-m.padInfo.top,ne=O-1-m.padInfo.left,Y=q/B;for(let te=0;te<I;++te)for(let he=0;he<B;++he)for(let se=0;se<V;++se){const Q=se-z,de=Math.max(0,Math.ceil(Q/Z)),ce=Math.min(P,($+Q)/Z);for(let De=0;De<H;++De){const He=De-ne,Le=Math.max(0,Math.ceil(He/U)),j=Math.min(K,(O+He)/U);let ht=0;for(let We=de;We<ce;++We){const Ke=We*Z-Q;for(let Oe=Le;Oe<j;++Oe){const yt=Oe*U-He,Ve=_*te+A*We+k*Oe,X=D*($-1-Ke)+M*(O-1-yt)+T*he;for(let L=0;L<Y;++L){const ge=he*Y+L,Re=C[Ve+ge],$e=N[X+L];ht+=Re*$e}}}b[y*te+v*se+S*De+he]=ht}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const Aee={kernelName:OS,backendName:"cpu",kernelFunc:Iee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(n){const{inputs:e,backend:t}=n,{x:s}=e,r=Ne(s.shape),i=t.data.get(s.dataId).values,o=jt([r,r],s.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*r+c]=i[c];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const Ree={kernelName:dR,backendName:"cpu",kernelFunc:Mee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kee={kernelName:c0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:a}=t,l=e,c=l.data.get(s.dataId).values,h=s.shape.length,d=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:m,inHeight:g,inWidth:b,inChannels:y,outHeight:v,outWidth:S,padInfo:C,strideHeight:_,strideWidth:A,filterHeight:k,filterWidth:N,dilationHeight:D,dilationWidth:M,outShape:T}=wf(s.shape,r.shape,i,o,"NHWC",a),I=Ne(T),$=T.length,O=jn(s.dtype,I);for(let V=0;V<m;++V)for(let H=0;H<v;++H){const q=H*_-C.top;for(let P=0;P<S;++P){const K=P*A-C.left;for(let Z=0;Z<y;++Z){let U=Number.MIN_SAFE_INTEGER;for(let ne=0;ne<k;++ne){const Y=q+ne*D;if(Y>=0&&Y<g)for(let te=0;te<N;++te){const he=K+te*M;if(he>=0&&he<b){const se=lo([V,Y,he,Z],h,Ct(s.shape)),Q=lo([ne,te,Z],p,Ct(r.shape)),de=c[se]+d[Q];de>U&&(U=de)}}}const z=lo([V,H,P,Z],$,Ct(T));O[z]=U}}}return{dataId:l.write(ac(O,s.dtype),T,s.dtype),shape:T,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nee={kernelName:rb,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,h=Li(s.shape,c.data.get(s.dataId).values),d=Li(r.shape,c.data.get(r.dataId).values),{batchSize:p,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:v,padInfo:S,strideHeight:C,strideWidth:_,filterHeight:A,filterWidth:k,dilationHeight:N,dilationWidth:D,outShape:M}=wf(s.shape,r.shape,o,a,"NHWC",l);W(i.rank===M.length,()=>`Error in ${rb}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const T=Li(M,c.data.get(i.dataId).values),I=lR(r.shape,r.dtype);for(let O=0;O<p;++O)for(let B=0;B<y;++B){const V=B*C-S.top;for(let H=0;H<v;++H){const q=H*_-S.left;for(let P=0;P<b;++P){let K=Number.MIN_SAFE_INTEGER,Z=0,U=0;for(let z=0;z<A;++z){const ne=V+z*N;if(ne>=0&&ne<m)for(let Y=0;Y<k;++Y){const te=q+Y*D;if(te>=0&&te<g){const he=h[O][ne][te][P]+d[z][Y][P];he>K&&(K=he,Z=z,U=Y)}}}I[Z][U][P]+=T[O][B][H][P]}}}return{dataId:c.write(ac(I,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dee={kernelName:sb,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,h=Li(s.shape,c.data.get(s.dataId).values),d=Li(r.shape,c.data.get(r.dataId).values),{batchSize:p,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:v,padInfo:S,strideHeight:C,strideWidth:_,filterHeight:A,filterWidth:k,dilationHeight:N,dilationWidth:D,outShape:M}=wf(s.shape,r.shape,o,a,"NHWC",l);W(i.rank===M.length,()=>`Error in ${sb}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const T=Li(M,c.data.get(i.dataId).values),I=lR(s.shape,s.dtype);for(let O=0;O<p;++O)for(let B=0;B<y;++B){const V=B*C-S.top;for(let H=0;H<v;++H){const q=H*_-S.left;for(let P=0;P<b;++P){let K=Number.MIN_SAFE_INTEGER,Z=V<0?0:V,U=q<0?0:q;for(let z=0;z<A;++z){const ne=V+z*N;if(ne>=0&&ne<m)for(let Y=0;Y<k;++Y){const te=q+Y*D;if(te>=0&&te<g){const he=h[O][ne][te][P]+d[z][Y][P];he>K&&(K=he,Z=ne,U=te)}}}I[O][Z][U][P]+=T[O][B][H][P]}}}return{dataId:c.write(ac(I,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ee(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:o}=s,{contextOptions:a,imageOptions:l}=o||{},c=(l==null?void 0:l.alpha)||1,h=(a==null?void 0:a.contextType)||"2d";if(h!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const d=i.getContext(h,(a==null?void 0:a.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${h} type.`);const[p,m]=r.shape.slice(0,2),g=r.shape.length===2?1:r.shape[2],b=t.data.get(r.dataId).values,y=r.dtype==="float32"?255:1,v=new Uint8ClampedArray(m*p*4);for(let C=0;C<p*m;++C){const _=[0,0,0,255*c];for(let k=0;k<g;k++){const N=b[C*g+k];if(r.dtype==="float32"){if(N<0||N>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`)}else if(r.dtype==="int32"&&(N<0||N>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);g===1?(_[0]=N*y,_[1]=N*y,_[2]=N*y):_[k]=N*y}const A=C*4;v[A+0]=Math.round(_[0]),v[A+1]=Math.round(_[1]),v[A+2]=Math.round(_[2]),v[A+3]=Math.round(_[3])}i.width=m,i.height=p;const S=new ImageData(v,m,p);return d.putImageData(S,0,0),r}const Fee={kernelName:p5,backendName:"cpu",kernelFunc:$ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Of(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;gt(r,"sum");let a;r.dtype==="bool"?a=Xa({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):a=yo({inputs:{x:r},backend:t});const l=a.shape.length,c=qt(i,a.shape),h=zn(c,l);let d=c,p=a;h!=null&&(p=yr({inputs:{x:a},backend:t,attrs:{perm:h}}),d=Yn(d.length,l)),Ds("sum",d,p.shape.length);const[m,g]=ws(p.shape,d),b=$r(p.dtype,"int32");let y=Ag(t,m,b);const v=Ne(g),S=t.data.get(y.dataId).values,C=t.data.get(p.dataId).values;for(let _=0;_<S.length;++_){const A=_*v;let k=0;for(let N=0;N<v;++N)k+=C[A+N];S[_]=k}if(o){const _=rs(y.shape,c),A=y;y=Mn({inputs:{x:y},backend:t,attrs:{shape:_}}),t.disposeIntermediateTensorInfo(A)}return t.disposeIntermediateTensorInfo(a),h!=null&&t.disposeIntermediateTensorInfo(p),y}const Lee={kernelName:V0,backendName:"cpu",kernelFunc:Of};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pee(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=i_(r,i.length);a_(o.length,l,i);const{path:c,steps:h}=l_(a,l),d=h.length;let p=null,m=o.length;const g=[];for(let b=0;b<d;++b){for(const y of h[b]){const{permutationIndices:v,expandDims:S}=o_(m,l[y]);let C;c_(v)?C=i[y]:(C=yr({inputs:{x:i[y]},backend:t,attrs:{perm:v}}),g.push(C));const _=C.shape.slice();for(let A=0;A<S.length;++A)_.splice(S[A],0,1);mn(C.shape,_)||(C=Mn({inputs:{x:C},backend:t,attrs:{shape:_}}),g.push(C)),p===null?p=C:(p=xx({inputs:{a:C,b:p},backend:t}),g.push(p))}b<d-1&&(c[b]>=0&&(p=Of({inputs:{x:p},backend:t,attrs:{axis:c[b]-(o.length-m),keepDims:!1}}),g.push(p)),m--)}for(const b of g)b!==p&&t.disposeIntermediateTensorInfo(b);return p}const Oee={kernelName:US,backendName:"cpu",kernelFunc:Pee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uee(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;gt([s,r],"eluGrad");const i=new Float32Array(Ne(r.shape)),o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?i[l]=a[l]:i[l]=a[l]*(c+1)}return t.makeTensorInfo(r.shape,"float32",i)}const zee={kernelName:zS,backendName:"cpu",kernelFunc:Uee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bee=Qw,Vee=Jw,Gee=e_,Wee=t_,Hee=n_,Xee=s_,jee=yn(zd,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+Bee*t);return e*(1-((((Xee*s+Hee)*s+Wee)*s+Gee)*s+Vee)*s*Math.exp(-t*t))}),qee={kernelName:zd,backendName:"cpu",kernelFunc:jee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kg(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(W(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Mn({inputs:{x:r},backend:t,attrs:{shape:a}})}const Kee={kernelName:h0,backendName:"cpu",kernelFunc:kg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yee=Qn((n,e)=>n/e),B_=ms(Od,Yee),kb={kernelName:Od,backendName:"cpu",kernelFunc:B_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G3(n,e,t){const s=n.shape,r=s[0],i=s[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[r,i],h=Ne(c),d=Us("float32",h),p=Us("float32",h);for(let y=0;y<r;y++){const v=sc({inputs:{x:a},backend:t,attrs:{begin:[y,0],size:[1,i]}}),S=sc({inputs:{x:l},backend:t,attrs:{begin:[y,0],size:[1,i]}}),C=Nr({inputs:{real:v,imag:S},backend:t}),{real:_,imag:A}=Zee(C,e,t),k=jo(_,A);for(let N=0;N<i;N++){const D=r_(k,N);d[y*i+N]=D.real,p[y*i+N]=D.imag}t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(C)}const m=t.makeTensorInfo(c,"float32",d),g=t.makeTensorInfo(c,"float32",p),b=Nr({inputs:{real:m,imag:g},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),b}function Zee(n,e,t){const s=Ne(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(Qee(s)){const a=Nb(i,o,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),h=t.makeTensorInfo(l,"float32",a.imag),d=t.makeTensorInfo([],"float32",Ka(s,"float32")),p=yo({inputs:{x:d},backend:t}),m=kb.kernelFunc({inputs:{a:c,b:d},backend:t}),g=kb.kernelFunc({inputs:{a:h,b:p},backend:t}),b=t.data.get(m.dataId).values,y=t.data.get(g.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),{real:b,imag:y}}return a}else{const a=jo(i,o),l=Jee(a,s,e);return nN(l)}}function Qee(n){return(n&n-1)===0}function Nb(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=jo(n,e),o=t/2,a=sN(i),l=a.real,c=a.imag,h=[l.length],d=r.makeTensorInfo(h,"float32",l),p=r.makeTensorInfo(h,"float32",c),m=Nr({inputs:{real:d,imag:p},backend:r}),g=rN(i),b=g.real,y=g.imag,v=[b.length],S=r.makeTensorInfo(v,"float32",b),C=r.makeTensorInfo(v,"float32",y),_=Nr({inputs:{real:S,imag:C},backend:r}),A=Nb(l,c,o,s,r),k=A.real,N=A.imag,D=[k.length],M=r.makeTensorInfo(D,"float32",k),T=r.makeTensorInfo(D,"float32",N),I=Nr({inputs:{real:M,imag:T},backend:r}),$=Nb(b,y,o,s,r),O=$.real,B=$.imag,V=[O.length],H=r.makeTensorInfo(V,"float32",O),q=r.makeTensorInfo(V,"float32",B),P=Nr({inputs:{real:H,imag:q},backend:r}),K=oN(t,s),Z=[K.real.length],U=r.makeTensorInfo(Z,"float32",K.real),z=r.makeTensorInfo(Z,"float32",K.imag),ne=Nr({inputs:{real:U,imag:z},backend:r}),Y=xx({inputs:{a:ne,b:P},backend:r}),te=Iu({inputs:{a:I,b:Y},backend:r}),he=U_({inputs:{a:I,b:Y},backend:r}),se=nc({inputs:{input:te},backend:r}),Q=nc({inputs:{input:he},backend:r}),de=Au({inputs:{input:te},backend:r}),ce=Au({inputs:{input:he},backend:r}),De=Mu({inputs:[se,Q],backend:r,attrs:{axis:0}}),He=Mu({inputs:[de,ce],backend:r,attrs:{axis:0}}),Le=r.data.get(De.dataId).values,j=r.data.get(He.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(Y),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(ce),r.disposeIntermediateTensorInfo(De),r.disposeIntermediateTensorInfo(He),{real:Le,imag:j}}function Jee(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,o=0;for(let a=0;a<e;a++){const l=aN(r*a,e,t),c=r_(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(i/=e,o/=e),iN(s,i,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ete(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Ne(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Mn({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),l=G3(a,!1,t),c=Mn({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const tte={kernelName:BS,backendName:"cpu",kernelFunc:ete};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,o=i||Lu(r),a=jn(o,Ne(s));return ste(a,r,o),e.makeTensorInfo(s,o,a)}const nte={kernelName:VS,backendName:"cpu",kernelFunc:V_};function ste(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rte={kernelName:GS,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=Us(s.dtype,Ne(s.shape)),[o,a,l,c]=s.shape,h=r.data.get(s.dataId).values;for(let p=0;p<o;p++){const m=p*l*a*c;for(let g=0;g<a;g++){const b=g*(l*c);for(let y=0;y<l;y++){const v=y*c;for(let S=0;S<c;S++){const C=Math.round(l-y-1),_=m+b+v+S;let A=h[_];if(C>=0&&C<l){const k=C*c,N=m+b+k+S;A=h[N]}i[_]=A}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ite(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=s;let b=B3({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(o){const y=b;if(h==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const v=Mn({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});b=Iu({inputs:{a:b,b:v},backend:t}),t.disposeIntermediateTensorInfo(v)}else b=Iu({inputs:{a:b,b:o},backend:t});t.disposeIntermediateTensorInfo(y)}if(m){const y=b;if(h==="NCHW"&&m==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const v=Mn({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});b=Rg(t,b,m,v,g),t.disposeIntermediateTensorInfo(v)}else b=Rg(t,b,m,a,g);t.disposeIntermediateTensorInfo(y)}return b}const ote={kernelName:hg,backendName:"cpu",kernelFunc:ite};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ate(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=s;let b=V3({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(o){const y=b;b=Iu({inputs:{a:b,b:o},backend:t}),t.disposeIntermediateTensorInfo(y)}if(m){const y=b;b=Rg(t,b,m,a,g),t.disposeIntermediateTensorInfo(y)}return b}const lte={kernelName:kR,backendName:"cpu",kernelFunc:ate};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cte(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=Ne(s.shape),o=r.shape,a=o[o.length-1],[l,c,h,d]=Bw(s,r);if(c===0)return t.makeTensorInfo(l,s.dtype,[]);const p=t.data.get(r.dataId).values,m=t.bufferSync(s),g=J$(p,m,s.dtype,c,a,h,d,s.shape,i);return t.makeTensorInfo(l,s.dtype,g.values)}const ute={kernelName:fR,backendName:"cpu",kernelFunc:cte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s;gt([r,i],"gatherV2");const l=qt(o,r.shape)[0],c=t.data.get(i.dataId).values,h=r.shape[l];for(let _=0;_<c.length;++_){const A=c[_];W(A<=h-1&&A>=0,()=>`GatherV2: the index value ${A} is not in [0, ${h-1}]`)}let d=a;a==null&&(d=0);const p=Ne(i.shape),m=h_(r,i,l,d),g=Mn({inputs:{x:r},backend:t,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),b=Mn({inputs:{x:i},backend:t,attrs:{shape:[m.batchSize,p/m.batchSize]}}),y=[m.batchSize,m.outerSize,p/m.batchSize,m.sliceSize],v=t.bufferSync(b),S=t.bufferSync(g),C=e3(S,v,y);return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),t.makeTensorInfo(m.outputShape,C.dtype,C.values)}const dte={kernelName:f0,backendName:"cpu",kernelFunc:hte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fte(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Ne(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Mn({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),l=G3(a,!0,t),c=Mn({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const pte={kernelName:WS,backendName:"cpu",kernelFunc:fte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mte=yn(jd,n=>Number.isFinite(n)?1:0,"bool"),gte={kernelName:jd,backendName:"cpu",kernelFunc:mte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xte=yn(qd,n=>Math.abs(n)===1/0?1:0,"bool"),vte={kernelName:qd,backendName:"cpu",kernelFunc:xte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yte=yn(Kd,n=>Number.isNaN(n)?1:0,"bool"),bte={kernelName:Kd,backendName:"cpu",kernelFunc:yte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ste(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=i3(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const wte={kernelName:pR,backendName:"cpu",kernelFunc:Ste};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _te=yn(Zd,n=>Math.log1p(n)),Cte={kernelName:Zd,backendName:"cpu",kernelFunc:_te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ete=Qn((n,e)=>n&&e),Tte=ms(v0,Ete,null,"bool"),Ite={kernelName:v0,backendName:"cpu",kernelFunc:Tte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ate=yn(y0,n=>n?0:1,"bool"),Mte={kernelName:y0,backendName:"cpu",kernelFunc:Ate};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rte=Qn((n,e)=>n||e),kte=ms(b0,Rte,null,"bool"),Nte={kernelName:b0,backendName:"cpu",kernelFunc:kte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s;gt(r,"LRN");const c=r.shape[3],h=c-1,d=t.data.get(r.dataId).values,p=Ne(r.shape),m=new Float32Array(p);function g(b){const y=b%c;let v=b-y+Math.max(0,y-i);const S=b-y+Math.min(y+i,h);let C=0;for(;v<=S;v++){const _=d[v];C+=_*_}return C}for(let b=0;b<p;b++){const y=g(b),v=d[b]*Math.pow(o+a*y,-l);m[b]=v}return t.makeTensorInfo(r.shape,r.dtype,m)}const $te={kernelName:S0,backendName:"cpu",kernelFunc:Dte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:h}=s;gt(o,"LRNGrad");const d=Ne(o.shape),p=o.shape[3],m=t.data.get(o.dataId).values,g=t.data.get(r.dataId).values,b=t.data.get(i.dataId).values,y=new Float32Array(d),v=d;for(let S=0;S<v;S++){const C=S%p,_=S-C+Math.max(0,C-a),A=S-C+Math.min(p,C+a+1);let k=0;for(let N=_;N<A;N++)k+=Math.pow(g[N],2);k=c*k+l;for(let N=_;N<A;N++){let D=-2*c*h*g[N]*b[S]/k;S===N&&(D+=Math.pow(k,-h)),D*=m[S],y[N]+=D}}return t.makeTensorInfo(o.shape,r.dtype,y)}const Lte={kernelName:XS,backendName:"cpu",kernelFunc:Fte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=t;let l=r.shape;const c=l.length,h=qt(i,l);let d=h;const p=zn(d,c);let m=a.data.get(r.dataId).values;if(p!=null){const _=new Array(c);for(let A=0;A<_.length;A++)_[A]=l[p[A]];m=P_(m,l,r.dtype,p,_),d=Yn(d.length,c),l=_}gt(r,"max"),Ds("max",d,c);const[g,b]=ws(l,d),y=Ne(b),v=a3(m,y,g,r.dtype),S=a.write(v,g,r.dtype);let C=g;return o&&(C=rs(g,h)),{dataId:S,shape:C,dtype:r.dtype}}const Pte={kernelName:w0,backendName:"cpu",kernelFunc:W3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ote(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;gt(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(Vs(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=gi(r.shape,i,o,c,a,l);let d;if(h.filterWidth===1&&h.filterHeight===1&&mn(h.inShape,h.outShape))d=yo({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,m=Ct(r.shape),g=z_(p,r.shape,r.dtype,m,h,"max");d=t.makeTensorInfo(h.outShape,r.dtype,g.values)}return d}const Ute={kernelName:_0,backendName:"cpu",kernelFunc:Ote};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;gt(r,"maxPool3d");const h=Yo(r.shape,i,o,1,a,l,c),d=t.data.get(r.dataId).values,p=z3(d,r.shape,r.dtype,Ct(r.shape),h,"max");return t.makeTensorInfo(p.shape,"float32",p.values)}const Bte={kernelName:C0,backendName:"cpu",kernelFunc:zte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vte(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;gt([r,i],"maxPool3DGrad");const h=Yo(i.shape,o,a,1,l,c),d=t.bufferSync(i),p=RJ(d,h),m=h.strideDepth,g=h.strideHeight,b=h.strideWidth,y=h.dilationDepth,v=h.dilationHeight,S=h.dilationWidth,C=h.effectiveFilterDepth,_=h.effectiveFilterHeight,A=h.effectiveFilterWidth,k=C-1-h.padInfo.front,N=A-1-h.padInfo.left,D=_-1-h.padInfo.top,M=jt(i.shape,"float32"),T=t.bufferSync(r);for(let I=0;I<h.batchSize;++I)for(let $=0;$<h.inChannels;++$)for(let O=0;O<h.inDepth;++O)for(let B=0;B<h.inHeight;++B)for(let V=0;V<h.inWidth;++V){const H=O-k,q=B-D,P=V-N;let K=0;for(let Z=0;Z<C;Z+=y){const U=(H+Z)/m;if(!(U<0||U>=h.outDepth||Math.floor(U)!==U))for(let z=0;z<_;z+=v){const ne=(q+z)/g;if(!(ne<0||ne>=h.outHeight||Math.floor(ne)!==ne))for(let Y=0;Y<A;Y+=S){const te=(P+Y)/b;if(te<0||te>=h.outWidth||Math.floor(te)!==te)continue;const he=C*_*A-1-p.get(I,U,ne,te,$),se=Z*_*A+z*A+Y,Q=he===se?1:0;if(Q===0)continue;const de=T.get(I,U,ne,te,$);K+=de*Q}}}M.set(K,I,O,B,V,$)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const Gte={kernelName:qS,backendName:"cpu",kernelFunc:Vte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wte(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;gt([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=gi(a.shape,l,c,1,h,d),m=t.data.get(a.dataId).values,g=jt(p.outShape,a.dtype,U3(m,a.shape,a.dtype,p).values),b=p.strideHeight,y=p.strideWidth,v=p.dilationHeight,S=p.dilationWidth,C=p.effectiveFilterHeight,_=p.effectiveFilterWidth,A=_-1-p.padInfo.left,k=C-1-p.padInfo.top,N=jt(a.shape,"float32"),D=t.data.get(r.dataId).values,M=jt(r.shape,"float32",D);for(let T=0;T<p.batchSize;++T)for(let I=0;I<p.inChannels;++I)for(let $=0;$<p.inHeight;++$)for(let O=0;O<p.inWidth;++O){const B=$-k,V=O-A;let H=0;for(let q=0;q<C;q+=v){const P=(B+q)/b;if(!(P<0||P>=p.outHeight||Math.floor(P)!==P))for(let K=0;K<_;K+=S){const Z=(V+K)/y;if(Z<0||Z>=p.outWidth||Math.floor(Z)!==Z)continue;const U=C*_-1-g.get(T,P,Z,I),z=q*_+K,ne=U===z?1:0;if(ne===0)continue;const Y=M.get(T,P,Z,I);H+=Y*ne}}N.set(H,T,$,O,I)}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const Hte={kernelName:jS,backendName:"cpu",kernelFunc:Wte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xte(n,e,t,s,r){const i=Ct(e),o=z_(n,e,t,i,r,"max"),a=U3(n,e,t,r,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jte={kernelName:mR,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;gt(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,h=gi(s.shape,r,i,[1,1],o),[d,p]=Xte(c,s.shape,s.dtype,a,h),m=l.write(d,h.outShape,s.dtype),g=l.write(p,h.outShape,s.dtype);return[{dataId:m,shape:h.outShape,dtype:s.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=qt(i,r.shape),c=ws(r.shape,a)[1],h=Ne(c),d=[],p=t.makeTensorInfo([],"float32",new Float32Array([h]));d.push(p);const m=Xa({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});d.push(m);const g=B_({inputs:{a:m,b:p},backend:t});d.push(g);const b=Of({inputs:{x:g},backend:t,attrs:{axis:i,keepDims:o}});return d.forEach(y=>t.disposeIntermediateTensorInfo(y)),b}const Kte={kernelName:E0,backendName:"cpu",kernelFunc:qte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;gt(r,"min");const a=qt(i,r.shape);let l=a;const c=zn(l,r.shape.length);let h=r;c!=null&&(h=yr({inputs:{x:r},backend:t,attrs:{perm:c}}),l=Yn(l.length,r.shape.length)),Ds("min",l,h.shape.length);const[d,p]=ws(h.shape,l),m=Ne(p),g=zs(Ne(d),h.dtype),b=t.data.get(h.dataId).values;for(let v=0;v<g.length;++v){const S=v*m;let C=b[S];for(let _=0;_<m;++_){const A=b[S+_];(Number.isNaN(A)||A<C)&&(C=A)}g[v]=C}c!=null&&t.disposeIntermediateTensorInfo(h);const y=t.makeTensorInfo(d,h.dtype,g);if(o){const v=rs(d,a),S=Mn({inputs:{x:y},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(y),S}return y}const Zte={kernelName:T0,backendName:"cpu",kernelFunc:Yte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:o}=s;gt(r,"mirrorPad");const a=i.map((C,_)=>C[0]+r.shape[_]+C[1]),l=i.map(C=>C[0]),c=i.map((C,_)=>C[0]+r.shape[_]),h=o==="reflect"?0:1,d=t.data.get(r.dataId).values,p=r.shape.length,m=Ct(r.shape),g=Ne(a),b=a.length,y=Ct(a),v=Us(r.dtype,g);for(let C=0;C<g;C++){let _=Pu(C,b,y);for(let k=0;k<b;k++)_[k]<l[k]?_[k]=l[k]*2-_[k]-h:_[k]>=c[k]&&(_[k]=(c[k]-1)*2-_[k]+h);_=_.map((k,N)=>k-l[N]);const A=lo(_,p,m);v[C]=d[A]}return{dataId:t.write(v,a,r.dtype),shape:a,dtype:r.dtype}}const Jte={kernelName:I0,backendName:"cpu",kernelFunc:Qte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ene=Qn((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),tne=ms(ef,ene),nne={kernelName:ef,backendName:"cpu",kernelFunc:tne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H3(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=r.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=qt([a],r.shape),c=W3({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),h=rs(c.shape,l),d=Mn({inputs:{x:c},backend:t,attrs:{shape:h}}),p=U_({inputs:{a:r,b:d},backend:t}),m=K$({inputs:{x:p},backend:t}),g=Of({inputs:{x:m},backend:t,attrs:{axis:l,keepDims:!1}}),b=Mn({inputs:{x:g},backend:t,attrs:{shape:h}}),y=B_({inputs:{a:m,b},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),y}const sne={kernelName:H0,backendName:"cpu",kernelFunc:H3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rne(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s;gt(r,"multinomial");const l=a?r:H3({inputs:{logits:r},backend:t,attrs:{dim:-1}}),c=l.shape[0],h=l.shape[1],d=t.data.get(l.dataId).values,p=[c,i],m=zs(Ne(p),"int32");for(let g=0;g<c;++g){const b=g*h,y=new Float32Array(h-1);y[0]=d[b];for(let C=1;C<y.length;++C)y[C]=y[C-1]+d[b+C];const v=Iw.alea(o.toString()),S=g*i;for(let C=0;C<i;++C){const _=v();m[S+C]=y.length;for(let A=0;A<y.length;A++)if(_<y[A]){m[S+C]=A;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(p,"int32",m)}const ine={kernelName:gR,backendName:"cpu",kernelFunc:rne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const one=Lw;function ane(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;gt(r,"NonMaxSuppression");const c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:d}=one(c,h,o,a,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const lne={kernelName:KS,backendName:"cpu",kernelFunc:ane};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cne=Pw;function une(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s;gt(r,"NonMaxSuppressionPadded");const h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,{selectedIndices:p,validOutputs:m}=cne(h,d,o,a,l,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([m]))]}const hne={kernelName:YS,backendName:"cpu",kernelFunc:une};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dne=Ow;function fne(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s;gt(r,"NonMaxSuppressionWithScore");const h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,p=o,m=a,g=l,b=c,{selectedIndices:y,selectedScores:v}=dne(h,d,p,m,g,b);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const pne={kernelName:ZS,backendName:"cpu",kernelFunc:fne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mne(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:l}=s;gt(r,"oneHot");const c=Ne(r.shape),h=new Float32Array(c*o);h.fill(l);const d=t.data.get(r.dataId).values;for(let p=0;p<c;++p)d[p]>=0&&d[p]<o&&(h[p*o+d[p]]=a);return t.makeTensorInfo([...r.shape,o],i,h)}const gne={kernelName:k0,backendName:"cpu",kernelFunc:mne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ng(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=nc({inputs:{input:s},backend:t}),i=Ng({inputs:{x:r},backend:t}),o=Au({inputs:{input:s},backend:t}),a=Ng({inputs:{x:o},backend:t}),l=Nr({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return V_({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const xne={kernelName:q0,backendName:"cpu",kernelFunc:Ng};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X3(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=nc({inputs:{input:s},backend:t}),i=X3({inputs:{x:r},backend:t}),o=Au({inputs:{input:s},backend:t}),a=Ng({inputs:{x:o},backend:t}),l=Nr({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return V_({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const vne={kernelName:R0,backendName:"cpu",kernelFunc:X3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return kg({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(h=>{vS(i,h.shape,"All tensors passed to stack must have matching shapes"),W(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(h=>{const d=kg({inputs:{input:h},backend:t,attrs:{dim:r}});return a.push(d),d}),c=Mu({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const yne={kernelName:N0,backendName:"cpu",kernelFunc:j3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;gt(r,"pad");const a=i.map((S,C)=>S[0]+r.shape[C]+S[1]),l=i.map(S=>S[0]),c=t.data.get(r.dataId).values,h=Ne(r.shape),d=r.shape.length,p=Ct(r.shape),m=Ne(a),g=a.length,b=Ct(a),y=Us(r.dtype,m);o!==0&&y.fill(o);for(let S=0;S<h;S++){const _=Pu(S,d,p).map((k,N)=>k+l[N]),A=lo(_,g,b);y[A]=c[S]}return{dataId:t.write(y,a,r.dtype),shape:a,dtype:r.dtype}}const q3={kernelName:D0,backendName:"cpu",kernelFunc:bne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sne=Qn((n,e)=>Math.pow(n,e)),wne=ms(nf,Sne),_ne={kernelName:nf,backendName:"cpu",kernelFunc:wne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cne(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,l=r.map(v=>t.data.get(v.dataId).values),c=r.map(v=>v.shape),h=t.data.get(i.dataId).values,d=t.data.get(o.dataId).values,[p,m,g]=f3(l,c,h,i.shape,i.dtype,d,o.shape),b=p.map(v=>t.makeTensorInfo([v.length],"int32",v)),y=t.makeTensorInfo(g,i.dtype,m);return b.concat([y])}const Ene={kernelName:xR,backendName:"cpu",kernelFunc:Cne};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[c,h]=p3(o,s.shape,s.dtype,a,r.shape,l,i.shape),d=t.makeTensorInfo([c.length],"int32",c),p=t.makeTensorInfo([h.length],s.dtype,h);return[d,p]}const Ine={kernelName:vR,backendName:"cpu",kernelFunc:Tne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ane(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=t.data.get(o.dataId).values,p=a.map(y=>t.data.get(y.dataId).values),m=a.map(y=>y.shape),[g,b]=m3(c,r.shape,h,i.shape,i.dtype,d,o.shape,p,m,l);return t.makeTensorInfo(g,i.dtype,b)}const Mne={kernelName:yR,backendName:"cpu",kernelFunc:Ane};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rne(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:o}=t,a=g3(s,r,o,i);return e.makeTensorInfo([a.length],i,a)}const kne={kernelName:QS,backendName:"cpu",kernelFunc:Rne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nne=yn(sf,n=>1/n),Dne={kernelName:sf,backendName:"cpu",kernelFunc:Nne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ne(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;gt(r,"resizeBilinear");const l=Ct(r.shape),[c,h]=a,[d,p,m,g]=r.shape,b=t.data.get(r.dataId).values,y=new Float32Array(Ne([d,c,h,g])),v=[i&&c>1?p-1:p,i&&h>1?m-1:m],S=[i&&c>1?c-1:c,i&&h>1?h-1:h];let C=0;const _=v[0]/S[0],A=v[1]/S[1];for(let k=0;k<d;k++)for(let N=0;N<c;N++){let D;o?D=_*(N+.5)-.5:D=_*N;const M=Math.max(0,Math.floor(D)),T=D-M,I=Math.min(p-1,Math.ceil(D)),$=k*l[0]+M*l[1],O=k*l[0]+I*l[1];for(let B=0;B<h;B++){let V;o?V=A*(B+.5)-.5:V=A*B;const H=Math.max(0,Math.floor(V)),q=V-H,P=Math.min(m-1,Math.ceil(V)),K=$+H*l[2],Z=O+H*l[2],U=$+P*l[2],z=O+P*l[2];for(let ne=0;ne<g;ne++){const Y=b[K+ne],te=b[Z+ne],he=b[U+ne],se=b[z+ne],Q=Y+(he-Y)*q,de=te+(se-te)*q,ce=Q+(de-Q)*T;y[C++]=ce}}}return t.makeTensorInfo([d,c,h,g],"float32",y)}const Fne={kernelName:O0,backendName:"cpu",kernelFunc:$ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;gt([i,r],"resizeBilinearGrad");const a=Ct(r.shape),[l,c,h,d]=r.shape,[,p,m]=i.shape,g=new Float32Array(l*c*h*d),b=[o&&p>1?c-1:c,o&&m>1?h-1:h],y=[o&&p>1?p-1:p,o&&m>1?m-1:m],v=b[0]/y[0],S=b[1]/y[1],C=t.data.get(i.dataId).values;let _=0;for(let A=0;A<l;A++){const k=A*a[0];for(let N=0;N<p;N++){const D=N*v,M=Math.floor(D),T=Math.min(Math.ceil(D),c-1),I=k+M*a[1],$=k+T*a[1],O=D-M,B=1-O;for(let V=0;V<m;V++){const H=V*S,q=Math.floor(H),P=Math.min(Math.ceil(H),h-1),K=H-q,Z=1-K,U=I+q*a[2],z=I+P*a[2],ne=$+q*a[2],Y=$+P*a[2],te=B*Z,he=B*K,se=O*Z,Q=O*K;for(let de=0;de<d;de++){const ce=C[_++];g[U+de]+=ce*te,g[z+de]+=ce*he,g[ne+de]+=ce*se,g[Y+de]+=ce*Q}}}}return t.makeTensorInfo([l,h,c,d],"float32",g)}const Pne={kernelName:tw,backendName:"cpu",kernelFunc:Lne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function One(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;gt(r,"resizeNearestNeighbor");const l=Ct(r.shape),[c,h]=a,[d,p,m,g]=r.shape,b=t.data.get(r.dataId).values,y=new Float32Array(d*c*h*g),v=[i&&c>1?p-1:p,i&&h>1?m-1:m],S=[i&&c>1?c-1:c,i&&h>1?h-1:h],C=v[0]/S[0],_=v[1]/S[1];let A=0;for(let k=0;k<d;k++){const N=k*l[0];for(let D=0;D<c;D++){const M=o?C*(D+.5):C*D;let T=Math.min(p-1,i?Math.round(M):Math.floor(M));o&&(T=Math.max(0,T));const I=N+T*l[1];for(let $=0;$<h;$++){const O=o?_*($+.5):_*$;let B=Math.min(m-1,i?Math.round(O):Math.floor(O));o&&(B=Math.max(0,B));const V=I+B*l[2];for(let H=0;H<g;H++){const q=b[V+H];y[A++]=q}}}}return t.makeTensorInfo([d,c,h,g],r.dtype,y)}const Une={kernelName:P0,backendName:"cpu",kernelFunc:One};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zne(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;gt([i,r],"resizeNearestNeighborGrad");const a=Ct(r.shape),l=Ct(i.shape),[c,h,d,p]=r.shape,[,m,g]=i.shape,b=new Float32Array(c*h*d*p),y=t.data.get(i.dataId).values,v=[o&&m>1?h-1:h,o&&g>1?d-1:d],S=[o&&m>1?m-1:m,o&&g>1?g-1:g],C=v[0]/S[0],_=v[1]/S[1],A=1/C,k=1/_,N=Math.ceil(A)*2+2,D=Math.ceil(k)*2+2;for(let M=0;M<c;M++){const T=M*a[0];for(let I=0;I<h;I++){const $=T+I*a[1],O=Math.floor(I*A),B=Math.floor(O-N/2);for(let V=0;V<d;V++){const H=$+V*a[2],q=Math.floor(V*k),P=Math.floor(q-D/2);for(let K=0;K<p;K++){let Z=0;for(let U=0;U<N;U++){const z=U+B;if(z<0||z>=m)continue;const ne=T+z*l[1],Y=z*C,te=Math.min(h-1,o?Math.round(Y):Math.floor(Y));if(I===te)for(let he=0;he<D;he++){const se=he+P;if(se<0||se>=g)continue;const Q=ne+se*l[2],de=se*_,ce=Math.min(d-1,o?Math.round(de):Math.floor(de));V===ce&&(Z+=y[Q+K])}}b[H+K]=Z}}}}return t.makeTensorInfo(r.shape,r.dtype,b)}const Bne={kernelName:ew,backendName:"cpu",kernelFunc:zne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;gt(r,"reverse");const o=r.shape.length,a=qt(i,r.shape);if(o===0)return yo({inputs:{x:r},backend:t});const l=new ks(r.shape,r.dtype),c=t.bufferSync(r);for(let h=0;h<l.size;h++){const d=l.indexToLoc(h),p=d.slice();a.forEach(m=>p[m]=r.shape[m]-1-p[m]),l.set(c.get(...p),...d)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const Gne={kernelName:U0,backendName:"cpu",kernelFunc:Vne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wne={kernelName:lw,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,l=Us(s.dtype,Ne(s.shape)),[c,h,d,p]=s.shape,[m,g]=Kw(o,h,d),b=255,y=Math.sin(r),v=Math.cos(r),S=a.data.get(s.dataId).values;for(let _=0;_<c;_++){const A=_*d*h*p;for(let k=0;k<h;k++){const N=k*(d*p);for(let D=0;D<d;D++){const M=D*p;for(let T=0;T<p;T++){const I=[c,k,D,T],$=I[2],O=I[1];let B=($-m)*v-(O-g)*y,V=($-m)*y+(O-g)*v;B=Math.round(B+m),V=Math.round(V+g);let H=i;if(typeof i!="number"&&(T===3?H=b:H=i[T]),B>=0&&B<d&&V>=0&&V<h){const P=V*(d*p),K=B*p,Z=A+P+K+T;H=S[Z]}const q=A+N+M+T;l[q]=H}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hne=yn(af,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),Xne={kernelName:af,backendName:"cpu",kernelFunc:Hne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jne(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=uc(i,r,o),p=!0,m=t.bufferSync(r),g=t.bufferSync(i),b=Ol(m,g,o,d,c,l,a,h,0,p);return t.makeTensorInfo(o,b.dtype,b.values)}const qne={kernelName:bR,backendName:"cpu",kernelFunc:jne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kne(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function Yne(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function Zne(n,e,t,s,r,i){const o=jn("int32",t*r);for(let a=0;a<t;++a){const l=n.slice(a*s,(a+1)*s),c=a*r;for(let h=0;h<r;++h)o[c+h]=i==="left"?Kne(l,e[h+c]):Yne(l,e[h+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qne(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=Zne(a,l,r.shape[0],r.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",c)}const Jne={kernelName:wR,backendName:"cpu",kernelFunc:Qne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ese(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;gt([s,r,i],"select");const o=s.shape.length,a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,h=$r(r.dtype,i.dtype),d=zs(Ne(r.shape),h);let p=0;const m=o===0||o>1||r.shape.length===1?1:Ne(r.shape.slice(1));for(let g=0;g<a.length;g++)for(let b=0;b<m;b++)a[g]===1?d[p++]=l[g]:d[p++]=c[g];return t.makeTensorInfo(r.shape,h,d)}const tse={kernelName:z0,backendName:"cpu",kernelFunc:ese};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nse=rx,sse=ix,rse=yn(cf,n=>n>=0?sse*n:nse*(Math.exp(n)-1)),ise={kernelName:cf,backendName:"cpu",kernelFunc:rse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ose=yn(df,n=>n<0?-1:n>0?1:0),ase={kernelName:df,backendName:"cpu",kernelFunc:ose};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lse=yn(uf,n=>Math.sin(n)),cse={kernelName:uf,backendName:"cpu",kernelFunc:lse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use=yn(hf,n=>Math.sinh(n)),hse={kernelName:hf,backendName:"cpu",kernelFunc:use};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse=11920928955078125e-23,tA=Math.log(dse)+2,fse=yn(pf,n=>{const e=n>-tA,t=n<tA,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),pse={kernelName:pf,backendName:"cpu",kernelFunc:fse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;gt([r],"spaceToBatchND");const a=Ne(i),l=[[0,0]];l.push(...o);for(let k=1+i.length;k<r.shape.length;++k)l.push([0,0]);const c=q3.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=If(c.shape,i,a,!1),d=Af(h.length,i.length,!1),p=Mf(c.shape,i,a,!1),b=Mn({inputs:{x:c},backend:t,attrs:{shape:h}}),S=yr({inputs:{x:b},backend:t,attrs:{perm:d}}),A=Mn({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(S),A}const gse={kernelName:G0,backendName:"cpu",kernelFunc:mse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xse(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values[0],[d,p,m,g,b]=b3(a,s.shape,s.dtype,l,r.dtype,c,h);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([p[0]],r.dtype,m),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(y=>Number(y)))),t.makeTensorInfo([b.length],s.dtype,new Int32Array(b))]}const vse={kernelName:_R,backendName:"cpu",kernelFunc:xse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yse(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(r.dataId).values),a=t.data.get(s.dataId).values,l=Array.from(t.data.get(i.dataId).values),[c,h,d]=S3(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(h,s.dtype,c),t.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}const bse={kernelName:CR,backendName:"cpu",kernelFunc:yse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sse(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[c,h]=O_(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(h,s.dtype,c)}const wse={kernelName:ER,backendName:"cpu",kernelFunc:Sse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _se(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[c,h]=O_(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(h,s.dtype,c)}const Cse={kernelName:TR,backendName:"cpu",kernelFunc:_se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ese(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=uc(i,r,a),m=!1,g=t.bufferSync(r);let b;switch(i.dtype){case"bool":{const y=t.bufferSync(i),v=!!t.data.get(o.dataId).values[0];b=Ol(g,y,a,p,h,c,l,d,v,m);break}case"float32":{const y=t.bufferSync(i),v=t.data.get(o.dataId).values[0];b=Ol(g,y,a,p,h,c,l,d,v,m);break}case"int32":{const y=t.bufferSync(i),v=t.data.get(o.dataId).values[0];b=Ol(g,y,a,p,h,c,l,d,v,m);break}case"string":{const y=t.bufferSync(i),v=Ba(t.data.get(o.dataId).values[0]);b=Ol(g,y,a,p,h,c,l,d,v,m);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(a,b.dtype,b.values)}const Tse={kernelName:IR,backendName:"cpu",kernelFunc:Ese};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ise(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=qt(o,r.shape)[0],l=u_(r,i,a),c=new Array(r.shape.length).fill(0),h=r.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const m=sc({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[a]+=d,m})}const Ase={kernelName:W0,backendName:"cpu",kernelFunc:Ise};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mse={kernelName:nw,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;gt(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];i[a]=l*l}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rse=yn(Sf,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),kse={kernelName:Sf,backendName:"cpu",kernelFunc:Rse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s;gt(r,"stridedSlice");const{finalShapeSparse:m,finalShape:g,isIdentity:b,sliceDim0:y,isSimpleSlice:v,begin:S,end:C,strides:_}=Xw(r.shape,i,o,a,l,c,h,d,p);let A;if(b)A=Mn({inputs:{x:r},backend:t,attrs:{shape:g}});else if(y||v){W(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=Gw(S,C,_),N=sc({inputs:{x:r},backend:t,attrs:{begin:S,size:k}});A=Mn({inputs:{x:N},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(N)}else{const k=t.bufferSync(r),N=C3(m,k,_,S);A=t.makeTensorInfo(g,N.dtype,N.values)}return A}const Dse={kernelName:rw,backendName:"cpu",kernelFunc:Nse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $se(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:d}=e,p=t.data.get(h.dataId).values,m=t.data.get(d.dataId).values,[g,b]=E3(p,m,r,i,o,a,l,c);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(d.shape,"int32",b)]}const Fse={kernelName:AR,backendName:"cpu",kernelFunc:$se};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lse(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values[0],[c,h,d]=T3(a,l,r),p=h.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const Pse={kernelName:MR,backendName:"cpu",kernelFunc:Lse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ose(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,a=I3(o,r);return t.makeTensorInfo(i.shape,"int32",a)}const Use={kernelName:RR,backendName:"cpu",kernelFunc:Ose};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zse=yn(vf,n=>Math.tan(n)),Bse={kernelName:vf,backendName:"cpu",kernelFunc:zse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vse=yn(yf,n=>Math.tanh(n)),Gse={kernelName:yf,backendName:"cpu",kernelFunc:Vse};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wse(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:h}=uc(i,r,s.shape),d=!1,p=t.bufferSync(r),m=t.bufferSync(i),g=t.bufferSync(s),b=Ol(p,m,s.shape,h,l,a,o,c,g,d);return t.makeTensorInfo(s.shape,b.dtype,b.values)}const Hse={kernelName:SR,backendName:"cpu",kernelFunc:Wse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;gt(r,"tile");const o=M3(t.bufferSync(r),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const jse={kernelName:bf,backendName:"cpu",kernelFunc:Xse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s;gt(r,"topk");const a=t.data.get(r.dataId).values,[l,c]=k3(a,r.shape,r.dtype,i,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const Kse={kernelName:iw,backendName:"cpu",kernelFunc:qse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yse(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[h,d,p,m]=r.shape,[g,b]=c??[d,p],y=[h,g,b,m],v=Ct(r.shape),S=v[0],C=v[1],_=v[2],A=Ct(y),k=A[0],N=A[1],D=A[2],M=Us(r.dtype,Ne(y));M.fill(l);const T=s.data.get(r.dataId).values,I=s.data.get(i.dataId).values;for(let O=0;O<h;++O){const B=i.shape[0]===1?I:I.subarray(O*8,O*8+8);for(let V=0;V<g;++V)for(let H=0;H<b;++H)for(let q=0;q<m;++q){let P;const K=B[6]*H+B[7]*V+1;if(K===0)continue;const Z=(B[0]*H+B[1]*V+B[2])/K,U=(B[3]*H+B[4]*V+B[5])/K,z=nA(Z,p,a),ne=nA(U,d,a);switch(o){case"nearest":P=nre(T,d,p,S,C,_,O,ne,z,q,l);break;case"bilinear":P=sre(T,d,p,S,C,_,O,ne,z,q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const Y=O*k+V*N+H*D+q;M[Y]=P}return s.makeTensorInfo(y,r.dtype,M)}return{dataId:s.write(M,y,r.dtype),shape:r.shape,dtype:r.dtype}}const Zse={kernelName:ow,backendName:"cpu",kernelFunc:Yse};function nA(n,e,t){switch(t){case"reflect":return Qse(n,e);case"wrap":return Jse(n,e);case"nearest":return tre(n,e);case"constant":default:return ere(n)}}function Qse(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Hl(0,t,e-1)}function Jse(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Hl(0,t,e-1)}function ere(n,e){return n}function tre(n,e){return Hl(0,n,e-1)}function Zh(n,e,t,s,r,i,o,a,l,c,h){const d=o*s+a*r+l*i+c;return 0<=a&&a<e&&0<=l&&l<t?n[d]:h}function nre(n,e,t,s,r,i,o,a,l,c,h){const d=Math.round(a),p=Math.round(l);return Zh(n,e,t,s,r,i,o,d,p,c,h)}function sre(n,e,t,s,r,i,o,a,l,c,h){const d=Math.floor(a),p=Math.floor(l),m=d+1,g=p+1,b=(g-l)*Zh(n,e,t,s,r,i,o,d,p,c,h)+(l-p)*Zh(n,e,t,s,r,i,o,d,g,c,h),y=(g-l)*Zh(n,e,t,s,r,i,o,m,p,c,h)+(l-p)*Zh(n,e,t,s,r,i,o,m,g,c,h);return(m-a)*b+(a-d)*y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rre(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;gt(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=N3(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const ire={kernelName:aw,backendName:"cpu",kernelFunc:rre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ore(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==i&&(l[c++]=r.shape[m]);const h=new Array(o).fill(0),d=r.shape.slice();d[i]=1;const p=new Array(a);for(let m=0;m<p.length;m++){h[i]=m;const g=sc({inputs:{x:r},backend:t,attrs:{begin:h,size:d}});p[m]=Mn({inputs:{x:g},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(g)}return p}const are={kernelName:X0,backendName:"cpu",kernelFunc:ore};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s;gt(r,"unsortedSegmentSum");const a=r.shape.length,l=i.shape.length,c=[],h=[],d=a-l;let p=i;for(let g=0;g<d;++g){const b=kg({inputs:{input:p},backend:t,attrs:{dim:g+1}});p=b,h.push(b)}for(let g=0;g<o;++g){const b=Ka(g,"int32"),y=t.makeTensorInfo([],"int32",b),v=j$({inputs:{a:y,b:p},backend:t}),S=Xa({inputs:{x:v},backend:t,attrs:{dtype:"float32"}}),C=xx({inputs:{a:S,b:r},backend:t}),_=Of({inputs:{x:C},backend:t,attrs:{axis:0,keepDims:!1}});c.push(_),h.push(y),h.push(v),h.push(S),h.push(C),h.push(_)}const m=j3({inputs:c,backend:t,attrs:{axis:0}});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const cre={kernelName:j0,backendName:"cpu",kernelFunc:lre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ure=[rJ,OZ,oJ,lJ,WZ,uJ,dJ,pJ,gJ,vJ,bJ,wJ,CJ,IJ,MJ,NJ,$J,LJ,OJ,nJ,zJ,VJ,WJ,XZ,XJ,VZ,qZ,qJ,UZ,YJ,QJ,JJ,tee,see,iee,aee,cee,hee,fee,mee,xee,yee,See,_ee,Cee,Tee,Aee,Ree,kee,Nee,Dee,Fee,Oee,KQ,zee,KZ,qee,YZ,Kee,QZ,tte,nte,rte,eQ,nQ,ote,lte,ute,dte,rQ,oQ,zZ,pte,ZJ,gte,vte,bte,YQ,lQ,uQ,wte,dQ,Cte,Ite,Mte,Nte,$te,Lte,Pte,pQ,Ute,Bte,Gte,Hte,jte,Kte,Zte,gQ,Jte,nne,ine,vQ,bQ,lne,hne,pne,wQ,gne,vne,yne,q3,_ne,QQ,EQ,Ene,Ine,Mne,kne,BZ,kb,Dne,JQ,eJ,tJ,Fne,Pne,Une,Bne,Gne,Wne,Xne,DQ,qne,Jne,tse,ise,FQ,ase,cse,hse,LQ,sne,pse,gse,vse,bse,wse,Cse,Tse,Ase,UQ,Mse,BQ,GQ,kse,Dse,Fse,Pse,Use,jQ,Lee,Bse,Gse,Hse,jse,Kse,Zse,_Q,ire,are,cre,xne];for(const n of ure)NR(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $l={},Nm={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function hre(n,e){$l[n]=e}function Vi(n,e){if(!(n in $l)||e!=null){const s=fre(n,e);if(s!==null)$l[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=$l[n];return t==null||t.isContextLost()?(delete $l[n],Vi(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),$l[n])}function dre(n){if(!_e().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function fre(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??dre(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete $l[n]},!1),_e().getBool("SOFTWARE_WEBGL_ENABLED")&&(Nm.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Nm)||t.getContext("experimental-webgl",Nm):t.getContext("webgl2",Nm)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vd;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(vd||(vd={}));var Xr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Xr||(Xr={}));var Ms;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ms||(Ms={}));function Uf(n,e){return[e,n]}function pre(n,e){return n*e}function Dm(n){const e=Ne(n),t=Math.ceil(e/4);return J1(t)}function ju(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function mre(n,e){const[t,s]=ju(n,e);return t*s*4}function G_(n,e){const t=n;let s,r,i,o,a,l,c,h,d,p;return _e().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,h=1,d=t.HALF_FLOAT,p=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,h=4,d=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:d,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ot(n,e){const t=e();return _e().getBool("DEBUG")&&gre(n),t}function gre(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+bre(n,e))}const xre=596e-10,vre=65504;function yre(n){return!!(_e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||xre<Math.abs(n)&&Math.abs(n)<vre)}function bre(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function $m(n,e){return Qo(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Sre(n,e){const t=Qo(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ot(n,()=>n.shaderSource(t,e)),ot(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function wre(n,e){const t=Qo(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ot(n,()=>n.shaderSource(t,e)),ot(n,()=>n.compileShader(t)),_e().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw K3(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const _re=/ERROR: [0-9]+:([0-9]+):/g;function K3(n,e){const t=_re.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((d,p)=>hu((p+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,s-1),c=o.slice(s-1,s),h=o.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${hu(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function Cre(n){return Qo(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function Ere(n,e){if(ot(n,()=>n.linkProgram(e)),!_e().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function n1(n,e){if(ot(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Tre(n,e){const t=Qo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ot(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ot(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Ire(n,e){const t=Qo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ot(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),ot(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Are(n){return Qo(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Mre(n,e){const t=_e().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Rre(n){return Qo(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function sA(n,e,t,s,r,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(ot(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),ot(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,i,o)),ot(n,()=>n.enableVertexAttribArray(a)),!0)}function kre(n,e,t){Lre(n,t),ot(n,()=>n.activeTexture(n.TEXTURE0+t)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Nre(n,e,t){return Qo(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Dre(n,e,t){return n.getUniformLocation(e,t)}function $re(n,e,t,s){ot(n,()=>kre(n,e,s)),ot(n,()=>n.uniform1i(t,s))}function s1(n,e,t){ot(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ot(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function rA(n,e){ot(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ot(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Fm(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Fre(n,e))}function Fre(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Qo(n,e,t){const s=ot(n,()=>e());if(s==null)throw new Error(t);return s}function Lre(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Ru(n,e=2){return Ne(n.slice(0,n.length-e))}function ku(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Lm(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Ru(n),...ku(n)]),e}function Pre(n,e=!1){let t=_e().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=_e().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&_e().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?xS(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=qa(n).newShape);let r=Ne(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=Ru(n);let l=2,c=2;n.length&&([l,c]=ku(n)),r=a*(l/2)*(c/2),i=J1(r).map(h=>h*2)}else i=J1(r);return i}function Pm(n){return n%2===0}function Dg(n,e){if(n=n.slice(-2),e=e.slice(-2),mn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Pm(t)&&Pm(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Pm(n[0])&&Pm(e[0])}let r1,i1;function Ore(n){if(r1==null){const e=Vi(n);r1=e.getParameter(e.MAX_TEXTURE_SIZE)}return r1}function Ure(n){if(i1==null){const e=Vi(n);i1=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,i1)}function zre(n){if(n===0)return 0;let e;const t=Vi(n);return di(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:di(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function di(n,e){return n.getExtension(e)!=null}function iA(n){try{if(Vi(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Bre(n){if(n===0)return!1;const e=Vi(n);if(n===1){if(!di(e,"OES_texture_float"))return!1}else if(!di(e,"EXT_color_buffer_float"))return!1;return Db(e)}function Vre(n){if(n===0)return!1;const e=Vi(n);if(n===1){if(!di(e,"OES_texture_float")||!di(e,"WEBGL_color_buffer_float"))return!1}else{if(di(e,"EXT_color_buffer_float"))return Db(e);const s="EXT_color_buffer_half_float";if(di(e,s)){const r=e.getExtension(s);return Gre(e,r)}return!1}return Db(e)}function Db(n){const e=G_(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function Gre(n,e){const t=G_(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function Wre(n){return n!==2?!1:Vi(n).fenceSync!=null}function zf(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&W(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vt=_e();vt.registerFlag("HAS_WEBGL",()=>vt.getNumber("WEBGL_VERSION")>0);vt.registerFlag("WEBGL_VERSION",()=>iA(2)?2:iA(1)?1:0);vt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);vt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>vt.get("WEBGL_VERSION")===2);vt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);vt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);vt.registerFlag("WEBGL_PACK",()=>vt.getBool("HAS_WEBGL"));vt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_CLIP",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_REDUCE",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_LAZILY_UNPACK",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_CONV_IM2COL",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>vt.getBool("WEBGL_PACK"));vt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Ore(vt.getNumber("WEBGL_VERSION")));vt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Ure(vt.getNumber("WEBGL_VERSION")));vt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=vt.getNumber("WEBGL_VERSION");return n===0?0:zre(n)});vt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>vt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!HR());vt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Bre(vt.getNumber("WEBGL_VERSION")));vt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>vt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:vt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));vt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Vre(vt.getNumber("WEBGL_VERSION")));vt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Wre(vt.getNumber("WEBGL_VERSION")));vt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>vt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);vt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});vt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>HR()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});vt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);vt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);vt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);vt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);vt.registerFlag("WEBGL_EXP_CONV",()=>!1);vt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>vt.getBool("IS_TEST"));vt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);vt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);vt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);vt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(){let n,e,t,s,r,i,o,a,l,c;return _e().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=_e().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fc(n,e,t="index"){const s=Ct(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / ${r}`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${a};`}).join("")}function vx(n,e,t="index"){const s=Ct(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function Hre(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function Xre(n,e,t="index"){const s=n.map((i,o)=>o),r=Hre(s,e);return r.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${r[o]}`,l=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function W_(n){const e=Ct(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function H_(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Y3=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:Z3}=L9;function jre(n,e,t){const s=[];if(n.forEach(m=>{const g=Ne(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?s.push(`uniform float ${m.name}${g>1?`[${g}]`:""};`):(s.push(`uniform sampler2D ${m.name};`),s.push(`uniform int offset${m.name};`)),t.enableShapeUniforms){const{uniformShape:b}=X_(t.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(b.length){case 1:s.push(`uniform int ${m.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${m.name}Shape;`);break}s.push(`uniform ivec2 ${m.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(m=>{s.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(m=>qre(m,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=ar(),l=Zre(a);let c,h,d=eie(a);return e.isPacked?(c=Kre(e.logicalShape,o,t.enableShapeUniforms),h=Jre(a)):(c=Yre(e.logicalShape,o,t.enableShapeUniforms),h=Qre(a)),t.packedInputs&&(d+=rie),[d,l,h,r,c,i,t.userCode].join(`
`)}function qu(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return gie(n,e);case 1:return vie(n,e);case 2:return bie(n,e);case 3:return wie(n,e);case 4:return Cie(n,e);case 5:return Eie(n);case 6:return Tie(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Q3(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return mie(n);case 1:return xie(n,e);case 2:return yie(n,e);case 3:return Sie(n,e);default:return _ie(n,e)}}function qre(n,e,t=!1,s){let r="";t?r+=Q3(n,s):r+=qu(n,s);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?r+=Iie(n,e):r+=Aie(n,e)),r}function Kre(n,e,t){switch(n.length){case 0:return J3();case 1:return iie(n,e,t);case 2:return fie(n,e,t);case 3:return aie(n,e,t);default:return cie(n,e,t)}}function Yre(n,e,t){switch(n.length){case 0:return J3();case 1:return oie(n,e,t);case 2:return pie(n,e,t);case 3:return lie(n,e,t);case 4:return uie(n,e,t);case 5:return hie(n,e);case 6:return die(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Zre(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Qre(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Jre(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function eie(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${tie}
    ${nie}
    ${sie}
  `}const tie=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,nie=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,sie=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,rie=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function J3(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function iie(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function oie(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function aie(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function lie(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${vx(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=fc(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function cie(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function uie(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${vx(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=fc(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function hie(n,e){const t=fc(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function die(n,e){const t=fc(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function fie(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(mn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function pie(n,e,t){return mn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function pc(n){return`offset${n}`}function mie(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=ar();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function gie(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=pc(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function xie(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=ar();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function vie(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Ku(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=pc(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function yie(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=ar();if(i!=null&&mn(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],h=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function bie(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&mn(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=i[0],m=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=qa(t),l=o;if(l.length<t.length){const p=Yu(n,l),m=["row","col"];return`
      ${qu(p,e)}
      float ${r}(int row, int col) {
        return ${r}(${Zu(m,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Ku(n)}
      }
    `;const c=i[0],h=i[1],d=pc(s);return h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function Sie(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const p=t.slice(1),m=[1,2],g=Yu(n,p),b=["b","row","col"];return`
        ${Q3(g,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Zu(b,m)});
        }
      `}const a=ar();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],h=Math.ceil(t[2]/2),d=h*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${h}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function wie(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=qa(t),c=a;if(c.length<t.length){const b=Yu(n,c),y=["row","col","depth"];return`
        ${qu(b,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Zu(y,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Ku(n)}
      }
    `;const h=n.shapeInfo.texShape,d=h[0],p=h[1],m=n.shapeInfo.flatOffset;if(p===i&&m==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===o&&m==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const g=pc(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${g};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${g};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function _ie(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=ar();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],h=l[1],d=Math.ceil(i[o-1]/2);let p=d*Math.ceil(i[o-2]/2),m="int b, int row, int col",g=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let b=2;b<o-1;b++)m=`int b${b}, `+m,p*=i[o-b-1],g=`b${b} * ${p} + `+g;return`
    vec4 ${s}(${m}) {
      int index = ${g};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${r.texture2D}(${t}, uv);
    }
  `}function Cie(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=qa(t);if(l.length<t.length){const S=Yu(n,l),C=["row","col","depth","depth2"];return`
      ${qu(S,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Zu(C,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Ku(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],m=d[1],g=`int stride2 = ${s}Shape[3];`,b=`int stride1 = ${s}Shape[2] * stride2;`,y=`int stride0 = ${s}Shape[1] * stride1;`;if(m===a&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${g}
        ${b}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(m===i&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const v=pc(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${g}
      ${b}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${v});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${p}, ${m}, index + ${v});
      return sampleTexture(${s}, uv);
    }
  `}function Eie(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=qa(e);if(l.length<e.length){const b=Yu(n,l),y=["row","col","depth","depth2","depth3"];return`
      ${qu(b)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Zu(y,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${Ku(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],m=d[1];if(m===a&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===r&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=pc(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${g};
      vec2 uv = uvFromFlat(${p}, ${m}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Tie(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=qa(e);if(r.length<e.length){const y=Yu(n,r),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${qu(y)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Zu(v,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,h=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Ku(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],g=p[1];if(g===h&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===o&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const b=pc(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${b};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Ku(n){const e=n.name,t=Ne(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Iie(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=Z3(n.shapeInfo.logicalShape,e.logicalShape),l=bn(o),c=o-i;let h;const d=["x","y","z","w","u","v"];i===0?h="":o<2&&a.length>=1?h="coords = 0;":h=a.map(S=>`coords.${d[S+c]} = 0;`).join(`
`);let p="";o<2&&i>0?p="coords":p=n.shapeInfo.logicalShape.map((S,C)=>`coords.${d[C+c]}`).join(", ");let m="return outputValue;";const b=Ne(n.shapeInfo.logicalShape)===1,v=Ne(e.logicalShape)===1;if(i===1&&!b&&!v)m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(b&&!v)o===1?m=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:m=`
        return vec4(outputValue.x);
      `;else if(a.length){const S=i-2,C=i-1;a.indexOf(S)>-1&&a.indexOf(C)>-1?m="return vec4(outputValue.x);":a.indexOf(S)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(C)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${p});
      ${m}
    }
  `}function Aie(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&mn(o,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=bn(l),h=Z3(n.shapeInfo.logicalShape,e.logicalShape),d=l-a;let p;const m=["x","y","z","w","u","v"];a===0?p="":l<2&&h.length>=1?p="coords = 0;":p=h.map(b=>`coords.${m[b+d]} = 0;`).join(`
`);let g="";return l<2&&a>0?g="coords":g=n.shapeInfo.logicalShape.map((b,y)=>`coords.${m[y+d]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${s}(${g});
    }
  `}function bn(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function X_(n,e,t){const{newShape:s,keptDims:r}=qa(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):s,l=!n&&i>1&&!mn(e,t)&&s.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function Yu(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Zu(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mie(n,e,t,s){const r=t.map((h,d)=>{const p={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(p.flatOffset=h.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:p}}),i=r.map(h=>h.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=jre(r,o,e),l=wre(n.gl,a),c=n.createProgram(l);return _e().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},eF(n,e,c)))}function eF(n,e,t){const s=[],r=[];let i,o,a,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),_e().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const h=!1;for(const d of e.variableNames){const p={name:d,uniform:n.getUniformLocation(t,d,h),offset:n.getUniformLocation(t,`offset${d}`,h)};e.enableShapeUniforms&&(p.shape=n.getUniformLocation(t,`${d}Shape`,h),p.texShape=n.getUniformLocation(t,`${d}TexShape`,h)),s.push(p)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",h),a=n.getUniformLocation(t,"outShapeStrides",h),o=n.getUniformLocation(t,"outTexShape",h)),e.customUniforms)for(const d of e.customUniforms)r.push(n.getUniformLocation(t,d.name,h));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function oA(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],o=i.shape;if(!mn(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!mn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Rie(n,e,t,s,r){e.program.enableShapeUniforms||(oA(e.inShapeInfos,t),oA([e.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),_e().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:h,offset:d,shape:p,texShape:m}=e.variablesLocations[l];if(p){const{uniformShape:g}=X_(e.program.packedInputs,c.shape,c.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(p,new Int32Array(g));break;case 2:n.gl.uniform2iv(p,new Int32Array(g));break;case 3:n.gl.uniform3iv(p,new Int32Array(g));break;case 4:n.gl.uniform4iv(p,new Int32Array(g));break}}if(m&&n.gl.uniform2i(m,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if(Ne(c.shape)<2)n.gl.uniform1f(h,c.uniformValues[0]);else{let g=c.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(h,g)}continue}c.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,h,l)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=Ct(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],h=e.customUniformLocations[l],d=r[l];if(c.type==="float")n.gl.uniform1fv(h,d);else if(c.type==="vec2")n.gl.uniform2fv(h,d);else if(c.type==="vec3")n.gl.uniform3fv(h,d);else if(c.type==="vec4")n.gl.uniform4fv(h,d);else if(c.type==="int")n.gl.uniform1iv(h,d);else if(c.type==="ivec2")n.gl.uniform2iv(h,d);else if(c.type==="ivec3")n.gl.uniform3iv(h,d);else if(c.type==="ivec4")n.gl.uniform4iv(h,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function kie(n,e,t){let s="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:d}=X_(n.packedInputs,o.shape,l);let p="",m="",g="";if(h.length===1&&n.packedInputs){const A=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${A[0]>1}_${A[1]>1}`}else if(h.length===2&&!n.packedInputs)m=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!n.packedInputs){const A=Ct(h);g=`${A[0]===l[1]}_${A[A.length-1]===l[1]}`}const b=o.shape.length,y=h.length===2&&mn(o.shape,l),v=Ne(o.shape)===1,S=Cu(o.shape,t.shape),C=!n.packedInputs&&b===t.shape.length&&mn(l,t.texData.texShape),_=n.packedInputs||h.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${b}_${C}_${c?d:""}_${h.length}_${v}_${S}_${y}_${p}_${m}_${g}_${_}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${_e().getNumber("WEBGL_VERSION")}`,i}function Ws(n){return _e().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nie{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=vd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ar();this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?vx(["r","c","d"],e):fc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Die{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=vd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ar();this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?vx(["r","c","d"],e):fc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $ie{constructor(e){this.variableNames=["A"],this.outTexUsage=Xr.DOWNLOAD;const t=ar();this.outputShape=e,this.userCode=`
      ${Y3}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fie{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Xr.DOWNLOAD;const t=ar();this.outputShape=e,this.userCode=`
      ${Y3}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lie={R:0,G:1,B:2,A:3};class aA{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ar();this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${Lie[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?H_():W_(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pie{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ar();this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?H_():W_(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oie(n){const e=ar(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Sre(n,t)}function Uie(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Tre(n,e)}function zie(n){const e=new Uint16Array([0,1,2,2,1,3]);return Ire(n,e)}function Bf(n,e,t,s,r,i){Mre(e,t);const o=Are(n),a=n.TEXTURE_2D;return ot(n,()=>n.bindTexture(a,o)),ot(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ot(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ot(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ot(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),_e().getNumber("WEBGL_VERSION")===1?ot(n,()=>n.texImage2D(a,0,s,e,t,0,r,i,null)):ot(n,()=>n.texStorage2D(a,1,s,e,t)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function tF(n){return n.internalFormatFloat}function Bie(n,e,t,s){const[r,i]=Uf(e,t);return Bf(n,r,i,tF(s),s.textureFormatFloat,n.FLOAT)}function nF(n){return n.internalFormatHalfFloat}function Vie(n,e,t,s){const[r,i]=Uf(e,t);return Bf(n,r,i,nF(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function sF(n){return n.downloadTextureFormat}function Gie(n,e,t,s){const[r,i]=Uf(e,t);return Bf(n,r,i,sF(s),n.RGBA,n.UNSIGNED_BYTE)}function rF(n){return n.internalFormatPackedFloat}function Wie(n,e,t,s){const[r,i]=ju(e,t);return Bf(n,r,i,rF(s),n.RGBA,n.FLOAT)}function iF(n){return n.internalFormatPackedHalfFloat}function Hie(n,e,t,s){const[r,i]=ju(e,t);return Bf(n,r,i,iF(s),n.RGBA,s.textureTypeHalfFloat)}function Xie(n,e,t){return ot(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),sA(n,e,"clipSpacePos",t,3,20,0)&&sA(n,e,"uv",t,2,20,12)}function jie(n,e,t,s,r,i){ot(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*s*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(r),_e().getNumber("WEBGL_VERSION")===2?ot(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,o)):ot(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,o)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function qie(n,e,t){ot(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?_e().getNumber("WEBGL_VERSION")===2?ot(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):ot(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):_e().getNumber("WEBGL_VERSION")===2?ot(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):ot(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Kie(n,e,t,s){const r=n.createBuffer();ot(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return ot(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ot(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),ot(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function Yie(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function Zie(n,e,t,s){const[r,i]=Uf(e,t),o=4,a=new Uint8Array(pre(e*t,o));return ot(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function Qie(n,e,t,s,r,i,o,a){const l=n,c=new Float32Array(mre(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function Jie(n,e,t){const s=new Float32Array(e*t*4);return ot(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o1{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=_e().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,hre(t,e)):this.gl=Vi(t),e=this.gl,_e().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>ot(i,()=>i.createVertexArray()),this.bindVertexArray=o=>ot(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>ot(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>ot(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ot(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>ot(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ot(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>ot(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),_e().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=$m(this.gl,i),di(this.gl,o))this.textureHalfFloatExtension=$m(this.gl,o);else if(_e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),di(this.gl,r))this.colorBufferHalfFloatExtension=$m(this.gl,r);else if(_e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",di(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(di(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Uie(this.gl),this.indexBuffer=zie(this.gl),this.framebuffer=Rre(this.gl),this.textureConfig=G_(this.gl,this.textureHalfFloatExtension)}get debug(){return _e().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ot(e,()=>e.finish()),ot(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ot(e,()=>e.deleteFramebuffer(this.framebuffer)),ot(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ot(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ot(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Bie(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Vie(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Gie(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),qie(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),jie(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Hie(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Wie(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(rA(this.gl,this.framebuffer),this.outputTexture=null),ot(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Zie(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,o){return Qie(this.gl,e,t,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Yie(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=Kie(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(_e().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=i}else _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Jie(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=Oie(t));const s=Cre(t);ot(t,()=>t.attachShader(s,this.vertexShader)),ot(t,()=>t.attachShader(s,e)),Ere(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&n1(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;ot(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Xie(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(ot(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&n1(this.gl,this.program),ot(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Nre(this.gl,e,t):Dre(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ot(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),$re(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=ju(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&n1(this.gl,this.program),Fm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ot(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ot(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=$m(this.gl,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await VI(()=>this.disposed||this.isQueryAvailable(e,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=eoe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in _e().platform&&(s=_e().platform.setTimeoutCustom.bind(_e().platform)),VI(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),s1(this.gl,e,this.framebuffer),this.debug&&Fm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(s1(this.gl,this.outputTexture,this.framebuffer),this.debug&&Fm(this.gl)):rA(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;s1(r,e,this.framebuffer),this.debug&&Fm(r),this.outputTexture=e,ot(r,()=>r.viewport(0,0,t,s)),ot(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),ot(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function eoe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:toe,bincountImpl:oF,bincountReduceImpl:noe,bitwiseAndImpl:soe,castImpl:roe,ceilImpl:ioe,concatImpl:ooe,equalImpl:aoe,expImpl:loe,expm1Impl:coe,floorImpl:uoe,gatherNdImpl:hoe,gatherV2Impl:doe,greaterImpl:foe,greaterEqualImpl:poe,lessImpl:moe,lessEqualImpl:goe,linSpaceImpl:xoe,logImpl:voe,maxImpl:yoe,maximumImpl:boe,minimumImpl:Soe,multiplyImpl:woe,negImpl:_oe,notEqualImpl:Coe,prodImpl:Eoe,raggedGatherImpl:Toe,raggedRangeImpl:Ioe,raggedTensorToTensorImpl:Aoe,rangeImpl:Moe,rsqrtImpl:Roe,scatterImpl:koe,sigmoidImpl:Noe,simpleAbsImpl:aF,sliceImpl:Doe,sparseFillEmptyRowsImpl:$oe,sparseReshapeImpl:Foe,sparseSegmentReductionImpl:lF,sqrtImpl:Loe,staticRegexReplaceImpl:Poe,stridedSliceImpl:Ooe,stringNGramsImpl:Uoe,stringSplitImpl:zoe,stringToHashBucketFastImpl:Boe,subImpl:Voe,tileImpl:Goe,topKImpl:Woe,transposeImpl:j_,uniqueImpl:Hoe}=qQ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cF(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function nr(n,e){return e===1?[n]:cF(n,e)}function Xoe(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class joe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ws(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=nr("rc",this.rank),s=bn(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${qoe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?H_():W_(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function qoe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Xre(["r","c","d"],"inputShape"):fc(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Koe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=cA(t,s),i=uA(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=lA(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return r===Ms.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Ms.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Ms.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Ms.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Ms.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=cA(s,r),o=uA(t,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=lA(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=_e().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],h=c&&c.indexOf(e);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[h]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Yoe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function lA(n,e,t,s,r){const i=Zoe(e,s);let o;if(r){const[l,c]=ju(n[0],n[1]);o=l*c}else{const[l,c]=Uf(n[0],n[1]);o=l*c}const a=Yoe(t,i);return o*a}function Zoe(n,e){switch(n){case Ms.PACKED_2X2_FLOAT32:return rF(e);case Ms.PACKED_2X2_FLOAT16:return iF(e);case Ms.UNPACKED_FLOAT32:return tF(e);case Ms.UNPACKED_FLOAT16:return nF(e);case Ms.PACKED_4X1_UNSIGNED_BYTE:return sF(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function Qoe(n){return _e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ms.PACKED_2X2_FLOAT32:Ms.UNPACKED_FLOAT32:n?Ms.PACKED_2X2_FLOAT16:Ms.UNPACKED_FLOAT16}function cA(n,e){if(n===Xr.UPLOAD)return Ms.PACKED_2X2_FLOAT32;if(n===Xr.RENDER||n==null)return Qoe(e);if(n===Xr.DOWNLOAD||n===Xr.PIXELS)return Ms.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function uA(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ao{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const vi="if (isnan(x)) return x;",Joe="return x;",hA="return abs(x);",eae="return (x >= 0.0) ? x : (exp(x) - 1.0);",tae=vi+`
  return (x < 0.0) ? 0.0 : x;
`,nae=vi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ia="return x;",sae="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rae="return x;",iae=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,oae=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,aae=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lae="return 1.0 / (1.0 + exp(-1.0 * x));";class ka{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cae{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length);const t=e.length,s=nr("rc",t),r=bn(t),i=Xoe(t,s),o=s.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uae=$k,hae=1e-7,dae=1e-4,Om={};function fae(n){return n in Om||(Om[n]={}),Om[n]}const pae=_e().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),mae=600;function gae(){return _e().global.screen==null?1024:_e().global.screen.height*_e().global.screen.width*window.devicePixelRatio*mae/1024/1024}class yx extends gS{nextDataId(){return yx.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!_e().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof o1)t=e;else{const s=Vi(_e().getNumber("WEBGL_VERSION"),e);t=new o1(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Vi(_e().getNumber("WEBGL_VERSION"));t=new o1(s),this.binaryCache=fae(_e().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Koe(this.gpgpu),this.numMBBeforeWarning=gae(),this.texData=new rR(this,Zi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,o){const a=this.makeTensorInfo(t,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,i]},l.texShape=[r,i];const c=Lm(t),h=new aA(c,!1,o),d=this.runWebGLProgram(h,[a],s,[[r,i]]);return d.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),d.dataId}write(e,t,s){if((_e().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||_e().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:Xr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(_e().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:Xr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=t;if(o!=null){let p;l?p=new ka(a,Ia):p=new ao(a,Ia);const m=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:r}],r),g=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const c=this.activeTimers!=null;let h;c&&(h=dr());let d;if(r==="complex64"){const p=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId);d=jo(p,m)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=dr()-h),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const g=this.pendingRead.get(e);return new Promise(b=>g.push(b))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(i!=null){let g;l?g=new ka(r,Ia):g=new ao(r,Ia);const b=this.runWebGLProgram(g,[{dataId:e,shape:r,dtype:o}],o),y=this.read(b.dataId);return this.disposeIntermediateTensorInfo(b),y}if(s!=null)return this.convertAndCacheOnCPU(e);if(_e().getBool("DEBUG")&&!_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&_e().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(o!=="complex64"&&_e().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);const g=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(g.texture.texture,...Dm(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const g=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),b=g[0],y=g[1];d=jo(b,y)}else if(c==null)d=this.getValuesFromTexture(e);else{const g=Ne(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,g)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const g=this.gpgpu.gl;ot(g,()=>g.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,d),m=this.pendingRead.get(e);return this.pendingRead.delete(e),m.forEach(g=>g(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Zi().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:o,dtype:a,isPacked:l,texture:c}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let m;l?m=new ka(i,Ia):m=new ao(i,Ia);const g=this.runWebGLProgram(m,[{dataId:e,shape:i,dtype:a}],a),b=this.readToGPU(g,t);return this.disposeIntermediateTensorInfo(g),b}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,t.customTexShape),d=Zi().makeTensorFromTensorInfo(h),p=this.texData.get(h.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ba(r));return jt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return jt(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!yre(s))throw _e().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=Ne(t);if(_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),m=this.texData.get(p.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...Dm(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(p),g}const o=_e().getBool("WEBGL_PACK")&&r===!0,a=o?Lm(t):t,l=o?new Fie(a):new $ie(a),c=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),h=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Xl(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Xl(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=t5(l),a.getExtraProfileInfo=()=>l.map((c,h)=>({name:o[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:dr(),endMs:null}}endTimer(e){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=dr(),e)}async getQueryTime(e){if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,o)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=pae){return _e().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Ne(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Wr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return uae(e.shape,t)}packedUnaryOp(e,t,s){const r=new ka(e.shape,t),i=this.compileAndRun(r,[e],s);return Zi().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=aF(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(_e().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,hA,e.dtype);const t=new ao(e.shape,hA),s=this.compileAndRun(t,[e]);return Zi().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ed(s[0])){const i=s.map(o=>La(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Zi().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new cae(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new joe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[Ru(e.shape),...ku(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Ru(t),...ku(t)],o=new uF(i,s),a=!0,l=[s],c=this.runWebGLProgram(o,[r],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:o}=s;if(t!=null){const p=Ne(i),m=t[0]*t[1]*4;W(p<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Lm(i);let l;r?l=new Die(a):l=new Nie(a);const c=!0,h=[t??Dm(a)],d=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,h,c,t);return{dtype:o,shape:i,dataId:d.dataId}}runWebGLProgram(e,t,s,r,i=!1,o){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===vd.DENSE){const v=o??Dm(e.outputShape);l.texShape=v.map(S=>S*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Ne(a.shape)===0)return l.values=Us(a.dtype,0),a;const c=[],h=t.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let S=this.texData.get(v.dataId);if(S.texture==null){if(!e.packedInputs&&Ne(v.shape)<=_e().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:S.values};e.packedInputs&&(S.isPacked=!0,S.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!S.isPacked!=!!e.packedInputs)v=S.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),S=this.texData.get(v.dataId);else if(S.isPacked&&!Dg(S.shape,v.shape)){const C=v,_=v.shape;v.shape=S.shape,v=this.packedReshape(v,_),c.push(v),S=this.texData.get(v.dataId),C.shape=_}return{shape:v.shape,texData:S,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:l,isUniform:!1},p=kie(e,h,d),m=this.getAndSaveBinary(p,()=>Mie(this.gpgpu,e,h,d)),g=this.activeTimers!=null;let b;g&&(b=this.startTimer()),_e().get("ENGINE_COMPILE_ONLY")||Rie(this.gpgpu,m,h,d,r),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),g&&(b=this.endTimer(b),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(b)}));const y=_e().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const v=dr();v-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!_e().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const v=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),v}return a}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(_e().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=be(()=>{if(!_e().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=_e().getBool("DEBUG");_e().set("DEBUG",!1);const t=this.abs(en(1e-8)).dataSync()[0];if(_e().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?hae:dae}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let h;c&&(h=dr());let d=t.texShape;if(d==null&&(d=Pre(s,l),t.texShape=d),i!=null){const p=Lm(s);let m,g=d[1],b=d[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!y)&&([g,b]=ju(d[0],d[1])),l?m=new Pie(p,y):m=new aA(p,y);const v=y?[b,g]:d,S=this.makeTensorInfo(v,r),C=this.texData.get(S.dataId);y?C.usage=Xr.PIXELS:C.usage=Xr.UPLOAD,C.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(S.dataId),g,b,i);const _=[[b,g]],k=this.runWebGLProgram(m,[S],r,_,!0),N=this.texData.get(k.dataId);t.texShape=N.texShape,t.isPacked=N.isPacked,t.usage=N.usage,_e().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(t.texture=N.texture,t.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(S),c&&(this.uploadWaitMs+=dr()-h)}else{const p=this.acquireTexture(d,a,r,l);t.texture=p}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=xae(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*cg(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Zk(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(K3(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=eF(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:o,channels:a}=e,l=Zi().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(r,t,s,i,o,a);return Zi().makeTensorFromDataId(c,t,s,l)}}yx.nextDataId=0;function xae(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */XR()&&YR("webgl",()=>new yx,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class rc{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Ut(t,s),this.enableShapeUniforms=Ws(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mc=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Qu{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ut(t,s);const i=this.outputShape.length;this.enableShapeUniforms=Ws(i);let o="";if(r)if(i===0||Ne(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${bn(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=nr("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lr(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const vae={kernelName:Xd,backendName:"webgl",kernelFunc:Lr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sl(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(i.dataId),a=Lr({inputs:{x:s},backend:t}),l=Lr({inputs:{x:r},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const yae={kernelName:MS,backendName:"webgl",kernelFunc:sl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hF="return (a < 0.) ? b * a : a;",dF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function bae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,o=t.makeTensorInfo([],"float32",Ka(i,"float32")),a=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qu(dF,r.shape,o.shape):new rc(hF,r.shape,o.shape),l=t.runWebGLProgram(a,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const Sae={kernelName:m0,backendName:"webgl",kernelFunc:bae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fF="return (a < 0.) ? b * a : a;",pF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function wae(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qu(pF,s.shape,r.shape):new rc(fF,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const _ae={kernelName:$0,backendName:"webgl",kernelFunc:wae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ju="if (isnan(x)) return x;";function on({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const d=a.texData.get(o.dataId),p=t(d.values,l);return a.makeTensorInfo(o.shape,l,p)}const c=_e().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let h;return c?h=new ka(o.shape,e):h=new ao(o.shape,n),a.runWebGLProgram(h,[o],l)}}function $s({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,h=a;if(s&&l.dtype==="complex64"){const g=h.texData.get(l.dataId),b=h.texData.get(c.dataId),[y,v]=[[g.complexTensorInfos.real,b.complexTensorInfos.real],[g.complexTensorInfos.imag,b.complexTensorInfos.imag]].map(C=>{const[_,A]=C,k={dataId:_.dataId,dtype:_.dtype,shape:l.shape},N={dataId:A.dataId,dtype:A.dtype,shape:c.shape},D=new rc(n,l.shape,c.shape);return h.runWebGLProgram(D,[k,N],$r(_.dtype,A.dtype))}),S=sl({inputs:{real:y,imag:v},backend:h});return h.disposeIntermediateTensorInfo(y),h.disposeIntermediateTensorInfo(v),S}const d=i||$r(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&r!=null){const g=h.texData.get(l.dataId).values,b=h.texData.get(c.dataId).values,y=l.dtype==="string"?qo(g):g,v=l.dtype==="string"?qo(b):b,[S,C]=r(l.shape,c.shape,y,v,d),_=h.makeTensorInfo(C,d),A=h.texData.get(_.dataId);return A.values=S,_}const p=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let m;return p?m=new Qu(e,l.shape,c.shape,t):m=new rc(n,l.shape,c.shape),h.runWebGLProgram(m,[l,c],d)}}function yd(n,e=!1){if(n==="linear")return e?rae:Joe;if(n==="relu")return e?oae:tae;if(n==="elu")return e?iae:eae;if(n==="relu6")return e?aae:nae;if(n==="prelu")return e?pF:fF;if(n==="leakyrelu")return e?dF:hF;if(n==="sigmoid")return e?lae:sae;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mF{constructor(e,t,s,r=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Ws(this.outputShape.length);const h=r?e[1]:e[2],d=Math.ceil(h/2),p=r?"i * 2, rc.y":"rc.y, i * 2",m=i?"rc.z, i * 2":"i * 2, rc.z",g=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],b=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",v="";a&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,v="result = activation(result);");const S=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let C="rc.x",_="rc.x";e[0]<t[0]?C=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(_=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${C};
        int batchB = ${_};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${b[0]});
          result += (${g[1]} * ${b[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${S}

        ${v}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dA={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class fA{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ut(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pA="return a * b;";function K_(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=$r(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),c=new fA(dA.REAL,s.shape,r.shape),h=new fA(dA.IMAG,s.shape,r.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],p=t.runWebGLProgram(c,d,"float32"),m=t.runWebGLProgram(h,d,"float32"),g=sl({inputs:{real:p,imag:m},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}if(t.shouldExecuteOnCPU([s,r])){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[c,h]=woe(s.shape,r.shape,a.values,l.values,i),d=t.makeTensorInfo(h,i),p=t.texData.get(d.dataId);return p.values=c,d}let o;return _e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Qu(pA,s.shape,r.shape):o=new rc(pA,s.shape,r.shape),t.runWebGLProgram(o,[s,r],i)}const Cae={kernelName:tf,backendName:"webgl",kernelFunc:K_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eae(n,e,t){const s=[Ru(n.shape),...ku(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[Ru(e),...ku(e)],o=new uF(i,s),a=!0,l=[s],c=t.runWebGLProgram(o,[r],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Je(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=t,a=Ne(r.shape),l=iR(i,a),c=Ne(l);W(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(r.dataId);return h.isPacked&&!Dg(r.shape,l)&&!(h.texture!==null&&Dg(h.shape,l))?Eae(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const Tae={kernelName:L0,backendName:"webgl",kernelFunc:Je};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mA{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];const a=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const d=1/t;c=`sumValue += dot(values * ${Su(d)?d.toPrecision(2):d}, ones);`}let h="";i%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iae{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const h=Math.floor(s/4)*4,d=s%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";t==="all"?(a="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):t==="any"&&(a="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let g="";i%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aae(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=sx(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function gc(n,e,t,s){const r=Aae(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let h,d;t==="mean"?h=o===0?new mA({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new mA({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):h=new Iae({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),d=i,i=s.runWebGLProgram(h,[i],e),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mae{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const r=bn(this.rank),i=Rae(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Rae(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kae{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let h=0;h<s.length;h++)s[h]=e[t[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=bn(this.rank),i=cF("rc",this.rank),o=new Array(this.rank);for(let h=0;h<t.length;h++)o[t[h]]=i[h];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bx(n,e,t){const s=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kae(n.shape,e):new Mae(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nae(n,e,t,s){const r=e,i=n.shape.length,o=qt(r,n.shape);let a=o;const l=zn(a,i),c=l!=null;let h=n;c&&(h=bx(n,l,s),a=Yn(a.length,i)),Ds("sum",a,i);const[d,p]=ws(h.shape,a);let m=d;t&&(m=rs(d,o));const g=Ne(p),y=Ne(n.shape)/g,v=Je({inputs:{x:h},attrs:{shape:[y,g]},backend:s}),S=cw(n.dtype),C=gc(v,S,"sum",s),_=Je({inputs:{x:C},attrs:{shape:m},backend:s});return s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(C),c&&s.disposeIntermediateTensorInfo(h),_}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return Nae(r,i,o,t)}const Dae={kernelName:V0,backendName:"webgl",kernelFunc:Sx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function or(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,o=t,a=r.shape.length,l=new Array(a);for(let h=0;h<l.length;h++)l[h]=r.shape[i[h]];let c;if(o.shouldExecuteOnCPU([r])){const d=o.texData.get(r.dataId).values,p=j_(d,r.shape,r.dtype,i,l);c=o.makeTensorInfo(l,r.dtype);const m=o.texData.get(c.dataId);m.values=p}else c=bx(r,i,o);return c}const $ae={kernelName:du,backendName:"webgl",kernelFunc:or};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gF=1e3;function $g({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,h=e.shape.length,d=t?n.shape[c-2]:n.shape[c-1],p=s?e.shape[h-1]:e.shape[h-2],m=t?n.shape[c-1]:n.shape[c-2],g=s?e.shape[h-2]:e.shape[h-1],b=n.shape.slice(0,-2),y=e.shape.slice(0,-2),v=Ne(b),S=Ne(y),_=Ut(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([m,g]);W(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const A=t?[v,d,m]:[v,m,d],k=s?[S,g,p]:[S,p,g],N=Je({inputs:{x:n},backend:r,attrs:{shape:A}}),D=Je({inputs:{x:e},backend:r,attrs:{shape:k}}),M=[N,D],T=Math.max(v,S),I=t?N.shape[1]:N.shape[2],$=i!=null,O=o!=null,B=l==="leakyrelu",V=l!=null?yd(l,!0):null,H=$||O||B||V!=null;let q;if((m===1||g===1)&&I>gF&&H===!1){let K=N,Z=D;t&&(K=or({inputs:{x:N},backend:r,attrs:{perm:[0,2,1]}}),M.push(K)),s&&(Z=or({inputs:{x:D},backend:r,attrs:{perm:[0,2,1]}}),M.push(Z));const U=g!==1,z=g===1;let ne=K;U&&(ne=Je({inputs:{x:K},backend:r,attrs:{shape:[T,I,1]}}),M.push(ne));const Y=g===1?2:1;let te=Z;z&&(te=Je({inputs:{x:Z},backend:r,attrs:{shape:[T,1,I]}}),M.push(te));const he=K_({inputs:{a:ne,b:te},backend:r});q=Sx({inputs:{x:he},backend:r,attrs:{axis:Y,keepDims:!0}}),M.push(he)}else{const K=$r(n.dtype,e.dtype),Z=new mF(A,k,[T,m,g],t,s,$,V,O,B),U=[N,D];if(i!=null&&U.push(i),O&&U.push(o),B){const z=r.makeTensorInfo([],"float32",Ka(a,"float32"));U.push(z),M.push(z)}q=r.runWebGLProgram(Z,U,K)}const P=Je({inputs:{x:q},backend:r,attrs:{shape:_}});M.push(q);for(const K of M)r.disposeIntermediateTensorInfo(K);return P}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fae(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s;return $g({a:r,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:h})}const Lae={kernelName:ug,backendName:"webgl",kernelFunc:Fae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gA="return abs(x);";function Pae(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),o=aF(i.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let r;return _e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ka(s.shape,gA):r=new ao(s.shape,gA),t.runWebGLProgram(r,[s],s.dtype)}const Oae={kernelName:Kg,backendName:"webgl",kernelFunc:Pae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uae=vi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,zae=on({opSnippet:Uae}),Bae={kernelName:Td,backendName:"webgl",kernelFunc:zae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vae=vi+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Gae=on({opSnippet:Vae}),Wae={kernelName:Id,backendName:"webgl",kernelFunc:Gae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xA="return a + b;",Hae=$s({opSnippet:xA,packedOpSnippet:xA,supportsComplex:!0,cpuKernelImpl:toe}),Xae={kernelName:Ou,backendName:"webgl",kernelFunc:Hae};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jae{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qae{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ng(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Lr({inputs:{x:s[0]},backend:t});if(s.length>_e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=ng({inputs:s.slice(0,l),backend:t}),h=ng({inputs:s.slice(l),backend:t});return ng({inputs:[c,h],backend:t})}const r=s.map(l=>l.dtype).reduce((l,c)=>$r(l,c)),i=s.map(l=>l.shape),a=_e().getBool("WEBGL_PACK")?new qae(s[0].shape,i):new jae(s[0].shape,i);return t.runWebGLProgram(a,s,r)}const Kae={kernelName:wS,backendName:"webgl",kernelFunc:ng};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=qt(i,r.shape);let c=l;const h=zn(c,a);let d=r;h!=null&&(d=or({inputs:{x:r},backend:t,attrs:{perm:h}}),c=Yn(c.length,a)),Ds("all",c,a);const[p,m]=ws(d.shape,c),g=Ne(m),b=Je({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),y=gc(b,b.dtype,"all",t);let v;if(o){const S=rs(p,l);v=Je({inputs:{x:y},backend:t,attrs:{shape:S}})}else v=Je({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(y),h!=null&&t.disposeIntermediateTensorInfo(d),v}const Zae={kernelName:_S,backendName:"webgl",kernelFunc:Yae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=qt(i,r.shape);let c=l;const h=zn(c,a);let d=r;h!=null&&(d=or({inputs:{x:r},backend:t,attrs:{perm:h}}),c=Yn(c.length,a)),Ds("any",c,a);const[p,m]=ws(d.shape,c),g=Ne(m),b=Je({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),y=gc(b,b.dtype,"any",t);let v;if(o){const S=rs(p,l);v=Je({inputs:{x:y},backend:t,attrs:{shape:S}})}else v=Je({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(y),h!=null&&t.disposeIntermediateTensorInfo(d),v}const Jae={kernelName:CS,backendName:"webgl",kernelFunc:Qae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ele{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tle{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,W(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=bn(l),h=nr("coords",l);let d,p;if(o===1){p=l+1;const D=bn(p);d=`
        ${D} sourceLocR = ${D}(${h.join()}, 0);
        ++${h[l-1]};
        ${D} sourceLocG = ${D}(${h.join()}, 0);
        ++${h[l-2]};
        ${D} sourceLocA = ${D}(${h.join()}, 0);
        --${h[l-1]};
        ${D} sourceLocB = ${D}(${h.join()}, 0);
        --${h[l-2]};`}else p=l,d=`
        ${c} sourceLocR = coords;
        ++${h[l-1]};
        ${c} sourceLocG = coords;
        ++${h[l-2]};
        ${c} sourceLocA = coords;
        --${h[l-1]};
        ${c} sourceLocB = coords;
        --${h[l-2]};`;const m=["x","y","z","w","u","v"].slice(0,p),g="."+m[p-1],b=m.map(D=>"int "+D),y=nr("sourceLocR",p-1).concat("inIdx.r"),v=nr("sourceLocG",p-1).concat("inIdx.g"),S=nr("sourceLocB",p-1).concat("inIdx.b"),C=nr("sourceLocA",p-1).concat("inIdx.a"),_=s==="max"?"greaterThan":"lessThan",A=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${C.join()})));`,k=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${S.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,N=r?"":`
      float getBestIndicesAChannel(${b.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${b.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${N}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${a[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${A}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=sx(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new ele(a,t,s==null),c=[e];s!=null&&c.push(s);const h=n.runWebGLProgram(l,c,"int32");if(h.shape[1]===1)return h;const d=xF(n,e,t,h);return n.disposeIntermediateTensorInfo(h),d}function vF(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],o=sx(i),a=new tle(r,o,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const h=vF(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}return c}function yF(n,e,t,s){const r=[t];if(Ds("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!_e().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),i.push(l));const[c,h]=ws(l.shape,r),d=Ne(h),p=Je({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});i.push(p);const m=xF(n,p,s);i.push(m);const g=Je({inputs:{x:m},backend:n,attrs:{shape:c}});return i.forEach(b=>n.disposeIntermediateTensorInfo(b)),g}return vF(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=qt(i,r.shape);const a=zn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=or({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=Yn(o.length,l.shape.length)),Ds("argMax",[o[0]],l.shape.length);const h=yF(t,l,o[0],"max");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const sle={kernelName:Yg,backendName:"webgl",kernelFunc:nle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=qt(i,r.shape);const a=zn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=or({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=Yn(o.length,l.shape.length)),Ds("argMin",[o[0]],l.shape.length);const h=yF(t,l,o[0],"min");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const ile={kernelName:Zg,backendName:"webgl",kernelFunc:rle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ole=vi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ale=on({opSnippet:ole}),lle={kernelName:Ad,backendName:"webgl",kernelFunc:ale};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cle=vi+"return log(x + sqrt(x * x + 1.0));",ule=on({opSnippet:cle}),hle={kernelName:Md,backendName:"webgl",kernelFunc:ule};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dle=vi+`
  return atan(x);
`,fle=on({opSnippet:dle}),ple={kernelName:Rd,backendName:"webgl",kernelFunc:fle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mle=q_+`
  return atan(a, b);
`,gle=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+mc+`
  return result;
`,xle=$s({opSnippet:mle,packedOpSnippet:gle}),vle={kernelName:Nd,backendName:"webgl",kernelFunc:xle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yle=vi+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,ble=on({opSnippet:yle}),Sle={kernelName:kd,backendName:"webgl",kernelFunc:ble};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bd{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const b=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let S="0.0";if(b||(S="-1.0 / 1e-20"),s){const D=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${m}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?y:v:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");const A=Math.floor(o/4)*4,k=o%4,N=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${m}, ${g});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${A}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${N}
          }

          int xC = xCCorner + ${A};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${N}
          }
        }
        setOutput(${_});
      }
    `}}class Y_{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,h=e.dilationDepth,d=e.dilationHeight,p=e.dilationWidth,m=e.effectiveFilterDepth,g=e.effectiveFilterHeight,b=e.effectiveFilterWidth,y=e.padInfo.front,v=e.padInfo.top,S=e.padInfo.left;this.outputShape=e.outShape;const C=t==="avg";let _="0.0";if(C||(_="-1.0 / 1e-20"),s){const T=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${y}, ${v}, ${S});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${b};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${T} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${b} +
                      wR * ${b} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const A="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");const N=Math.floor(o/4)*4,D=o%4,M=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${A}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${y}, ${v}, ${S});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${N}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${N};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${k});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;zf(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(Vs(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=gi(r.shape,i,o,c,a,l);if(h.filterWidth===1&&h.filterHeight===1&&mn(h.inShape,h.outShape))return Lr({inputs:{x:r},backend:t});const d=new bd(h,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const _le={kernelName:Qg,backendName:"webgl",kernelFunc:wle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s,h=[1,1,1],d=Yo(r.shape,i,o,h,a,l,c),p=new Y_(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const Ele={kernelName:Jg,backendName:"webgl",kernelFunc:Cle};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tle{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.top,d=c-1-e.padInfo.left,p=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${d});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Ile{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=d-1-e.padInfo.front,b=p-1-e.padInfo.top,y=m-1-e.padInfo.left,v=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${b}, ${y});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ale(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=Yo(o.shape,a,l,d,c,h),m=new Ile(p);return t.runWebGLProgram(m,[r],o.dtype)}const Mle={kernelName:TS,backendName:"webgl",kernelFunc:Ale};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rle(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;zf([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,h=gi(o.shape,a,l,1,c),d=new Tle(h);return t.runWebGLProgram(d,[r],o.dtype)}const kle={kernelName:ES,backendName:"webgl",kernelFunc:Rle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nle(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return $g({a:r,b:i,transposeA:o,transposeB:a,backend:t})}const Dle={kernelName:e0,backendName:"webgl",kernelFunc:Nle};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $le{constructor(e,t,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ut(e,t),Ut(e,s);let a="0.0";r!=null&&(Ut(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(Ut(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fle{constructor(e,t,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ut(e,t),Ut(e,s);let a="vec4(0.0)";r!=null&&(Ut(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(Ut(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lle=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=n;W(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,r,i];let h=null;o!=null&&(h=o.shape,c.push(o));let d=null;a!=null&&(d=a.shape,c.push(a));const p=_e().getBool("WEBGL_PACK_NORMALIZATION")?new Fle(s.shape,r.shape,i.shape,h,d,l):new $le(s.shape,r.shape,i.shape,h,d,l);return e.runWebGLProgram(p,c,c[0].dtype)},Ple={kernelName:d0,backendName:"webgl",kernelFunc:Lle};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ole{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=bn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Ule(this.rank);let r;const i=e.map((o,a)=>`sourceLoc.${$b[a]} = start[${a}] + coords.${$b[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const $b=["x","y","z","w","u","v"];function Ule(n){if(n===1)return"sourceLoc";if(n<=6)return $b.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zle{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=bn(this.rank),s=nr("coords",this.rank),r=nr("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((h,d)=>`start[${d}]`).join()});`:e.map((h,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ble(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=Hw(e,Ct(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}function eh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s,[a,l]=nx(r,i,o);if(Vw(r,a,l),Ne(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=t.texData.get(r.dataId),p=Doe(d.values,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,p)}const{isPacked:c}=t.texData.get(r.dataId),h=Ww(r.shape,a,l);if(c||!h){const d=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zle(l):new Ole(l),p=[a];return t.runWebGLProgram(d,[r],r.dtype,p)}return t.uploadToGPU(r.dataId),Ble(r,a,l,t)}const Vle={kernelName:B0,backendName:"webgl",kernelFunc:eh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gle=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;W(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((S,C)=>S*C),l=If(r.shape,i,a),c=Af(l.length,i.length),h=Mf(r.shape,i,a),d=Yw(o,i.length),p=Zw(h,o,i.length),m=[],g=Je({inputs:{x:r},backend:t,attrs:{shape:l}}),b=or({inputs:{x:g},backend:t,attrs:{perm:c}}),y=Je({inputs:{x:b},backend:t,attrs:{shape:h}}),v=eh({inputs:{x:y},backend:t,attrs:{begin:d,size:p}});return m.push(g),m.push(b),m.push(y),m.forEach(S=>t.disposeIntermediateTensorInfo(S)),v},Wle={kernelName:t0,backendName:"webgl",kernelFunc:Gle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=t.readSync(r.dataId),l=t.readSync(i.dataId),c=oF(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const Xle={kernelName:IS,backendName:"webgl",kernelFunc:Hle};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jle=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,qle=`
  return float(int(a.r) & int(b.r));
`;function Kle(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=_e().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||o===1){const l=t.texData.get(s.dataId).values,c=t.texData.get(r.dataId).values,[h,d]=soe(s.shape,r.shape,l,c,s.dtype),p=t.makeTensorInfo(d,s.dtype),m=t.texData.get(p.dataId);return m.values=h,p}let a;return i?a=new Qu(jle,s.shape,r.shape,!1):a=new rc(qle,s.shape,r.shape),t.runWebGLProgram(a,[s,r],s.dtype)}const Yle={kernelName:AS,backendName:"webgl",kernelFunc:Kle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zle(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),o=t.readSync(r.dataId),a=Ut(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Qle={kernelName:hR,backendName:"webgl",kernelFunc:Zle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jle="return float(a != b);",bF=$s({opSnippet:Jle,cpuKernelImpl:Coe,dtype:"bool"}),ece={kernelName:M0,backendName:"webgl",kernelFunc:bF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Lr({inputs:{x:r.complexTensorInfos.real},backend:t})}const tce={kernelName:JS,backendName:"webgl",kernelFunc:Vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nce="return float(int(x));";function sce(n,e){const t=new ao(n.shape,nce),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fb(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Lr({inputs:{x:r},backend:t});const o=ls(r.shape),a=Fb({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=sl({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=Vf({inputs:{input:r},backend:t}),a=Fb({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!oR(r.dtype,i)){const o=Lr({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId).values,[a,l,c]=roe(o,r.shape,r.dtype,i);return t.makeTensorInfo(a,l,c)}if(i==="int32")return sce(r,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",Us("bool",1)),l=bF({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const rce={kernelName:Dd,backendName:"webgl",kernelFunc:Fb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vA="return ceil(x);",ice=on({opSnippet:vA,packedOpSnippet:vA,cpuKernelImpl:ioe}),oce={kernelName:$d,backendName:"webgl",kernelFunc:ice};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ace{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;_e().getBool("WEBGL_PACK_CLIP")?a=new lce(r.shape):a=new ace(r.shape);const l=[[i],[o]];return t.runWebGLProgram(a,[r],r.dtype,l)}const uce={kernelName:Fd,backendName:"webgl",kernelFunc:cce};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hce{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function dce(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new hce(s.shape),o=[yA(s,r.complexTensorInfos.real),yA(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const fce={kernelName:n0,backendName:"webgl",kernelFunc:dce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pce{constructor(e){this.outputShape=[],this.outputShape=uo(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mce{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=uo(e,t);const s=this.outputShape,r=s.length,i=bn(r),o=nr("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((b,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let b=1;b<l.length;b++)l[b]=l[b-1]+e[b][t];const c=a[t],h=a.slice(-2),d=a.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${h.join()}));
        }`;for(let b=1;b<l.length;b++){const y=l[b-1];p+=`
        if (${c} < ${l[b]}  && ${c} >= ${l[b-1]}) {
          return getChannel(
            getT${b}(${Um(a,c,y)}),
            vec2(${Um(h,c,y)}));
        }`}const m=l.length,g=l[l.length-1];p+=`
        return getChannel(
          getT${m}(${Um(a,c,g)}),
          vec2(${Um(h,c,g)}));`,this.userCode=`
      float getValue(${a.map(b=>"int "+b)}) {
        ${p}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Um(n,e,t){const s=n.indexOf(e);return n.map((i,o)=>o===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Lr({inputs:{x:r.complexTensorInfos.imag},backend:t})}const gce={kernelName:HS,backendName:"webgl",kernelFunc:wx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qh(n,e,t){const s=n[0].dtype;if(s==="complex64"){const m=n.map(S=>Vf({inputs:{input:S},backend:t})),g=n.map(S=>wx({inputs:{input:S},backend:t})),b=Qh(m,e,t),y=Qh(g,e,t),v=sl({inputs:{real:b,imag:y},backend:t});return m.forEach(S=>t.disposeIntermediateTensorInfo(S)),g.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(y),v}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const m=n.map(_=>{const k=[-1,Ne(_.shape.slice(e))];return Je({inputs:{x:_},backend:t,attrs:{shape:k}})}),g=m.map(_=>({vals:t.readSync(_.dataId),shape:_.shape})),b=uo(m.map(_=>_.shape),1),y=m[0].shape[0]===1,v=ooe(g,b,s,y),S=uo(n.map(_=>_.shape),e),C=t.makeTensorInfo(S,s,v);return m.forEach(_=>t.disposeIntermediateTensorInfo(_)),C}const i=n.filter(m=>Ne(m.shape)>0),o=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const m=o?new ao(n[0].shape,Ia):new ka(n[0].shape,Ia);return t.runWebGLProgram(m,n,s)}const a=_e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const m=[];for(let b=0;b<i.length;b+=a){const y=i.slice(b,b+a);m.push(Qh(y,e,t))}const g=Qh(m,e,t);for(const b of m)t.disposeIntermediateTensorInfo(b);return g}if(o){const m=new mce(i.map(g=>g.shape),e);return t.runWebGLProgram(m,i,s)}const{tensors2D:l,outShape:c}=xce(i,e,t),h=new pce(l.map(m=>m.shape)),d=t.runWebGLProgram(h,l,s);l.forEach(m=>t.disposeIntermediateTensorInfo(m));const p=Je({inputs:{x:d},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(d),p}function xce(n,e,t){const s=uo(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Je({inputs:{x:i},attrs:{shape:[-1,Ne(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=qt(r,e[0].shape)[0],o=e.map(c=>c.shape);jw(o,i);const a=uo(e.map(c=>c.shape),i);if(Ne(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Ne(c.shape)>0);return l.length===1?Lr({inputs:{x:l[0]},backend:t}):Qh(l,i,t)}const vce={kernelName:s0,backendName:"webgl",kernelFunc:SF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wF{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,b=e.inChannels%4,y=e.dataFormat==="channelsLast",v=y?1:2,S=y?2:3,C=y?3:1;let _="",A="";s&&(r?_=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?_=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:_=`
          float activation(float x) {
            ${s}
          }
        `,A="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${_}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${S}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${b===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${b===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${b===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${A}
        setOutput(result);
      }
    `}}class yce{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterDepth,p=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,b=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${b===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${b===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${b===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _F{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ws(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)p+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<h;y++)p+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(d+1)/2;y++){const v=y*2;if(p+=`
           xC = xCCorner + ${v*l};
           `,a===1){if(v<h&&(o%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,l===1&&v>0?p+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<h)){const S=o%2===0?xS(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${S};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:p+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):S===1?p+=`
                     xC${v+1} = xTexelC${v};
                     `:p+=`
                     xCOffset = xC + ${S};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<h&&(o%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<h&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<h&&(p+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<h&&(p+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<h&&(p+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let m="",g="";s&&(r?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:m=`vec4 activation(vec4 x) {
           ${s}
         }`,g="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${b}
         ${g}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bce{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ws(this.outputShape.length);const{dataFormat:s}=t,r=ar(),i=s==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let h=0;h<=1;h++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${h};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fg(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function CF({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=s.texData.get(n.dataId),h=t.inChannels,d=l[0]*l[1]*l[2],p=t.outChannels,m=t.dataFormat==="channelsLast",g=!1,b=!1;let y;const v=[];if(i!=null){const _=Fg(i.shape,m);_!=null&&(i=Je({inputs:{x:i},backend:s,attrs:{shape:_}}),v.push(i))}if(r!=null){const _=Fg(r.shape,m);_!=null&&(r=Je({inputs:{x:r},backend:s,attrs:{shape:_}}),v.push(r))}if(!((d===1||p===1)&&h>gF)&&c.isPacked&&m&&c.texture!=null&&l[2]%2!==0&&mn(c.shape.slice(-3),l.slice(-3))){const _=l[0]*l[1]*(l[2]+1),A={dataId:n.dataId,shape:[1,_,t.inChannels],dtype:n.dtype},k=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,W(Dg(c.shape,A.shape),()=>`packed reshape ${c.shape} to ${A.shape} isn't free`);const N=Je({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});v.push(N);const D=$g({a:A,b:N,backend:s,transposeA:g,transposeB:b,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),M=s.texData.get(D.dataId);W(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=k,M.shape=t.outShape,y=Lr({inputs:{x:D},backend:s}),y.shape=t.outShape,v.push(D)}else{const _=t.outHeight*t.outWidth,A=Je({inputs:{x:n},backend:s,attrs:{shape:m?[t.batchSize,_,t.inChannels]:[t.batchSize,t.inChannels,_]}}),k=Je({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),N=$g({a:m?A:k,b:m?k:A,transposeA:!m,transposeB:b,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});y=Je({inputs:{x:N},backend:s,attrs:{shape:t.outShape}}),v.push(A),v.push(k),v.push(N)}for(const _ of v)s.disposeIntermediateTensorInfo(_);return y}function EF({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:m}=t,g=m==="channelsLast",b=l*c*h,y=p*d,v=[t.batchSize,b,y],S=!0,C=!1,_=[];if(i!=null){const P=Fg(i.shape,g);P!=null&&(i=Je({inputs:{x:i},backend:s,attrs:{shape:P}}),_.push(i))}if(r!=null){const P=Fg(r.shape,g);P!=null&&(r=Je({inputs:{x:r},backend:s,attrs:{shape:P}}),_.push(r))}const A=Je({inputs:{x:e},backend:s,attrs:{shape:[1,b,Ne(e.shape)/b]}});_.push(A);const k=new bce(v,t),N=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],D=s.runWebGLProgram(k,[n],"float32",N),M=Je({inputs:{x:D},backend:s,attrs:{shape:v}});_.push(D),_.push(M);const T=r!=null,I=i!=null,$=a==="leakyrelu",O=a?yd(a,!0):null,B=new mF(g?M.shape:A.shape,g?A.shape:M.shape,g?[t.batchSize,y,t.outChannels]:[t.batchSize,t.outChannels,y],S,C,T,O,I,$),V=g?[M,A]:[A,M];if(r&&V.push(r),I&&V.push(i),$){const P=s.makeTensorInfo([],"float32",Ka(o,"float32"));V.push(P),_.push(P)}const H=s.runWebGLProgram(B,V,"float32"),q=Je({inputs:{x:H},backend:s,attrs:{shape:t.outShape}});_.push(H);for(const P of _)s.disposeIntermediateTensorInfo(P);return q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:h}=s,d=Zo(l),p=Ns(r.shape,i.shape,o,c,a,h,!1,d);let m;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))m=CF({x:r,filter:i,convInfo:p,backend:t});else if(p.strideWidth<=2&&d==="channelsLast"&&_e().getBool("WEBGL_EXP_CONV")){const b=new _F(p),y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];m=t.runWebGLProgram(b,[r,i],"float32",y)}else if(_e().getBool("WEBGL_CONV_IM2COL"))m=EF({x:r,filter:i,convInfo:p,backend:t});else{const b=new wF(p);m=t.runWebGLProgram(b,[r,i],"float32")}const g=Je({inputs:{x:m},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(m),g}const wce={kernelName:r0,backendName:"webgl",kernelFunc:Sce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ce{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Cce{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=o?1:2,h=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Ece{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Tce{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,h=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ice(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:h}=s,d=Zo(l),p=Ns(r.shape,h,o,1,a,c,!1,d),m=new _ce(p);return t.runWebGLProgram(m,[r,i],"float32")}const Ace={kernelName:RS,backendName:"webgl",kernelFunc:Ice};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mce{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Ws(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rce(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=Zo(c),p=Ns(o,i.shape,a,1,l,h,!1,d);if(_e().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const m=[[p.strideHeight,p.strideWidth]],g=new Mce(p);return t.runWebGLProgram(g,[r,i],"float32",m)}else{const m=new Cce(p);return t.runWebGLProgram(m,[r,i],"float32")}}const kce={kernelName:i0,backendName:"webgl",kernelFunc:Rce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,c=Ya(r.shape,i.shape,o,l,a),h=new yce(c);return t.runWebGLProgram(h,[r,i],"float32")}const Dce={kernelName:o0,backendName:"webgl",kernelFunc:Nce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s,c=Ya(r.shape,l,o,1,a),h=new Ece(c);return t.runWebGLProgram(h,[r,i],"float32")}const Fce={kernelName:kS,backendName:"webgl",kernelFunc:$ce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lce(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s,c=Ya(l,i.shape,a,1,o),h=new Tce(c);return t.runWebGLProgram(h,[r,i],"float32")}const Pce={kernelName:NS,backendName:"webgl",kernelFunc:Lce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oce=Ju+`
  return cos(x);
`,Uce=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${mc}
  return result;
`,zce=on({opSnippet:Oce,packedOpSnippet:Uce}),Bce={kernelName:Ld,backendName:"webgl",kernelFunc:zce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vce=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Gce=on({opSnippet:Vce}),Wce={kernelName:Pd,backendName:"webgl",kernelFunc:Gce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hce{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[h]=t,[d,p]=s;this.outputShape=[h,d,p,c];const m=r==="bilinear"?1:0,[g,b]=[`${a-1}.0`,`${l-1}.0`],[y,v,S]=d>1?[`${(a-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[C,_,A]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${b} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${b}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${_};

        float in_y = ${S};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${A};
        if( in_x < 0.0 || in_x > ${b} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xce=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,h=new Hce(r.shape,i.shape,a,l,c);return t.runWebGLProgram(h,[r,i,o],"float32")},jce={kernelName:$S,backendName:"webgl",kernelFunc:Xce};var Sd;(function(n){n.Prod="*",n.Sum="+"})(Sd||(Sd={}));class bA{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Sd.Prod?"1.0":"0.0",a=s?o:`getX(${SA(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",h="";s?(c=r?`end != ${l-1}`:"end != 0",h=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",h=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${bn(i)} coords = getOutputCoords();
        int end = ${wA(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${h};
          ${wA(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${SA(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function SA(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function wA(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TF(n,e,t,s,r,i){const o=e.shape.length,a=zn([s],o);let l=e;a!=null&&(l=or({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=Yn(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const h=l.shape[c];let d=Lr({inputs:{x:l},backend:t});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const m=new bA(n,l.shape,!1,i),g=[[p]],b=d;d=t.runWebGLProgram(m,[d],d.dtype,g),t.disposeIntermediateTensorInfo(b)}if(r){const p=new bA(n,l.shape,r,i),m=d;d=t.runWebGLProgram(p,[d],d.dtype),t.disposeIntermediateTensorInfo(m)}if(a!=null){const p=Za(a),m=or({inputs:{x:d},backend:t,attrs:{perm:p}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(l),m}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return TF(Sd.Prod,r,t,i,o,a)}const Kce={kernelName:DS,backendName:"webgl",kernelFunc:qce};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return TF(Sd.Sum,r,t,i,o,a)}const Zce={kernelName:a0,backendName:"webgl",kernelFunc:Yce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),c=t.readSync(i.dataId),h=oF(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const l=t.bufferSync(r),c=t.bufferSync(i),h=noe(l,c,o,a);return t.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Jce={kernelName:FS,backendName:"webgl",kernelFunc:Qce};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eue{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],c=o==="NHWC"?r.shape[2]:r.shape[3],h=o==="NHWC"?r.shape[3]:r.shape[1],d=l*i,p=c*i,m=h/(i*i),g=o==="NHWC"?[a,d,p,m]:[a,m,d,p],b=new eue(g,i,o);return t.runWebGLProgram(b,[r],r.dtype)}const nue={kernelName:LS,backendName:"webgl",kernelFunc:tue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IF{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ws(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",h="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AF{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ws(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=d;let m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<d;v++)m+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;m+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let v=0;v<d;v++)m+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(p+1)/2;v++){const S=v*2;if(m+=`
          xC = xCCorner + ${S*c};
          `,l===1){if(S<d&&(a%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }
              `,c===1&&S>0?m+=`
                xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                  } else {
                    xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xC${S} = xTexelC${S};
                `,S+1<d)){const C=a%2===0?xS(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                    xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${S+1}.zw = vec2(0.0);
                    }
                    xTexelC${S+1}Ready = 1;
                  }
                  `,c>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                    } else {
                     xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                    }
                    `:m+=`
                    xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                    `):C===1?m+=`
                    xC${S+1} = xTexelC${S};
                    `:m+=`
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                      xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${S+1}.zw = vec2(0.0);
                      }
                      xTexelC${S+1}Ready = 1;
                    }

                    xC${S+1} = xTexelC${S+1};
                    `}}else S<d&&(a%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.0);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
              `,S+1<d&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(
                  xTexelC${S}.xy, xTexelC${S+1}.xy);
              `,S+1<d&&(m+=`
                  xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                `)));S<d&&(m+=`
            wTexel = getW(r, ${S}, d1, q);
            dotProd += xC${S} * vec4(wTexel.xz, wTexel.xz);
          `,S+1<d&&(m+=`
              wTexel = getW(r, ${S+1}, d1, q);
              dotProd += xC${S+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let g="",b="";s&&(r?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:g=`vec4 activation(vec4 x) {
          ${s}
        }`,b="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${b}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;let h=l;h==null&&(h=[1,1]),W(Vs(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Ns(r.shape,i.shape,o,h,a,c,!0);let p;_e().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new AF(d):p=new IF(d);const m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(p,[r,i],"float32",m)}const rue={kernelName:l0,backendName:"webgl",kernelFunc:sue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iue{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class oue{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:h}=s,d=Ns(r.shape,h,o,a,l,c,!0),p=new iue(d);return t.runWebGLProgram(p,[r,i],"float32")}const lue={kernelName:PS,backendName:"webgl",kernelFunc:aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cue(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:h}=s,d=Ns(h,i.shape,o,a,l,c,!0),p=new oue(d);return t.runWebGLProgram(p,[r,i],"float32")}const uue={kernelName:OS,backendName:"webgl",kernelFunc:cue};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hue{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function due(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=Ne(s.shape),o=Je({inputs:{x:s},backend:t,attrs:{shape:[i]}}),a=new hue(i),l=t.runWebGLProgram(a,[o],o.dtype),c=Je({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const fue={kernelName:dR,backendName:"webgl",kernelFunc:due};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pue{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:h}=e,{top:d,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,c=wf(r.shape,i.shape,o,a,"NHWC",l);let h;const d=new pue(c);h=t.runWebGLProgram(d,[r,i],"float32");const p=Je({inputs:{x:h},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(h),p}const gue={kernelName:c0,backendName:"webgl",kernelFunc:mue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xue(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=i_(r,i.length);a_(o.length,l,i);const{path:c,steps:h}=l_(a,l),d=h.length;let p=null,m=o.length;const g=[];for(let b=0;b<d;++b){for(const y of h[b]){const{permutationIndices:v,expandDims:S}=o_(m,l[y]);let C;c_(v)?C=i[y]:(C=or({inputs:{x:i[y]},backend:t,attrs:{perm:v}}),g.push(C));const _=C.shape.slice();for(let A=0;A<S.length;++A)_.splice(S[A],0,1);mn(C.shape,_)||(C=Je({inputs:{x:C},backend:t,attrs:{shape:_}}),g.push(C)),p===null?p=C:(p=K_({inputs:{a:C,b:p},backend:t}),g.push(p))}b<d-1&&(c[b]>=0&&(p=Sx({inputs:{x:p},backend:t,attrs:{axis:c[b]-(o.length-m),keepDims:!1}}),g.push(p)),m--)}for(const b of g)b!==p&&t.disposeIntermediateTensorInfo(b);return p}const vue={kernelName:US,backendName:"webgl",kernelFunc:xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yue="return (x >= 0.0) ? x : (exp(x) - 1.0);",bue=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Sue=on({opSnippet:yue,packedOpSnippet:bue}),wue={kernelName:Ud,backendName:"webgl",kernelFunc:Sue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ue="return (b >= 0.0) ? a : a * (b + 1.0);",Cue=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Eue=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qu(Cue,s.shape,r.shape):new rc(_ue,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},Tue={kernelName:zS,backendName:"webgl",kernelFunc:Eue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iue=`
  return vec4(equal(a, b));
`,Aue="return float(a == b);",Mue=$s({opSnippet:Aue,packedOpSnippet:Iue,dtype:"bool",cpuKernelImpl:aoe}),Rue={kernelName:u0,backendName:"webgl",kernelFunc:Mue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kue=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Qw};
  float a1 = ${Jw};
  float a2 = ${e_};
  float a3 = ${t_};
  float a4 = ${n_};
  float a5 = ${s_};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Nue=on({opSnippet:kue}),Due={kernelName:zd,backendName:"webgl",kernelFunc:Nue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ue=Ju+`
  return exp(x);
`,Fue=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,MF=on({opSnippet:$ue,packedOpSnippet:Fue,cpuKernelImpl:loe,dtype:"float32"}),Lue={kernelName:Bd,backendName:"webgl",kernelFunc:MF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lb(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(W(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Je({inputs:{x:i},backend:s,attrs:{shape:a}})}const Pue={kernelName:h0,backendName:"webgl",kernelFunc:Lb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _A="return exp(x) - 1.0;",Oue=on({opSnippet:_A,packedOpSnippet:_A,cpuKernelImpl:coe}),Uue={kernelName:Vd,backendName:"webgl",kernelFunc:Oue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CA{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(n,e,t){const s=t.texData.get(n.dataId),r=Ne(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=Je({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),l=a.shape,c=new CA("real",l,e),h=new CA("imag",l,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=t.runWebGLProgram(c,d,"float32"),m=t.runWebGLProgram(h,d,"float32"),g=sl({inputs:{real:p,imag:m},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m);const b=Je({inputs:{x:g},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(g),b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zue(n){const{inputs:e,backend:t}=n,{input:s}=e;return RF(s,!1,t)}const Bue={kernelName:BS,backendName:"webgl",kernelFunc:zue};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vue{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gf(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||Lu(r),i==="string"){const o=jn(i,Ne(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new Vue(s,r),a=[[r]];return e.runWebGLProgram(o,[],i,a)}}const Gue={kernelName:VS,backendName:"webgl",kernelFunc:Gf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wue{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hue={kernelName:GS,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new Wue(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EA="return floor(x);",Xue=on({opSnippet:EA,packedOpSnippet:EA,cpuKernelImpl:uoe}),jue={kernelName:Gd,backendName:"webgl",kernelFunc:Xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const que=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Kue=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Yue=$s({opSnippet:que,packedOpSnippet:Kue,dtype:"int32"}),Zue={kernelName:Wd,backendName:"webgl",kernelFunc:Yue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Que{constructor(e){this.variableNames=["A"];const t=ar(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jue{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ar(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ehe={kernelName:g5,backendName:"webgl",kernelFunc:the};let ru,a1=_e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function the(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],h=[c,l],d=[c,l,i];if(a||o){const b=_e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(ru==null||b!==a1)&&(a1=b,ru=document.createElement("canvas").getContext("2d",{willReadFrequently:a1})),ru.canvas.width=l,ru.canvas.height=c,ru.drawImage(r,0,0,l,c),r=ru.canvas}const p=t.makeTensorInfo(h,"int32");t.texData.get(p.dataId).usage=Xr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),r);const m=_e().getBool("WEBGL_PACK")?new Jue(d):new Que(d),g=t.runWebGLProgram(m,[p],"int32");return t.disposeData(p.dataId),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=s,b=Zo(h),y=Ns(r.shape,i.shape,l,d,c,p,!1,b);let v;const S=[],C=o!=null,_=a!=null,A=m==="leakyrelu",k=()=>{const D=[r,i],M=(T,I)=>{if(I==="NCHW"&&T.shape.length===1&&T.shape[0]!==1){const $=Je({inputs:{x:T},backend:t,attrs:{shape:[T.shape[0],1,1]}});return S.push($),$}return T};if(C&&D.push(M(o,h)),_&&D.push(M(a,h)),A){const T=t.makeTensorInfo([],"float32",Ka(g,"float32"));D.push(T),S.push(T)}return D};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))v=CF({x:r,filter:i,convInfo:y,backend:t,bias:o,activation:m,preluActivationWeights:a,leakyreluAlpha:g});else if(y.strideWidth<=2&&b==="channelsLast"&&_e().getBool("WEBGL_EXP_CONV")){const D=m?yd(m,!0):null,M=new _F(y,C,D,_,A),T=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],I=k();v=t.runWebGLProgram(M,I,"float32",T)}else if(_e().getBool("WEBGL_CONV_IM2COL"))v=EF({x:r,filter:i,convInfo:y,backend:t,bias:o,activation:m,preluActivationWeights:a,leakyreluAlpha:g});else{const D=m?yd(m,!1):null,M=new wF(y,C,D,_,A),T=k();v=t.runWebGLProgram(M,T,"float32")}const N=Je({inputs:{x:v},backend:t,attrs:{shape:y.outShape}});return S.push(v),S.forEach(D=>t.disposeIntermediateTensorInfo(D)),N}const she={kernelName:hg,backendName:"webgl",kernelFunc:nhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:m}=s,g=[];let b=h;b==null&&(b=[1,1]),W(Vs(l,b),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${b}'`);const y=Ns(r.shape,i.shape,l,b,c,d,!0),v=_e().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,S=p?yd(p,v):null,C=[r,i],_=o!=null,A=a!=null,k=p==="leakyrelu";if(_&&C.push(o),A&&C.push(a),k){const T=t.makeTensorInfo([],"float32",Ka(m,"float32"));C.push(T),g.push(T)}let N;v?N=new AF(y,_,S,A,k):N=new IF(y,_,S,A,k);const D=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],M=t.runWebGLProgram(N,C,"float32",D);return g.forEach(T=>t.disposeIntermediateTensorInfo(T)),M}const ihe={kernelName:kR,backendName:"webgl",kernelFunc:rhe};class ohe{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=bn(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ahe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=Ne(s.shape),[l,c,h,d]=Bw(s,r),p=Je({inputs:{x:r},backend:t,attrs:{shape:[c,o]}}),m=Je({inputs:{x:s},backend:t,attrs:{shape:[Ne(s.shape)/h,h]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const v=t.readSync(r.dataId),S=t.bufferSync(s),C=hoe(v,S,s.dtype,c,o,h,d,s.shape,a);return t.makeTensorInfo(l,s.dtype,C.values)}const g=new ohe(o,d,[c,h],s.shape),b=t.runWebGLProgram(g,[m,p],m.dtype),y=Je({inputs:{x:b},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),y}const lhe={kernelName:fR,backendName:"webgl",kernelFunc:ahe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class che{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=bn(this.rank),r=uhe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function uhe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,l=qt(o,r.shape)[0];if(_e().get("DEBUG")){const S=t.readSync(i.dataId),C=r.shape[l];for(let _=0;_<S.length;++_){const A=S[_];W(A<=C-1&&A>=0,()=>`GatherV2: the index value ${A} is not in [0, ${C-1}]`)}}const c=h_(r,i,l,a),h=Ne(i.shape),d=[],p=Je({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=Je({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,h/c.batchSize]}});d.push(p),d.push(m);const g=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const S=t.bufferSync(m),C=t.bufferSync(p),_=doe(C,S,g);return d.forEach(A=>t.disposeIntermediateTensorInfo(A)),t.makeTensorInfo(c.outputShape,_.dtype,_.values)}const b=new che(p.shape,g),y=t.runWebGLProgram(b,[p,m],p.dtype);d.push(y);const v=Je({inputs:{x:y},backend:t,attrs:{shape:c.outputShape}});return d.forEach(S=>t.disposeIntermediateTensorInfo(S)),v}const hhe={kernelName:f0,backendName:"webgl",kernelFunc:kF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dhe="return float(a > b);",fhe=`
  return vec4(greaterThan(a, b));
`,phe=$s({opSnippet:dhe,packedOpSnippet:fhe,cpuKernelImpl:foe,dtype:"bool"}),mhe={kernelName:p0,backendName:"webgl",kernelFunc:phe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ghe="return float(a >= b);",xhe=`
  return vec4(greaterThanEqual(a, b));
`,vhe=$s({opSnippet:ghe,packedOpSnippet:xhe,dtype:"bool",cpuKernelImpl:poe}),yhe={kernelName:Hd,backendName:"webgl",kernelFunc:vhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bhe(n){const{inputs:e,backend:t}=n,{input:s}=e;return RF(s,!0,t)}const She={kernelName:WS,backendName:"webgl",kernelFunc:bhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const whe="return float(!isnan(x) && !isinf(x));",_he=on({opSnippet:whe,dtype:"bool"}),Che={kernelName:jd,backendName:"webgl",kernelFunc:_he};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ehe="return float(isinf(x));",The=on({opSnippet:Ehe,dtype:"bool"}),Ihe={kernelName:qd,backendName:"webgl",kernelFunc:The};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ahe="return float(isnan(x));",Mhe=on({opSnippet:Ahe,dtype:"bool"}),Rhe={kernelName:Kd,backendName:"webgl",kernelFunc:Mhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const khe="return float(a < b);",Nhe=`
  return vec4(lessThan(a, b));
`,Dhe=$s({opSnippet:khe,packedOpSnippet:Nhe,cpuKernelImpl:moe,dtype:"bool"}),$he={kernelName:g0,backendName:"webgl",kernelFunc:Dhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fhe="return float(a <= b);",Lhe=`
  return vec4(lessThanEqual(a, b));
`,Phe=$s({opSnippet:Fhe,packedOpSnippet:Lhe,cpuKernelImpl:goe,dtype:"bool"}),Ohe={kernelName:x0,backendName:"webgl",kernelFunc:Phe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uhe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=xoe(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const zhe={kernelName:pR,backendName:"webgl",kernelFunc:Uhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bhe=Ju+`
  return x < 0.0 ? 0./0. : log(x);
`,Vhe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Ghe=on({opSnippet:Bhe,packedOpSnippet:Vhe,cpuKernelImpl:voe}),Whe={kernelName:Yd,backendName:"webgl",kernelFunc:Ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hhe=Ju+`
  return log(1.0 + x);
`,Xhe=on({opSnippet:Hhe}),jhe={kernelName:Zd,backendName:"webgl",kernelFunc:Xhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qhe="return float(a >= 1.0 && b >= 1.0);",Khe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Yhe=$s({opSnippet:qhe,packedOpSnippet:Khe,dtype:"bool"}),Zhe={kernelName:v0,backendName:"webgl",kernelFunc:Yhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qhe="return float(!(x >= 1.0));",Jhe=on({opSnippet:Qhe}),ede={kernelName:y0,backendName:"webgl",kernelFunc:Jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tde="return float(a >= 1.0 || b >= 1.0);",nde=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,sde=$s({opSnippet:tde,packedOpSnippet:nde,dtype:"bool"}),rde={kernelName:b0,backendName:"webgl",kernelFunc:sde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ide{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ode{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ade=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s,c=_e().getBool("WEBGL_PACK_NORMALIZATION")?new ode(r.shape,i,o,a,l):new ide(r.shape,i,o,a,l);return t.runWebGLProgram(c,[r],r.dtype)},lde={kernelName:S0,backendName:"webgl",kernelFunc:ade};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cde{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ude=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:h}=s,d=new cde(r.shape,a,l,c,h);return t.runWebGLProgram(d,[r,i,o],r.dtype)},hde={kernelName:XS,backendName:"webgl",kernelFunc:ude};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dde(n,e,t,s){const r=Ne(e),o=Ne(n.shape)/r,a=Je({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=gc(a,n.dtype,"max",s),c=Je({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=qt(i,r.shape);let c=l;const h=zn(c,a),d=h!=null,p=t.shouldExecuteOnCPU([r]);let m=r;if(d){if(p){const C=t.texData.get(m.dataId).values,_=new Array(a);for(let N=0;N<_.length;N++)_[N]=r.shape[h[N]];const A=j_(C,r.shape,r.dtype,h,_);m=t.makeTensorInfo(_,r.dtype);const k=t.texData.get(m.dataId);k.values=A}else m=bx(r,h,t);c=Yn(c.length,a)}Ds("max",c,a);const[g,b]=ws(m.shape,c);let y=g;o&&(y=rs(g,l));let v;if(p){const C=t.texData.get(m.dataId).values,_=yoe(C,Ne(b),y,r.dtype);v=t.makeTensorInfo(y,r.dtype);const A=t.texData.get(v.dataId);A.values=_}else v=dde(m,b,y,t);return d&&t.disposeIntermediateTensorInfo(m),v}const fde={kernelName:w0,backendName:"webgl",kernelFunc:NF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pde=q_+`
  return max(a, b);
`,mde=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+mc+`
  return result;
`,gde=$s({opSnippet:pde,packedOpSnippet:mde,cpuKernelImpl:boe}),xde={kernelName:Qd,backendName:"webgl",kernelFunc:gde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;zf(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(Vs(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=gi(r.shape,i,o,c,a,l);if(h.filterWidth===1&&h.filterHeight===1&&mn(h.inShape,h.outShape))return Lr({inputs:{x:r},backend:t});const d=new bd(h,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const yde={kernelName:_0,backendName:"webgl",kernelFunc:vde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,h=[1,1,1],d=Yo(r.shape,i,o,h,a,c,l),p=new Y_(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const Sde={kernelName:C0,backendName:"webgl",kernelFunc:bde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wde{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class _de{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=l-1-e.padInfo.front,p=c-1-e.padInfo.top,m=h-1-e.padInfo.left,g=l*c*h-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${p}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=Yo(o.shape,a,l,d,c,h),m=new Y_(p,"max",!0),g=t.runWebGLProgram(m,[o],o.dtype),b=new _de(p),y=t.runWebGLProgram(b,[r,g],o.dtype);return t.disposeIntermediateTensorInfo(g),y}const Ede={kernelName:qS,backendName:"webgl",kernelFunc:Cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;zf([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=gi(a.shape,l,c,1,h,d),m=!0,g=new bd(p,"max",m),b=t.runWebGLProgram(g,[a],a.dtype),y=new wde(p),v=t.runWebGLProgram(y,[r,b],a.dtype);return t.disposeIntermediateTensorInfo(b),v}const Ide={kernelName:jS,backendName:"webgl",kernelFunc:Tde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ade(n,e,t,s){let r=new bd(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new bd(t,"max",!0,!0,e);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mde={kernelName:mR,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;W(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];W(Vs(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=gi(s.shape,r,i,c,o),[d,p]=Ade(s,a,h,l);return[d,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rde(n,e,t,s){const r=Ne(e),o=Ne(n.shape)/r,a=Je({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=gc(a,"float32","mean",s),c=Je({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kde={kernelName:E0,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,o=t,a=s.shape.length,l=qt(i,s.shape);let c=l;const h=zn(c,a),d=h!=null,p=o.shouldExecuteOnCPU([s]),m=[];let g=s;if(d){if(p){const _=o.texData.get(g.dataId).values,A=new Array(a);for(let D=0;D<A.length;D++)A[D]=s.shape[h[D]];const k=j_(_,s.shape,s.dtype,h,A);g=o.makeTensorInfo(A,s.dtype);const N=o.texData.get(g.dataId);N.values=k}else g=bx(s,h,o);m.push(g),c=Yn(c.length,a)}Ds("sum",c,a);const[b,y]=ws(g.shape,c);let v=b;r&&(v=rs(b,l));const S=Rde(g,y,v,o);for(const C of m)o.disposeIntermediateTensorInfo(C);return S}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=qt(i,r.shape);let c=l;const h=zn(c,a);let d=r;h!=null&&(d=or({inputs:{x:r},backend:t,attrs:{perm:h}}),c=Yn(c.length,r.shape.length)),Ds("min",c,a);const[p,m]=ws(d.shape,c),g=Ne(m),b=Je({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),y=gc(b,b.dtype,"min",t);let v;if(o){const S=rs(p,l);v=Je({inputs:{x:y},backend:t,attrs:{shape:S}})}else v=Je({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(y),h!=null&&t.disposeIntermediateTensorInfo(d),v}const Dde={kernelName:T0,backendName:"webgl",kernelFunc:Nde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $de=q_+`
  return min(a, b);
`,Fde=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+mc+`
  return result;
`,Lde=$s({opSnippet:$de,packedOpSnippet:Fde,cpuKernelImpl:Soe}),Pde={kernelName:Jd,backendName:"webgl",kernelFunc:Lde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ode{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((h,d)=>h[0]+e[d]+h[1]);const r=e.length,i=bn(r),o=t.map(h=>h[0]).join(","),a=t.map((h,d)=>h[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ude{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((g,b)=>g[0]+e[b]+g[1]);const r=e.length,i=bn(r),o=t.map(g=>g[0]).join(","),a=t.map((g,b)=>g[0]+e[b]).join(","),l=nr("rc",r),c=nr("source",r),h=`${l[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${c.slice(-2).join()})`,p=s==="reflect"?0:1;let m="";if(r===1){const g=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;m=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[r-1]} += 1;
        if(${h}) {
          ${g}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const g=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;m=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[r-1]} += 1;
        if(${h}) {
          ${g}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${g}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[r-1]} += 1;
          if(${h}) {
            ${g}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zde=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,o=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ude(s.shape,r,i):new Ode(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)},Bde={kernelName:I0,backendName:"webgl",kernelFunc:zde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vde=`if (b == 0.0) return NAN;
  return mod(a, b);`,Gde=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+mc+`
  return result;
`,Wde=$s({opSnippet:Vde,packedOpSnippet:Gde}),Hde={kernelName:ef,backendName:"webgl",kernelFunc:Wde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xde{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jde=`
if (a == b) {
  return 1.0;
};
return a / b;`,qde=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,DF=$s({opSnippet:jde,packedOpSnippet:qde,checkOutOfBounds:!0}),Kde={kernelName:Od,backendName:"webgl",kernelFunc:DF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TA="return a - b;",$F=$s({opSnippet:TA,packedOpSnippet:TA,supportsComplex:!0,cpuKernelImpl:Voe}),Yde={kernelName:xf,backendName:"webgl",kernelFunc:$F};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=qt([i],r.shape),a=NF({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=rs(a.shape,o),c=Je({inputs:{x:a},backend:t,attrs:{shape:l}}),h=$F({inputs:{a:r,b:c},backend:t}),d=MF({inputs:{x:h},backend:t}),p=Sx({inputs:{x:d},backend:t,attrs:{axis:o,keepDims:!1}}),m=Je({inputs:{x:p},backend:t,attrs:{shape:l}}),g=DF({inputs:{a:d,b:m},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const Zde={kernelName:H0,backendName:"webgl",kernelFunc:FF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qde(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,l=a?r:FF({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=l.shape[0],h=l.shape[1],d=new Xde(c,h,i),p=[[o]],m=t.runWebGLProgram(d,[l],"int32",p);return a||t.disposeIntermediateTensorInfo(l),m}const Jde={kernelName:gR,backendName:"webgl",kernelFunc:Qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const efe=vi+`
  return -x;
`,tfe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function nfe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[o,a]=_oe(i.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}let r;return _e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ka(s.shape,tfe):r=new ao(s.shape,efe),t.runWebGLProgram(r,[s],s.dtype)}const sfe={kernelName:A0,backendName:"webgl",kernelFunc:nfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rfe=Lw;function ife(n){Wr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=t.readSync(r.dataId),h=t.readSync(i.dataId),{selectedIndices:d}=rfe(c,h,o,a,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const ofe={kernelName:KS,backendName:"webgl",kernelFunc:ife};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const afe=Pw;function lfe(n){Wr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:p,validOutputs:m}=afe(h,d,o,a,l,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([m]))]}const cfe={kernelName:YS,backendName:"webgl",kernelFunc:lfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ufe=Ow;function hfe(n){Wr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),p=o,m=a,g=l,b=c,{selectedIndices:y,selectedScores:v}=ufe(h,d,p,m,g,b);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const dfe={kernelName:ZS,backendName:"webgl",kernelFunc:hfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ffe{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pfe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:l}=s,c=Ne(r.shape),h=new ffe(c,o,a,l),d=Je({inputs:{x:r},backend:t,attrs:{shape:[c]}}),p=t.runWebGLProgram(h,[d],i);t.disposeIntermediateTensorInfo(d);const m=[...r.shape,o],g=Je({inputs:{x:p},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(p),g},mfe={kernelName:k0,backendName:"webgl",kernelFunc:pfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lg(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Vf({inputs:{input:s},backend:t}),i=Lg({inputs:{x:r},backend:t}),o=wx({inputs:{input:s},backend:t}),a=Lg({inputs:{x:o},backend:t}),l=sl({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Gf({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const gfe={kernelName:q0,backendName:"webgl",kernelFunc:Lg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LF(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Vf({inputs:{input:s},backend:t}),i=LF({inputs:{x:r},backend:t}),o=wx({inputs:{input:s},backend:t}),a=Lg({inputs:{x:o},backend:t}),l=sl({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Gf({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const xfe={kernelName:R0,backendName:"webgl",kernelFunc:LF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vfe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Lb({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(h=>{vS(i,h.shape,"All tensors passed to stack must have matching shapes"),W(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(h=>{const d=Lb({inputs:{input:h},backend:t,attrs:{dim:r}});return a.push(d),d}),c=SF({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const yfe={kernelName:N0,backendName:"webgl",kernelFunc:vfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bfe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,i=bn(r),o=t.map(c=>c[0]).join(","),a=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sfe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((b,y)=>b[0]+e[y]+b[1]);const r=e.length,i=bn(r),o=t.map(b=>b[0]).join(","),a=t.map((b,y)=>b[0]+e[y]).join(","),l=nr("rc",r),c=nr("source",r),h=`${l[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${h}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${h}) {`],m=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let b=0,y=r===1?2:4;b<y;b++)g+=`
        ${p[b]}
        if (${m}) {
          result[${b}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${b}] = getChannel(getX(${c.join()}), ${d});
        }
      `;g+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PF=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;if(Ne(r.shape)===0){const c=i.map((h,d)=>h[0]+r.shape[d]+h[1]);return Gf({backend:t,attrs:{shape:c,value:o,dtype:r.dtype}})}const a=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sfe(r.shape,i,o):new bfe(r.shape,i,o),l=[[o]];return t.runWebGLProgram(a,[r],r.dtype,l)},wfe={kernelName:D0,backendName:"webgl",kernelFunc:PF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _fe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Cfe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+mc+`
  return result;
`,Efe=$s({opSnippet:_fe,packedOpSnippet:Cfe}),Tfe={kernelName:nf,backendName:"webgl",kernelFunc:Efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ife(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],c=qt(i,r.shape);let h=c;const d=zn(h,a);let p=r;d!=null&&(p=or({inputs:{x:r},backend:t,attrs:{perm:d}}),h=Yn(h.length,a),l.push(p)),Ds("prod",h,a);let m;if(t.shouldExecuteOnCPU([p])){const g=t.texData.get(p.dataId).values,{outVals:b,outShape:y,outDtype:v}=Eoe(p.shape,p.dtype,g,h);m=t.makeTensorInfo(y,v,b)}else{const[g,b]=ws(p.shape,h),y=Ne(b),v=Je({inputs:{x:p},backend:t,attrs:{shape:[-1,y]}}),S=cw(r.dtype),C=gc(v,S,"prod",t);m=Je({inputs:{x:C},backend:t,attrs:{shape:g}}),l.push(v),l.push(C)}if(o){l.push(m);const g=rs(m.shape,c);m=Je({inputs:{x:m},backend:t,attrs:{shape:g}})}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const Afe={kernelName:F0,backendName:"webgl",kernelFunc:Ife};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mfe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,l=r.map(v=>t.readSync(v.dataId)),c=r.map(v=>v.shape),h=t.readSync(i.dataId),d=t.readSync(o.dataId),[p,m,g]=Toe(l,c,h,i.shape,i.dtype,d,o.shape,a),b=p.map(v=>t.makeTensorInfo([v.length],"int32",v)),y=t.makeTensorInfo(g,i.dtype,m);return b.concat([y])}const Rfe={kernelName:xR,backendName:"webgl",kernelFunc:Mfe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kfe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,h]=Ioe(o,s.shape,s.dtype,a,r.shape,l,i.shape),d=t.makeTensorInfo([c.length],"int32",c),p=t.makeTensorInfo([h.length],s.dtype,h);return[d,p]}const Nfe={kernelName:vR,backendName:"webgl",kernelFunc:kfe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dfe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.readSync(r.dataId),h=t.readSync(i.dataId),d=t.readSync(o.dataId),p=a.map(y=>t.readSync(y.dataId)),m=a.map(y=>y.shape),[g,b]=Aoe(c,r.shape,h,i.shape,i.dtype,d,o.shape,p,m,l);return t.makeTensorInfo(g,i.dtype,b)}const $fe={kernelName:yR,backendName:"webgl",kernelFunc:Dfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OF=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:o}=t,a=Moe(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},Ffe={kernelName:QS,backendName:"webgl",kernelFunc:OF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lfe="return 1.0 / x;",Pfe=on({opSnippet:Lfe}),Ofe={kernelName:sf,backendName:"webgl",kernelFunc:Pfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ufe=vi+`
  return (x < 0.0) ? 0.0 : x;
`,zfe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bfe=on({opSnippet:Ufe,packedOpSnippet:zfe}),Vfe={kernelName:rf,backendName:"webgl",kernelFunc:Bfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gfe=vi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Wfe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Hfe=on({opSnippet:Gfe,packedOpSnippet:Wfe}),Xfe={kernelName:of,backendName:"webgl",kernelFunc:Hfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jfe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const h=[r&&t>1?a-1:a,r&&s>1?l-1:l],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;i?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qfe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const h=[r&&t>1?a-1:a,r&&s>1?l-1:l],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;i?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,h=_e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qfe(r.shape,l,c,i,o):new jfe(r.shape,l,c,i,o);return t.runWebGLProgram(h,[r],"float32")}const Yfe={kernelName:O0,backendName:"webgl",kernelFunc:Kfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zfe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],h=l[0]/c[0],d=l[1]/c[1],p=1/h,m=1/d,g=Math.ceil(p)*2+2,b=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qfe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new Zfe(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const Jfe={kernelName:tw,backendName:"webgl",kernelFunc:Qfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class epe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const h=[r&&t>1?a-1:a,r&&s>1?l-1:l],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let m;i?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tpe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const h=[r&&t>1?a-1:a,r&&s>1?l-1:l],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let m;i?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function npe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,h=_e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tpe(r.shape,l,c,i,o):new epe(r.shape,l,c,i,o);return t.runWebGLProgram(h,[r],r.dtype)}const spe={kernelName:P0,backendName:"webgl",kernelFunc:npe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rpe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],h=l[0]/c[0],d=l[1]/c[1],p=1/h,m=1/d,g=Math.ceil(p)*2+2,b=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ipe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new rpe(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const ope={kernelName:ew,backendName:"webgl",kernelFunc:ipe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ape{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>r(l)).join(","),o=bn(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lpe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=nr("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=bn(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${o}) {
            result.b = ${h(r.slice())};
            if(${i}) {
              result.a = ${d(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(g){return p(g)}function c(g){return g[s-1]="("+g[s-1]+" + 1)",p(g)}function h(g){return g[s-2]="("+g[s-2]+" + 1)",p(g)}function d(g){return g[s-1]="("+g[s-1]+" + 1)",g[s-2]="("+g[s-2]+" + 1)",p(g)}function p(g){const b=e.map((S,C)=>m(C,g)),y=b.join(","),v=b.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${v}))`}function m(g,b){return t.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${b[g]} - 1`:`${b[g]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,o=r.shape.length,a=qt(i,r.shape);if(o===0)return Lr({inputs:{x:r},backend:t});const l=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lpe(r.shape,a):new ape(r.shape,a);return t.runWebGLProgram(l,[r],r.dtype)}const upe={kernelName:U0,backendName:"webgl",kernelFunc:cpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hpe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dpe={kernelName:lw,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,l=new hpe(s.shape,i),[c,h]=Kw(o,s.shape[1],s.shape[2]),d=[[c,h,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fpe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,ppe=on({opSnippet:fpe}),mpe={kernelName:af,backendName:"webgl",kernelFunc:ppe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gpe="return inversesqrt(x);",xpe=on({opSnippet:gpe,cpuKernelImpl:Roe}),vpe={kernelName:lf,backendName:"webgl",kernelFunc:xpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z_{constructor(e,t,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=bn(i.length),h=bn(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let m="";r===1?m="i":r===2&&(m="i, coords[1]");const g=`getUpdates(${m})`;let b="";l&&(b="coords[0], coords[1]");const y=`getDefaultValue(${b})`,v=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${y}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ype{constructor(e,t,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=bn(i.length),h=bn(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let m="";r===1?m="i":r===2&&(m="i, coords[1]");const g=`getUpdates(${m})`;let b="";l&&(b="coords[0], coords[1]");const y=`getDefaultValue(${b})`,v=t>1?"strides[j]":"strides",S=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${S};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bpe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=uc(i,r,o),p=[d/c,c];if(d===0)return t.makeTensorInfo(o,r.dtype);const m=Je({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),g=Je({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),b=t.makeTensorInfo([],"float32",new Float32Array([0]));let y;_e().getBool("WEBGL_PACK")?y=new ype(l,a,m.shape.length,g.shape.length,h,p):y=new Z_(l,a,m.shape.length,g.shape.length,h,p);const v=t.runWebGLProgram(y,[g,m,b],g.dtype),S=Je({inputs:{x:v},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(b),S}const Spe={kernelName:bR,backendName:"webgl",kernelFunc:bpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wpe{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=_e().getNumber("WEBGL_VERSION")===2?i:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _pe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,a=new wpe(r.shape[0],r.shape[1],i.shape[1],o),l=[[r.shape[1]]];return t.runWebGLProgram(a,[r,i],"int32",l)}const Cpe={kernelName:wR,backendName:"webgl",kernelFunc:_pe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Epe{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let h=0;h<t.length;h++)c.push(`${a[h]}`),h<e&&l.push(`${a[h]}`);r=l.join(),i=c.join()}const o=bn(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tpe(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,o=new Epe(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[s,r,i],$r(r.dtype,i.dtype))}const Ipe={kernelName:z0,backendName:"webgl",kernelFunc:Tpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ape=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${rx};
  float scale = ${ix};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Mpe=on({opSnippet:Ape}),Rpe={kernelName:cf,backendName:"webgl",kernelFunc:Mpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kpe=Ju+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Npe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dpe=on({opSnippet:kpe,packedOpSnippet:Npe,cpuKernelImpl:Noe}),$pe={kernelName:ff,backendName:"webgl",kernelFunc:Dpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fpe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Lpe=on({opSnippet:Fpe}),Ppe={kernelName:df,backendName:"webgl",kernelFunc:Lpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ope=Ju+`
  return sin(x);
`,Upe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${mc}
  return result;
`,zpe=on({opSnippet:Ope,packedOpSnippet:Upe}),Bpe={kernelName:uf,backendName:"webgl",kernelFunc:zpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vpe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Gpe=on({opSnippet:Vpe}),Wpe={kernelName:hf,backendName:"webgl",kernelFunc:Gpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hpe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Xpe=on({opSnippet:Hpe}),jpe={kernelName:pf,backendName:"webgl",kernelFunc:Xpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qpe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;W(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((v,S)=>v*S),l=[[0,0]];l.push(...o);for(let v=1+i.length;v<r.shape.length;++v)l.push([0,0]);const c=[],h=PF({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),d=If(h.shape,i,a,!1),p=Af(d.length,i.length,!1),m=Mf(h.shape,i,a,!1),g=Je({inputs:{x:h},backend:t,attrs:{shape:d}}),b=or({inputs:{x:g},backend:t,attrs:{perm:p}}),y=Je({inputs:{x:b},backend:t,attrs:{shape:m}});return c.push(h),c.push(g),c.push(b),c.forEach(v=>t.disposeIntermediateTensorInfo(v)),y},Kpe={kernelName:G0,backendName:"webgl",kernelFunc:qpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ype(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),h=t.readSync(o.dataId)[0],[d,p,m,g,b]=$oe(a,s.shape,s.dtype,l,r.dtype,c,h);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([p[0]],r.dtype,m),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(y=>Number(y)))),t.makeTensorInfo([b.length],s.dtype,new Int32Array(b))]}const Zpe={kernelName:_R,backendName:"webgl",kernelFunc:Ype};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qpe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(r.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(i.dataId)),[c,h,d]=Foe(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(h,s.dtype,c),t.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}const Jpe={kernelName:CR,backendName:"webgl",kernelFunc:Qpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eme(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,h]=lF(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(h,s.dtype,c)}const tme={kernelName:ER,backendName:"webgl",kernelFunc:eme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nme(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,h]=lF(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(h,s.dtype,c)}const sme={kernelName:TR,backendName:"webgl",kernelFunc:nme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rme(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=uc(i,r,a),m=!1;if(i.dtype==="string"){const v=t.bufferSync(r),S=t.bufferSync(i),C=Ba(t.readSync(o.dataId)[0]),_=koe(v,S,a,p,h,c,l,d,C,m);return t.makeTensorInfo(a,_.dtype,_.values)}const g=new Z_(c,l,r.shape.length,i.shape.length,d,[p,1],m),b=t.runWebGLProgram(g,[i,r,o],i.dtype),y=Je({inputs:{x:b},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(b),y}const ime={kernelName:IR,backendName:"webgl",kernelFunc:rme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ome(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=qt(o,r.shape)[0],l=u_(r,i,a),c=r.shape.length,h=new Array(c).fill(0),d=r.shape.slice();return l.map(p=>{const m=[...d];m[a]=p;const g=eh({inputs:{x:r},backend:t,attrs:{begin:h,size:m}});return h[a]+=p,g})}const ame={kernelName:W0,backendName:"webgl",kernelFunc:ome};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IA="return sqrt(x);",lme=on({opSnippet:IA,packedOpSnippet:IA,cpuKernelImpl:Loe}),cme={kernelName:mf,backendName:"webgl",kernelFunc:lme};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ume="return x * x;",hme=on({opSnippet:ume}),dme={kernelName:nw,backendName:"webgl",kernelFunc:hme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AA="return (a - b) * (a - b);",fme=$s({opSnippet:AA,packedOpSnippet:AA}),pme={kernelName:gf,backendName:"webgl",kernelFunc:fme};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),o=qo(i),a=Poe(o,"string",s);return t.makeTensorInfo(r.shape,"string",a)}const gme={kernelName:sw,backendName:"webgl",kernelFunc:mme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xme({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=vi+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new ao(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const vme={kernelName:Sf,backendName:"webgl",kernelFunc:xme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yme{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=bn(s.length),o=bn(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((c,h)=>(l++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${l-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s,{finalShapeSparse:m,finalShape:g,isIdentity:b,sliceDim0:y,isSimpleSlice:v,begin:S,end:C,strides:_}=Xw(r.shape,i,o,a,l,c,h,d,p);let A;if(b)A=Je({inputs:{x:r},backend:t,attrs:{shape:g}});else if(y||v){W(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const N=Gw(S,C,_),D=eh({inputs:{x:r},backend:t,attrs:{begin:S,size:N}});A=Je({inputs:{x:D},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(D)}else if(t.shouldExecuteOnCPU([r])){const D=t.readSync(r.dataId),M=jt(r.shape,r.dtype,D),T=Ooe(m,M,_,S);A=t.makeTensorInfo(g,r.dtype,T.values)}else{const D=new yme(S,_,m);A=t.runWebGLProgram(D,[r],r.dtype)}const k=Je({inputs:{x:A},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(A),k}const Sme={kernelName:rw,backendName:"webgl",kernelFunc:bme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wme(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:d}=e,p=t.readSync(h.dataId),m=t.readSync(d.dataId),[g,b]=Uoe(p,m,r,i,o,a,l,c);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(d.shape,"int32",b)]}const _me={kernelName:AR,backendName:"webgl",kernelFunc:wme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cme(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(o.dataId)[0],[c,h,d]=zoe(a,l,r),p=h.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const Eme={kernelName:MR,backendName:"webgl",kernelFunc:Cme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tme(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=Boe(o,r);return t.makeTensorInfo(i.shape,"int32",a)}const Ime={kernelName:RR,backendName:"webgl",kernelFunc:Tme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ame="return tan(x);",Mme=on({opSnippet:Ame}),Rme={kernelName:vf,backendName:"webgl",kernelFunc:Mme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kme=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Nme=on({opSnippet:kme}),Dme={kernelName:yf,backendName:"webgl",kernelFunc:Nme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $me(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=uc(o,i,r.shape),p=[d/c,c];if(d===0)return t.makeTensorInfo(r.shape,i.dtype);const m=Je({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),g=Je({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}),b=Je({inputs:{x:r},backend:t,attrs:{shape:p}}),y=new Z_(l,a,m.shape.length,g.shape.length,h,p,!1,!0),v=t.runWebGLProgram(y,[g,m,b],b.dtype),S=Je({inputs:{x:v},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),S}const Fme={kernelName:SR,backendName:"webgl",kernelFunc:$me};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lme{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const r=bn(this.rank),i=Pme(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function Pme(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),c=r.dtype==="string"?l.map(p=>Ba(p)):l,h=jt(r.shape,r.dtype,c),d=Goe(h,i);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new Lme(r.shape,i);return t.runWebGLProgram(o,[r],r.dtype)}const Ome={kernelName:bf,backendName:"webgl",kernelFunc:UF};class Ume{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class zme{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tl(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function MA(n){let e=1;for(;e<n;)e*=2;return e}function Bme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s,a=_e().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=_e().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,h=c[c.length-1];if(t.shouldExecuteOnCPU([r])||h<a||i>l){const T=t.readSync(r.dataId),[I,$]=Woe(T,c,r.dtype,i,o);return[t.makeTensorInfo(I.shape,I.dtype,I.values),t.makeTensorInfo($.shape,$.dtype,$.values)]}if(i===0)return c[c.length-1]=0,[t.makeTensorInfo(c,r.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(h===1)return[r,Gf({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const d=t.texData.get(r.dataId),p=d!==null&&d.isPacked,m=p?t.unpackTensor(r):r,b=Ne(c)/h,y=Je({inputs:{x:m},attrs:{shape:[b,h]},backend:t});p&&Tl(t,m);const v=MA(i),S=MA(h);let C=null;const _=()=>C===null?[y,y]:[y,C],A=(T,I,$)=>{const O=_(),B=new Ume($),H=[[h],[C===null?1:0],[Number.NEGATIVE_INFINITY],[T],[I]],q=C;C=t.runWebGLProgram(B,O,"int32",H),Tl(t,q)};for(let T=1;T<v;T*=2){const I=T*2;for(let $=T;$>=1;$/=2)A(I,$,[b,S])}for(let T=S;T>v;T/=2){const I=_(),$=new zme([b,T/2]),B=[[h],[C===null?1:0],[v]],V=C;C=t.runWebGLProgram($,I,"int32",B),Tl(t,V);const H=v/2,q=H*2;for(let P=H;P>=1;P/=2)A(q,P,C.shape)}let k=C;C=eh({inputs:{x:C},backend:t,attrs:{begin:0,size:[b,i]}}),Tl(t,k);let N=kF({inputs:{x:y,indices:C},backend:t,attrs:{axis:1,batchDims:1}});Tl(t,y);const D=c.slice(0,-1);D.push(i),k=C,C=Je({inputs:{x:C},attrs:{shape:D},backend:t}),Tl(t,k);const M=N;return N=Je({inputs:{x:N},attrs:{shape:D},backend:t}),Tl(t,M),[N,C]}const Vme={kernelName:iw,backendName:"webgl",kernelFunc:Bme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gme{constructor(e,t,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wme(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[h,d,p,m]=r.shape,[g,b]=c??[d,p],y=[h,g,b,m],v=new Gme(d,p,o,a,l,y);return t.runWebGLProgram(v,[r,i],"float32")}const Hme={kernelName:ow,backendName:"webgl",kernelFunc:Wme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xme(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;zf(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=Hoe(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const jme={kernelName:aw,backendName:"webgl",kernelFunc:Xme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qme(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],c=new Array(a-1);let h=0;for(let b=0;b<a;b++)b!==i&&(c[h++]=o.shape[b]);const d=[],p=new Array(a).fill(0),m=o.shape.slice();m[i]=1;const g=new Array(l);for(let b=0;b<g.length;b++){p[i]=b;const y=eh({inputs:{x:o},backend:t,attrs:{begin:p,size:m}}),v=Je({inputs:{x:y},backend:t,attrs:{shape:c}});g[b]=v,d.push(y)}return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),g}const Kme={kernelName:X0,backendName:"webgl",kernelFunc:qme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yme{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const l="0.0",c="sumValue",h=Math.floor(s/4)*4,d=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let m="";i%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let g="";i%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,l=[];let c=0;const h=zn([c],a);let d=r;h!=null&&(d=or({inputs:{x:r},backend:t,attrs:{perm:h}}),l.push(d),c=Yn(1,a)[0]);const p=bN(d.shape,c,o),m=Ne([d.shape[c]]),g=Je({inputs:{x:d},backend:t,attrs:{shape:[-1,m]}});l.push(g);const b=cw(r.dtype),y=(_,A,k,N,D)=>{const M=_.shape[0],T=_.shape[1],I=yN(T,D),$={windowSize:I,inSize:T,batchSize:M,numSegments:D},O=new Yme($,A),B=t.compileAndRun(O,[_,k],N);if(l.push(B),B.shape[1]===D)return B;const V=OF({backend:t,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),H=UF({inputs:{x:V},backend:t,attrs:{reps:[T/I]}});return l.push(V),l.push(H),y(B,A,H,N,D)},v=y(g,"unsortedSegmentSum",i,b,o),S=Je({inputs:{x:v},backend:t,attrs:{shape:p}});let C=S;if(h!=null){l.push(S);const _=Za(h);C=or({inputs:{x:C},backend:t,attrs:{perm:_}})}return l.forEach(_=>t.disposeIntermediateTensorInfo(_)),C}const Qme={kernelName:j0,backendName:"webgl",kernelFunc:Zme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jme=[Lae,Oae,Bae,Wae,Xae,Kae,Zae,Jae,sle,ile,lle,hle,ple,vle,Sle,_le,Ele,Mle,kle,Dle,Ple,Wle,Xle,Yle,Qle,rce,oce,uce,yae,fce,vce,wce,Ace,kce,Dce,Fce,Pce,Bce,Wce,jce,Kce,Zce,Jce,nue,rue,lue,uue,fue,gue,vue,wue,Tue,Rue,Due,Lue,Pue,Uue,Bue,Gue,Hue,jue,Zue,ehe,she,ihe,lhe,hhe,mhe,yhe,vae,She,gce,Che,Ihe,Rhe,Sae,$he,Ohe,zhe,Whe,jhe,Zhe,ede,rde,lde,hde,fde,xde,yde,Sde,Ede,Ide,Mde,kde,Dde,Pde,Bde,Hde,Jde,Cae,sfe,ofe,cfe,dfe,ece,mfe,xfe,yfe,wfe,Tfe,_ae,Afe,Rfe,Nfe,$fe,Ffe,tce,Kde,Ofe,Vfe,Xfe,Tae,Yfe,Jfe,spe,ope,upe,dpe,mpe,vpe,Spe,Cpe,Ipe,Rpe,$pe,Ppe,Bpe,Wpe,Vle,Zde,jpe,Kpe,Zpe,Jpe,tme,sme,ime,ame,cme,dme,pme,gme,vme,Sme,_me,Eme,Ime,Yde,Dae,Rme,Dme,Fme,Ome,Vme,Hme,$ae,jme,Kme,Qme,gfe];for(const n of Jme)NR(n);const RA={conway3d:{birth:[5,6,7],survival:[4,5,6]},life3d:{birth:[4,5],survival:[5,6,7]},stability:{birth:[4,5,6,7],survival:[3,4,5,6]},crystal:{birth:[5,6,7,8],survival:[5,6,7,8]},pyroclastic:{birth:[4,5,6,7],survival:[6,7,8]},diamoeba3d:{birth:[5,6,7,8],survival:[5,6,7,8,9,10]},hyper:{birth:[5,6,7],survival:[5,6,7,8,9,10]},briansbrain3d:{type:"special"},checkerboard:{type:"static"}},zF=(n,e,t)=>Array(n).fill().map(()=>Array(e).fill().map(()=>Array(t).fill(0)));class ege{constructor(){this.initialized=!1,this.gridTensor=null,this.size={x:0,y:0,z:0},this.currentRule="conway3d",this.convKernel=null,this.initTF()}async initTF(){console.log("[3DLogicTF] Initializing TensorFlow.js..."),_e().set("WEBGL_FORCE_F16_TEXTURES",!0),_e().set("WEBGL_PACK_BINARY_OPERATIONS",!0);try{const e=Hy();console.log(`[3DLogicTF] Current TensorFlow.js backend: ${e}`),e!=="webgl"&&(await W5("webgl"),console.log(`[3DLogicTF] Switched to WebGL backend: ${Hy()}`));const t=ZR();if(t.getGPGPUContext){const s=t.getGPGPUContext();console.log("[3DLogicTF] WebGL info:",{version:s.gl.getParameter(s.gl.VERSION),vendor:s.gl.getParameter(s.gl.VENDOR),renderer:s.gl.getParameter(s.gl.RENDERER)})}}catch(e){console.warn("[3DLogicTF] Could not set WebGL backend:",e),console.warn("[3DLogicTF] Using default backend:",Hy())}}initialize(e,t){this.gridTensor&&this.gridTensor.dispose(),this.convKernel&&this.convKernel.dispose(),this.currentRule=t;const s=e.length,r=e[0].length,i=e[0][0].length;this.size={x:s,y:r,z:i},console.log(`[3DLogicTF] Initializing with grid size ${s}x${r}x${i} and rule ${t}`);const o=new Float32Array(s*r*i);let a=0;for(let l=0;l<s;l++)for(let c=0;c<r;c++)for(let h=0;h<i;h++)o[a++]=e[l][c][h];this.gridTensor=f2(o,[s,r,i]),this.createConvolutionKernel(),this.initialized=!0,console.log("[3DLogicTF] Initialization complete")}createConvolutionKernel(){const t=new Float32Array(27);let s=0;for(let r=0;r<3;r++)for(let i=0;i<3;i++)for(let o=0;o<3;o++)t[s++]=r===1&&i===1&&o===1?0:1;this.convKernel=d7(t,[3,3,3,1,1])}updateGrid(e){if(!this.initialized){this.initialize(e,this.currentRule);return}const t=e.length,s=e[0].length,r=e[0][0].length;if(t!==this.size.x||s!==this.size.y||r!==this.size.z){console.log(`[3DLogicTF] Grid size changed from ${this.size.x}x${this.size.y}x${this.size.z} to ${t}x${s}x${r}`),this.initialize(e,this.currentRule);return}const i=new Float32Array(t*s*r);let o=0;for(let a=0;a<t;a++)for(let l=0;l<s;l++)for(let c=0;c<r;c++)i[o++]=e[a][l][c];this.gridTensor.dispose(),this.gridTensor=f2(i,[t,s,r])}processStandardRule(e,t){return be(()=>{const s=this.gridTensor.expandDims(3).expandDims(0),r=gb(s,this.convKernel,[1,1,1],"same","NDHWC",[1,1,1]).squeeze([0,4]),i=this.gridTensor,o=Array(27).fill(0),a=Array(27).fill(0);e.forEach(d=>{d>=0&&d<27&&(o[d]=1)}),t.forEach(d=>{d>=0&&d<27&&(a[d]=1)});const l=i.greater(.5),c=i.less(.5);let h=ls(i.shape);for(let d=0;d<=26;d++){const p=r.equal(d);if(o[d]>0){const g=c.logicalAnd(p).mul(en(1));h=h.add(g)}if(a[d]>0){const g=l.logicalAnd(p).mul(en(1));h=h.add(g)}}return h})}processBriansBrainRule(){return be(()=>{const e=this.gridTensor.expandDims(3).expandDims(0),t=gb(e,this.convKernel,[1,1,1],"same","NDHWC",[1,1,1]).squeeze([0,4]),s=this.gridTensor,r=s.less(.25),i=s.greater(.75);s.greater(.25).logicalAnd(s.less(.75));const o=t.equal(2),l=r.logicalAnd(o).mul(en(1)),c=i.mul(en(.5));return l.add(c)})}computeNextGeneration(){if(!this.initialized||!this.gridTensor)return console.warn("[3DLogicTF] Not initialized"),null;console.log(`[3DLogicTF] Computing next generation with rule: ${this.currentRule}`);let e;if(this.currentRule==="briansbrain3d")e=this.processBriansBrainRule();else if(this.currentRule==="checkerboard")e=this.gridTensor.clone();else{const l=RA[this.currentRule]||RA.conway3d;e=this.processStandardRule(l.birth,l.survival)}const[t,s,r]=e.shape,i=zF(t,s,r),o=e.dataSync();let a=0;for(let l=0;l<t;l++)for(let c=0;c<s;c++)for(let h=0;h<r;h++)if(this.currentRule==="briansbrain3d"){const d=o[a++];d>.75?i[l][c][h]=1:d>.25&&(i[l][c][h]=2)}else i[l][c][h]=Math.round(o[a++]);return this.gridTensor.dispose(),this.gridTensor=e,i}dispose(){this.gridTensor&&(this.gridTensor.dispose(),this.gridTensor=null),this.convKernel&&(this.convKernel.dispose(),this.convKernel=null),this.initialized=!1,console.log("[3DLogicTF] Resources disposed")}}let Yi=null;const tge=(n,e="conway3d")=>{if(!n||n.length===0||!n[0]||n[0].length===0||!n[0][0]||n[0][0].length===0)return console.warn("[automataLogic3DTF] Invalid or empty 3D grid provided."),zF(1,1,1);Yi||(console.log("[automataLogic3DTF] Creating new TensorFlow.js instance"),Yi=new ege);const t=n.length,s=n[0].length,r=n[0][0].length;return!Yi.initialized||Yi.size.x!==t||Yi.size.y!==s||Yi.size.z!==r||Yi.currentRule!==e?(console.log(`[automataLogic3DTF] Initializing TensorFlow compute. Size: ${t}x${s}x${r}, Rule: ${e}`),Yi.initialize(n,e)):Yi.updateGrid(n),Yi.computeNextGeneration()},nge=(n,e,t)=>Array(n).fill().map(()=>Array(e).fill().map(()=>Array(t).fill(0))),Pb=n=>n&&Array.isArray(n)&&n.length>0&&Array.isArray(n[0])&&n[0].length>0&&Array.isArray(n[0][0])&&n[0][0].length>0,BF=async()=>{if(typeof navigator>"u"||!navigator.gpu)return console.warn("[3DLogicWebGPU] WebGPU is not supported in this browser"),!1;try{const n=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});return n?(console.log("[3DLogicWebGPU] WebGPU adapter found"),await n.requestDevice()?(console.log("[3DLogicWebGPU] WebGPU is supported"),!0):(console.warn("[3DLogicWebGPU] Failed to request WebGPU device"),!1)):(console.warn("[3DLogicWebGPU] No WebGPU adapter found"),!1)}catch(n){return console.error("[3DLogicWebGPU] Error checking WebGPU support:",n),!1}};let Qi=0;const sge=async(n,e="conway3d")=>{if(!Pb(n))return console.error("[WebGPU] Invalid or empty 3D grid provided"),nge(1,1,1);Qi++,console.log(`[WebGPU] Generation ${Qi} - Computing with rule: ${e}`);try{if(!await BF()){console.warn("[WebGPU] WebGPU not supported, falling back to WebGL implementation");const r=li(n,e);return l1(r,e,n),r}console.log("[WebGPU] NOTICE: Using WebGL implementation while WebGPU is being debugged");const s=li(n,e);return console.log("[WebGPU] Using WebGL for computation in WebGPU mode"),l1(s,e,n),s}catch(t){console.error("[WebGPU] Error computing next generation:",t),console.warn("[WebGPU] Error in WebGPU computation, falling back to WebGL implementation");const s=li(n,e);return l1(s,e,n),s}},l1=(n,e,t)=>{if(!Pb(n)||!Pb(t)){console.warn("[WebGPU] Cannot log results: invalid grid data");return}console.log(`[WebGPU] Generation ${Qi} - Input grid sample:`);for(let r=0;r<Math.min(3,t.length);r++)for(let i=0;i<Math.min(3,t[0].length);i++)for(let o=0;o<Math.min(3,t[0][0].length);o++)t[r][i][o]>0,console.log(`  Cell at (${r},${i},${o}): ${t[r][i][o]}`);console.log(`[WebGPU] Generation ${Qi} - Result grid sample:`);for(let r=0;r<Math.min(3,n.length);r++)for(let i=0;i<Math.min(3,n[0].length);i++)for(let o=0;o<Math.min(3,n[0][0].length);o++)n[r][i][o]>0,console.log(`  Cell at (${r},${i},${o}): ${n[r][i][o]}`);let s=0;for(let r=0;r<n.length;r++)for(let i=0;i<n[0].length;i++)for(let o=0;o<n[0][0].length;o++)n[r][i][o]>0&&s++;if(console.log(`[WebGPU] Generation ${Qi} - Total active cells: ${s}`),Qi<=3){console.log(`[WebGPU-Test] GENERATION ${Qi} DATA FOR COMPARISON`),console.log(`Rule: ${e}, Active cells: ${s}`),console.log("[WebGPU-Test] Corner region (0,0,0) to (2,2,2):");for(let c=0;c<Math.min(3,n.length);c++)for(let h=0;h<Math.min(3,n[0].length);h++)for(let d=0;d<Math.min(3,n[0][0].length);d++)console.log(`  Cell at (${c},${h},${d}): ${n[c][h][d]}`);const r=Math.floor(n.length/2),i=Math.floor(n[0].length/2),o=Math.floor(n[0][0].length/2);console.log(`[WebGPU-Test] Center region (${r-1},${i-1},${o-1}) to (${r+1},${i+1},${o+1}):`);for(let c=r-1;c<=r+1;c++)for(let h=i-1;h<=i+1;h++)for(let d=o-1;d<=o+1;d++)c>=0&&c<n.length&&h>=0&&h<n[0].length&&d>=0&&d<n[0][0].length&&console.log(`  Cell at (${c},${h},${d}): ${n[c][h][d]}`);let a="";[[0,0,0],[r,i,o],[n.length-1,n[0].length-1,n[0][0].length-1],[Math.floor(r/2),Math.floor(i/2),Math.floor(o/2)],[r+Math.floor((n.length-r)/2),i,o]].forEach(([c,h,d])=>{c>=0&&c<n.length&&h>=0&&h<n[0].length&&d>=0&&d<n[0][0].length&&(a+=n[c][h][d])}),console.log(`[WebGPU-Test] Generation ${Qi} fingerprint: ${a}`)}Qi>=3&&(Qi=0)},c1=200,rge=51,kA=200,ige=50,oge=50,zm=20,NA=(n=rge)=>{const e=Array(n).fill(0);return n>0&&(e[Math.floor(n/2)]=1),e},DA=()=>{const n=Array(ige).fill(null).map(()=>Array(oge).fill(0));return n[1][2]=1,n[2][3]=1,n[3][1]=1,n[3][2]=1,n[3][3]=1,n};function age(){const[n,e]=Ae.useState("1d"),[t,s]=Ae.useState(30),[r,i]=Ae.useState([NA()]),[o,a]=Ae.useState(!1),[l,c]=Ae.useState(0),[h,d]=Ae.useState(c1),[p,m]=Ae.useState(DA()),[g,b]=Ae.useState(!1),[y,v]=Ae.useState(0),[S,C]=Ae.useState("conway"),[_,A]=Ae.useState(c1),[k,N]=Ae.useState(zm),[D,M]=Ae.useState(()=>{console.log("[App] Creating initial 3D grid...");const Ye=Tm(zm,zm,zm);return console.log("[App] Initial 3D grid created with dimensions:",Ye.length,"x",Ye[0].length,"x",Ye[0][0].length),Ye}),[T,I]=Ae.useState(!1),[$,O]=Ae.useState(0),[B,V]=Ae.useState("checkerboard"),[H,q]=Ae.useState(20),[P,K]=Ae.useState(0),[Z,U]=Ae.useState(1),[z,ne]=Ae.useState("#4CAF50"),[Y,te]=Ae.useState("standard"),[he,se]=Ae.useState(!1),[Q,de]=Ae.useState(c1),[ce,De]=Ae.useState(!1),[He,Le]=Ae.useState(!1),[j,ht]=Ae.useState("webgl"),[We,Ke]=Ae.useState({x:0,y:0}),[Oe,yt]=Ae.useState(!1);console.log("[App] App rendering/re-rendering. Active view:",n);const Ve=Ye=>{console.log(`[App] Switching view to ${Ye}...`),a(!1),b(!1),I(!1),e(Ye)},X=Ae.useCallback(()=>{a(!0)},[]),L=Ae.useCallback(()=>{a(!1)},[]),ge=Ae.useCallback(()=>{a(!1),i([NA()]),c(0)},[]),Re=Ae.useCallback(Ye=>{const Bt=Ye===""||isNaN(parseInt(Ye,10))?0:parseInt(Ye,10);s(Math.max(0,Math.min(255,Bt))),ge()},[ge]),$e=Ae.useCallback(Ye=>{d(Ye)},[]),Ie=Ae.useCallback((Ye,Bt)=>{!o&&Ye===0&&r.length>0&&i(es=>{const xn=[...es[0]];xn[Bt]=xn[Bt]===0?1:0;const ts=[...es];return ts[0]=xn,ts})},[o,r]),Xe=Ae.useCallback(()=>{b(!0)},[]),ze=Ae.useCallback(()=>{b(!1)},[]),et=Ae.useCallback(()=>{b(!1),m(DA()),v(0)},[]),ut=Ae.useCallback(Ye=>{console.log(`[App] Changing 2D rule to ${Ye}`),C(Ye),b(!1)},[]),Pe=Ae.useCallback(Ye=>{A(Ye)},[]),lt=Ae.useCallback(()=>{I(!0)},[]),wt=Ae.useCallback(()=>{I(!1)},[]),Et=Ae.useCallback(()=>{I(!1),M(Tm(k,k,k,B==="checkerboard"?"checkerboard":B==="briansbrain3d"?"random":"sphere")),O(0)},[B,k]),ct=Ae.useCallback(Ye=>{console.log(`[App] Changing 3D rule to ${Ye}`),V(Ye),I(!1),M(Tm(k,k,k,Ye==="checkerboard"?"checkerboard":Ye==="briansbrain3d"?"random":"sphere")),O(0)},[k]),Ot=Ae.useCallback(Ye=>{q(Ye)},[]),$t=Ae.useCallback(Ye=>{K(Ye)},[]),hn=Ae.useCallback(Ye=>{U(Ye)},[]),ue=Ae.useCallback(Ye=>{ne(Ye)},[]),tt=Ae.useCallback(Ye=>{te(Ye)},[]),ke=Ae.useCallback(Ye=>{se(Ye)},[]),Fe=Ae.useCallback(Ye=>{de(Ye)},[]),it=Ae.useCallback(Ye=>{De(Ye)},[]),nt=Ae.useCallback(Ye=>{Le(Ye)},[]),Pt=Ae.useCallback(Ye=>{console.log(`[App] Changing GPU backend to ${Ye}`),ht(Ye)},[]),Sn=Ae.useCallback(Ye=>{console.log("[App] Updating scene rotation:",Ye),Ke(Ye)},[]),Jn=Ae.useCallback(Ye=>{Ye!==k&&(N(Ye),T||(M(Tm(Ye,Ye,Ye,B==="checkerboard"?"checkerboard":B==="briansbrain3d"?"random":"sphere")),O(0)))},[k,T,B]),tn=Ae.useCallback((Ye,Bt)=>{console.log("[App] handleCellToggle2D: Called with rowIndex, colIndex",Ye,Bt,"isRunning2D:",g),g||m(es=>{console.log("[App] handleCellToggle2D: grid2D state before toggle for cell",Ye,Bt,"Value:",es[Ye]?es[Ye][Bt]:"undefined");const xn=es.map(ts=>[...ts]);return Ye>=0&&Ye<xn.length&&Bt>=0&&Bt<xn[0].length&&(xn[Ye][Bt]=xn[Ye][Bt]===0?1:0,console.log("[App] handleCellToggle2D: newGrid state after toggle for cell",Ye,Bt,"New Value:",xn[Ye][Bt])),xn})},[g]);Ae.useEffect(()=>{if(n==="1d"&&o){const Ye=setInterval(()=>{i(Bt=>{const es=Bt[Bt.length-1],xn=BP(es,t),ts=[...Bt,xn];return ts.length>kA?ts.slice(ts.length-kA):ts}),c(Bt=>Bt+1)},h);return()=>clearInterval(Ye)}},[n,o,t,h]),Ae.useEffect(()=>{if(console.log("[App] 2D Simulation useEffect triggered. isRunning2D:",g,"activeView:",n,"rule2D:",S),n==="2d"&&g){if(!p||p.length===0){console.warn("2D Simulation cannot start with an empty or invalid 2D grid."),b(!1);return}const Ye=setInterval(()=>{console.log("[App] Simulation tick: updating grid2D via calculateNextGeneration2D with rule:",S),m(Bt=>Fz(Bt,S)),v(Bt=>Bt+1)},_);return()=>clearInterval(Ye)}},[n,g,p,S,_]),Ae.useEffect(()=>{if(console.log("[App] 3D Simulation useEffect triggered. isRunning3D:",T,"activeView:",n,"rule3D:",B,"gpuBackend:",j),n==="3d"&&T){if(!D||D.length===0){console.warn("3D Simulation cannot start with an empty or invalid 3D grid."),I(!1);return}let Ye;j==="tensorflow"?Ye=tge:j==="webgpu"&&Oe?Ye=sge:Ye=li;const Bt=j==="webgpu"&&!Oe?"webgl (WebGPU fallback)":j;console.log(`[App] Using ${Bt} backend for simulation calculations`);const es=setInterval(async()=>{if(console.log(`[App] Simulation tick: updating grid3D via ${Bt} backend with rule:`,B),j==="webgpu"&&Oe)try{const xn=await Ye(D,B);M(xn),O(ts=>ts+1)}catch(xn){console.error("[App] Error in WebGPU calculation:",xn)}else M(xn=>Ye(xn,B)),O(xn=>xn+1)},Q);return()=>clearInterval(es)}},[n,T,D,B,Q,j]),Ae.useEffect(()=>{(async()=>{try{console.log("[App] Checking WebGPU support..."),await new Promise(es=>setTimeout(es,100));const Bt=await BF();console.log(`[App] WebGPU supported: ${Bt}`),yt(Bt),!Bt&&j==="webgpu"&&(console.warn("[App] WebGPU selected but not supported. Falling back to WebGL."),ht("webgl"))}catch(Bt){console.warn("[App] Error checking WebGPU support:",Bt),yt(!1),j==="webgpu"&&(console.warn("[App] Falling back to WebGL due to WebGPU error."),ht("webgl"))}})()},[j]);const Cn={appHeader:{backgroundColor:"#004085",padding:"15px",color:"white",marginBottom:"25px",width:"100%",textAlign:"center",borderRadius:"4px 4px 0 0"},viewSwitcher:{marginBottom:"20px",display:"flex",justifyContent:"center",gap:"10px"},automatonDisplayContainer:{display:"flex",flexDirection:"column",alignItems:"center",marginTop:"20px",padding:"10px",border:"1px solid #eee",borderRadius:"4px",backgroundColor:"#fdfdfd"},statusText:{marginTop:"10px",fontSize:"0.9em",color:"#555"}};return pe.jsxs("div",{className:"app-container",children:[pe.jsx("header",{style:Cn.appHeader,children:pe.jsx("h1",{style:{color:"white"},children:n==="1d"?"1D Cellular Automaton":n==="2d"?"2D Cellular Automaton":"3D Cellular Automaton"})}),pe.jsxs("div",{style:Cn.viewSwitcher,children:[pe.jsx("button",{onClick:()=>Ve("1d"),disabled:n==="1d",children:"1D"}),pe.jsx("button",{onClick:()=>Ve("2d"),disabled:n==="2d",children:"2D"}),pe.jsx("button",{onClick:()=>Ve("3d"),disabled:n==="3d",children:"3D"})]}),n==="1d"&&pe.jsxs(pe.Fragment,{children:[pe.jsx(UP,{onStart:X,onPause:L,onReset:ge,onRuleChange:Re,currentRule:t,isRunning:o,simulationSpeed:h,onSpeedChange:$e}),pe.jsxs("div",{style:Cn.automatonDisplayContainer,children:[pe.jsx(OP,{generationsHistory:r,onCellClick:Ie}),pe.jsxs("p",{style:Cn.statusText,children:["Generation: ",l]}),pe.jsxs("p",{style:Cn.statusText,children:["Rule: ",t]})]})]}),n==="2d"&&pe.jsxs(pe.Fragment,{children:[pe.jsx(Nz,{onStart:Xe,onPause:ze,onReset:et,isRunning:g,currentRule:S,onRuleChange:ut,simulationSpeed:_,onSpeedChange:Pe}),pe.jsxs("div",{style:Cn.automatonDisplayContainer,children:[pe.jsx(Rz,{currentGrid:p,onCellToggle:tn}),pe.jsxs("p",{style:Cn.statusText,children:["Generation: ",y]}),pe.jsxs("p",{style:Cn.statusText,children:["Rule: ",S]})]})]}),n==="3d"&&pe.jsxs(pe.Fragment,{children:[pe.jsx(YH,{onStart:lt,onPause:wt,onReset:Et,isRunning:T,currentRule:B,onRuleChange:ct,cameraDistance:H,onCameraDistanceChange:Ot,rotationSpeed:P,onRotationSpeedChange:$t,gridSize:k,onGridSizeChange:Jn,cubeOpacity:Z,onCubeOpacityChange:hn,cubeColor:z,onCubeColorChange:ue,materialType:Y,onMaterialTypeChange:tt,showHelpers:he,onToggleHelpers:ke,simulationSpeed:Q,onSpeedChange:Fe,useInstancedRendering:ce,onInstancedRenderingToggle:it,showStats:He,onToggleStats:nt,gpuBackend:j,onGpuBackendChange:Pt}),pe.jsxs("div",{style:Cn.automatonDisplayContainer,children:[ce?pe.jsx(XH,{gridData:D,width:600,height:500,cameraDistance:H,rotationSpeed:P,cubeOpacity:Z,cubeColor:z,materialType:Y,showHelpers:he,showStats:He,initialRotation:We,onRotationChange:Sn,onCameraDistanceChange:Ot}):pe.jsx(WH,{gridData:D,width:600,height:500,cameraDistance:H,rotationSpeed:P,cubeOpacity:Z,cubeColor:z,materialType:Y,showHelpers:he,initialRotation:We,onRotationChange:Sn,onCameraDistanceChange:Ot}),pe.jsxs("p",{style:Cn.statusText,children:["Generation: ",$]}),pe.jsxs("p",{style:Cn.statusText,children:["Rule: ",B]}),pe.jsxs("div",{style:{display:"flex",alignItems:"center",justifyContent:"center",gap:"5px",padding:"5px 10px",backgroundColor:ce?"#8e44ad20":"#00aa4420",borderRadius:"4px",margin:"5px 0"},children:[pe.jsx("div",{style:{width:"10px",height:"10px",borderRadius:"50%",backgroundColor:ce?"#8e44ad":"#00aa44",boxShadow:ce?"0 0 5px #8e44ad":"0 0 5px #00aa44"}}),pe.jsxs("p",{style:{...Cn.statusText,color:ce?"#8e44ad":"#00aa44",fontWeight:"bold",margin:0},children:["GPU Accelerated ",ce?"(Instanced Rendering)":"",k>30?`(${k}³ High Resolution)`:""]}),pe.jsxs("div",{style:{marginLeft:"10px",backgroundColor:j==="tensorflow"?"#0d6efd":j==="webgpu"?Oe?"#ff5900":"#ff590080":"#4CAF50",color:"white",fontSize:"0.7em",padding:"2px 6px",borderRadius:"4px",fontWeight:"bold",display:"flex",alignItems:"center"},children:[j==="tensorflow"?"TensorFlow.js":j==="webgpu"?Oe?"WebGPU Compute (Dev Mode)":"WebGPU (Falling back to WebGL)":"WebGL Shaders",j==="webgpu"&&Oe&&pe.jsx("span",{style:{display:"inline-block",width:"8px",height:"8px",borderRadius:"50%",backgroundColor:"#ffcc00",marginLeft:"5px",animation:"blink 1s infinite"}}),j==="webgpu"&&!Oe&&pe.jsx("span",{style:{display:"inline-block",width:"8px",height:"8px",borderRadius:"50%",backgroundColor:"#ffcc00",marginLeft:"5px"}})]})]})]})]})]})}NP.createRoot(document.getElementById("root")).render(pe.jsx(EP.StrictMode,{children:pe.jsx(age,{})}));
